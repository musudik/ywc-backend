
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Child
 * 
 */
export type Child = $Result.DefaultSelection<Prisma.$ChildPayload>
/**
 * Model Applicant
 * 
 */
export type Applicant = $Result.DefaultSelection<Prisma.$ApplicantPayload>
/**
 * Model ImmobillionApplicantDetails
 * 
 */
export type ImmobillionApplicantDetails = $Result.DefaultSelection<Prisma.$ImmobillionApplicantDetailsPayload>
/**
 * Model ImmobillionForm
 * 
 */
export type ImmobillionForm = $Result.DefaultSelection<Prisma.$ImmobillionFormPayload>
/**
 * Model AnalysisForm
 * 
 */
export type AnalysisForm = $Result.DefaultSelection<Prisma.$AnalysisFormPayload>
/**
 * Model PersonalDetails
 * 
 */
export type PersonalDetails = $Result.DefaultSelection<Prisma.$PersonalDetailsPayload>
/**
 * Model EmploymentDetails
 * 
 */
export type EmploymentDetails = $Result.DefaultSelection<Prisma.$EmploymentDetailsPayload>
/**
 * Model IncomeDetails
 * 
 */
export type IncomeDetails = $Result.DefaultSelection<Prisma.$IncomeDetailsPayload>
/**
 * Model ExpensesDetails
 * 
 */
export type ExpensesDetails = $Result.DefaultSelection<Prisma.$ExpensesDetailsPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Liability
 * 
 */
export type Liability = $Result.DefaultSelection<Prisma.$LiabilityPayload>
/**
 * Model GoalsAndWishes
 * 
 */
export type GoalsAndWishes = $Result.DefaultSelection<Prisma.$GoalsAndWishesPayload>
/**
 * Model RiskAppetite
 * 
 */
export type RiskAppetite = $Result.DefaultSelection<Prisma.$RiskAppetitePayload>
/**
 * Model Consent
 * 
 */
export type Consent = $Result.DefaultSelection<Prisma.$ConsentPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Form
 * 
 */
export type Form = $Result.DefaultSelection<Prisma.$FormPayload>
/**
 * Model CustomForm
 * 
 */
export type CustomForm = $Result.DefaultSelection<Prisma.$CustomFormPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ApplicantType: {
  PrimaryApplicant: 'PrimaryApplicant',
  SecondaryApplicant: 'SecondaryApplicant'
};

export type ApplicantType = (typeof ApplicantType)[keyof typeof ApplicantType]


export const EmploymentType: {
  PrimaryEmployment: 'PrimaryEmployment',
  SecondaryEmployment: 'SecondaryEmployment'
};

export type EmploymentType = (typeof EmploymentType)[keyof typeof EmploymentType]


export const LoanType: {
  PersonalLoan: 'PersonalLoan',
  HomeLoan: 'HomeLoan',
  CarLoan: 'CarLoan',
  BusinessLoan: 'BusinessLoan',
  EducationLoan: 'EducationLoan',
  OtherLoan: 'OtherLoan'
};

export type LoanType = (typeof LoanType)[keyof typeof LoanType]


export const ConsentType: {
  Analysis: 'Analysis',
  Immobillion: 'Immobillion',
  PrivateHealthInsurance: 'PrivateHealthInsurance',
  StateHealthInsurance: 'StateHealthInsurance',
  KFZ: 'KFZ',
  Electricity: 'Electricity',
  Loans: 'Loans',
  Sanuspay: 'Sanuspay',
  Gems: 'Gems',
  Other: 'Other'
};

export type ConsentType = (typeof ConsentType)[keyof typeof ConsentType]


export const FormType: {
  Analysis: 'Analysis',
  Immobillion: 'Immobillion',
  PrivateHealthInsurance: 'PrivateHealthInsurance',
  StateHealthInsurance: 'StateHealthInsurance',
  KFZ: 'KFZ',
  Electricity: 'Electricity',
  Loans: 'Loans',
  Sanuspay: 'Sanuspay',
  Gems: 'Gems',
  Other: 'Other'
};

export type FormType = (typeof FormType)[keyof typeof FormType]

}

export type ApplicantType = $Enums.ApplicantType

export const ApplicantType: typeof $Enums.ApplicantType

export type EmploymentType = $Enums.EmploymentType

export const EmploymentType: typeof $Enums.EmploymentType

export type LoanType = $Enums.LoanType

export const LoanType: typeof $Enums.LoanType

export type ConsentType = $Enums.ConsentType

export const ConsentType: typeof $Enums.ConsentType

export type FormType = $Enums.FormType

export const FormType: typeof $Enums.FormType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.child`: Exposes CRUD operations for the **Child** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Children
    * const children = await prisma.child.findMany()
    * ```
    */
  get child(): Prisma.ChildDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicant`: Exposes CRUD operations for the **Applicant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicants
    * const applicants = await prisma.applicant.findMany()
    * ```
    */
  get applicant(): Prisma.ApplicantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.immobillionApplicantDetails`: Exposes CRUD operations for the **ImmobillionApplicantDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImmobillionApplicantDetails
    * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.findMany()
    * ```
    */
  get immobillionApplicantDetails(): Prisma.ImmobillionApplicantDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.immobillionForm`: Exposes CRUD operations for the **ImmobillionForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImmobillionForms
    * const immobillionForms = await prisma.immobillionForm.findMany()
    * ```
    */
  get immobillionForm(): Prisma.ImmobillionFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analysisForm`: Exposes CRUD operations for the **AnalysisForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalysisForms
    * const analysisForms = await prisma.analysisForm.findMany()
    * ```
    */
  get analysisForm(): Prisma.AnalysisFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalDetails`: Exposes CRUD operations for the **PersonalDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalDetails
    * const personalDetails = await prisma.personalDetails.findMany()
    * ```
    */
  get personalDetails(): Prisma.PersonalDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employmentDetails`: Exposes CRUD operations for the **EmploymentDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmploymentDetails
    * const employmentDetails = await prisma.employmentDetails.findMany()
    * ```
    */
  get employmentDetails(): Prisma.EmploymentDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incomeDetails`: Exposes CRUD operations for the **IncomeDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomeDetails
    * const incomeDetails = await prisma.incomeDetails.findMany()
    * ```
    */
  get incomeDetails(): Prisma.IncomeDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expensesDetails`: Exposes CRUD operations for the **ExpensesDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpensesDetails
    * const expensesDetails = await prisma.expensesDetails.findMany()
    * ```
    */
  get expensesDetails(): Prisma.ExpensesDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liability`: Exposes CRUD operations for the **Liability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Liabilities
    * const liabilities = await prisma.liability.findMany()
    * ```
    */
  get liability(): Prisma.LiabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goalsAndWishes`: Exposes CRUD operations for the **GoalsAndWishes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoalsAndWishes
    * const goalsAndWishes = await prisma.goalsAndWishes.findMany()
    * ```
    */
  get goalsAndWishes(): Prisma.GoalsAndWishesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.riskAppetite`: Exposes CRUD operations for the **RiskAppetite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskAppetites
    * const riskAppetites = await prisma.riskAppetite.findMany()
    * ```
    */
  get riskAppetite(): Prisma.RiskAppetiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consent`: Exposes CRUD operations for the **Consent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consents
    * const consents = await prisma.consent.findMany()
    * ```
    */
  get consent(): Prisma.ConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **Form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.FormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customForm`: Exposes CRUD operations for the **CustomForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomForms
    * const customForms = await prisma.customForm.findMany()
    * ```
    */
  get customForm(): Prisma.CustomFormDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Child: 'Child',
    Applicant: 'Applicant',
    ImmobillionApplicantDetails: 'ImmobillionApplicantDetails',
    ImmobillionForm: 'ImmobillionForm',
    AnalysisForm: 'AnalysisForm',
    PersonalDetails: 'PersonalDetails',
    EmploymentDetails: 'EmploymentDetails',
    IncomeDetails: 'IncomeDetails',
    ExpensesDetails: 'ExpensesDetails',
    Asset: 'Asset',
    Liability: 'Liability',
    GoalsAndWishes: 'GoalsAndWishes',
    RiskAppetite: 'RiskAppetite',
    Consent: 'Consent',
    Document: 'Document',
    Form: 'Form',
    CustomForm: 'CustomForm'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "child" | "applicant" | "immobillionApplicantDetails" | "immobillionForm" | "analysisForm" | "personalDetails" | "employmentDetails" | "incomeDetails" | "expensesDetails" | "asset" | "liability" | "goalsAndWishes" | "riskAppetite" | "consent" | "document" | "form" | "customForm"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Child: {
        payload: Prisma.$ChildPayload<ExtArgs>
        fields: Prisma.ChildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          findFirst: {
            args: Prisma.ChildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          findMany: {
            args: Prisma.ChildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          create: {
            args: Prisma.ChildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          createMany: {
            args: Prisma.ChildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          delete: {
            args: Prisma.ChildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          update: {
            args: Prisma.ChildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          deleteMany: {
            args: Prisma.ChildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChildUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          upsert: {
            args: Prisma.ChildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          aggregate: {
            args: Prisma.ChildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChild>
          }
          groupBy: {
            args: Prisma.ChildGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChildGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChildCountArgs<ExtArgs>
            result: $Utils.Optional<ChildCountAggregateOutputType> | number
          }
        }
      }
      Applicant: {
        payload: Prisma.$ApplicantPayload<ExtArgs>
        fields: Prisma.ApplicantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          findFirst: {
            args: Prisma.ApplicantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          findMany: {
            args: Prisma.ApplicantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
          }
          create: {
            args: Prisma.ApplicantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          createMany: {
            args: Prisma.ApplicantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
          }
          delete: {
            args: Prisma.ApplicantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          update: {
            args: Prisma.ApplicantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          deleteMany: {
            args: Prisma.ApplicantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
          }
          upsert: {
            args: Prisma.ApplicantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          aggregate: {
            args: Prisma.ApplicantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicant>
          }
          groupBy: {
            args: Prisma.ApplicantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicantCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicantCountAggregateOutputType> | number
          }
        }
      }
      ImmobillionApplicantDetails: {
        payload: Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>
        fields: Prisma.ImmobillionApplicantDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImmobillionApplicantDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImmobillionApplicantDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>
          }
          findFirst: {
            args: Prisma.ImmobillionApplicantDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImmobillionApplicantDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>
          }
          findMany: {
            args: Prisma.ImmobillionApplicantDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>[]
          }
          create: {
            args: Prisma.ImmobillionApplicantDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>
          }
          createMany: {
            args: Prisma.ImmobillionApplicantDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImmobillionApplicantDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>[]
          }
          delete: {
            args: Prisma.ImmobillionApplicantDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>
          }
          update: {
            args: Prisma.ImmobillionApplicantDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>
          }
          deleteMany: {
            args: Prisma.ImmobillionApplicantDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImmobillionApplicantDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImmobillionApplicantDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>[]
          }
          upsert: {
            args: Prisma.ImmobillionApplicantDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionApplicantDetailsPayload>
          }
          aggregate: {
            args: Prisma.ImmobillionApplicantDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImmobillionApplicantDetails>
          }
          groupBy: {
            args: Prisma.ImmobillionApplicantDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImmobillionApplicantDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImmobillionApplicantDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<ImmobillionApplicantDetailsCountAggregateOutputType> | number
          }
        }
      }
      ImmobillionForm: {
        payload: Prisma.$ImmobillionFormPayload<ExtArgs>
        fields: Prisma.ImmobillionFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImmobillionFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImmobillionFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>
          }
          findFirst: {
            args: Prisma.ImmobillionFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImmobillionFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>
          }
          findMany: {
            args: Prisma.ImmobillionFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>[]
          }
          create: {
            args: Prisma.ImmobillionFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>
          }
          createMany: {
            args: Prisma.ImmobillionFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImmobillionFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>[]
          }
          delete: {
            args: Prisma.ImmobillionFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>
          }
          update: {
            args: Prisma.ImmobillionFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>
          }
          deleteMany: {
            args: Prisma.ImmobillionFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImmobillionFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImmobillionFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>[]
          }
          upsert: {
            args: Prisma.ImmobillionFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmobillionFormPayload>
          }
          aggregate: {
            args: Prisma.ImmobillionFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImmobillionForm>
          }
          groupBy: {
            args: Prisma.ImmobillionFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImmobillionFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImmobillionFormCountArgs<ExtArgs>
            result: $Utils.Optional<ImmobillionFormCountAggregateOutputType> | number
          }
        }
      }
      AnalysisForm: {
        payload: Prisma.$AnalysisFormPayload<ExtArgs>
        fields: Prisma.AnalysisFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>
          }
          findFirst: {
            args: Prisma.AnalysisFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>
          }
          findMany: {
            args: Prisma.AnalysisFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>[]
          }
          create: {
            args: Prisma.AnalysisFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>
          }
          createMany: {
            args: Prisma.AnalysisFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>[]
          }
          delete: {
            args: Prisma.AnalysisFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>
          }
          update: {
            args: Prisma.AnalysisFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>
          }
          deleteMany: {
            args: Prisma.AnalysisFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalysisFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>[]
          }
          upsert: {
            args: Prisma.AnalysisFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisFormPayload>
          }
          aggregate: {
            args: Prisma.AnalysisFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysisForm>
          }
          groupBy: {
            args: Prisma.AnalysisFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisFormCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisFormCountAggregateOutputType> | number
          }
        }
      }
      PersonalDetails: {
        payload: Prisma.$PersonalDetailsPayload<ExtArgs>
        fields: Prisma.PersonalDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          findFirst: {
            args: Prisma.PersonalDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          findMany: {
            args: Prisma.PersonalDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>[]
          }
          create: {
            args: Prisma.PersonalDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          createMany: {
            args: Prisma.PersonalDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>[]
          }
          delete: {
            args: Prisma.PersonalDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          update: {
            args: Prisma.PersonalDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          deleteMany: {
            args: Prisma.PersonalDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>[]
          }
          upsert: {
            args: Prisma.PersonalDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          aggregate: {
            args: Prisma.PersonalDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalDetails>
          }
          groupBy: {
            args: Prisma.PersonalDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalDetailsCountAggregateOutputType> | number
          }
        }
      }
      EmploymentDetails: {
        payload: Prisma.$EmploymentDetailsPayload<ExtArgs>
        fields: Prisma.EmploymentDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmploymentDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmploymentDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          findFirst: {
            args: Prisma.EmploymentDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmploymentDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          findMany: {
            args: Prisma.EmploymentDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>[]
          }
          create: {
            args: Prisma.EmploymentDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          createMany: {
            args: Prisma.EmploymentDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmploymentDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>[]
          }
          delete: {
            args: Prisma.EmploymentDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          update: {
            args: Prisma.EmploymentDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          deleteMany: {
            args: Prisma.EmploymentDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmploymentDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmploymentDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>[]
          }
          upsert: {
            args: Prisma.EmploymentDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          aggregate: {
            args: Prisma.EmploymentDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmploymentDetails>
          }
          groupBy: {
            args: Prisma.EmploymentDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmploymentDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmploymentDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<EmploymentDetailsCountAggregateOutputType> | number
          }
        }
      }
      IncomeDetails: {
        payload: Prisma.$IncomeDetailsPayload<ExtArgs>
        fields: Prisma.IncomeDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomeDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomeDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>
          }
          findFirst: {
            args: Prisma.IncomeDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomeDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>
          }
          findMany: {
            args: Prisma.IncomeDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>[]
          }
          create: {
            args: Prisma.IncomeDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>
          }
          createMany: {
            args: Prisma.IncomeDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncomeDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>[]
          }
          delete: {
            args: Prisma.IncomeDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>
          }
          update: {
            args: Prisma.IncomeDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>
          }
          deleteMany: {
            args: Prisma.IncomeDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomeDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncomeDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>[]
          }
          upsert: {
            args: Prisma.IncomeDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeDetailsPayload>
          }
          aggregate: {
            args: Prisma.IncomeDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncomeDetails>
          }
          groupBy: {
            args: Prisma.IncomeDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomeDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncomeDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<IncomeDetailsCountAggregateOutputType> | number
          }
        }
      }
      ExpensesDetails: {
        payload: Prisma.$ExpensesDetailsPayload<ExtArgs>
        fields: Prisma.ExpensesDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpensesDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpensesDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>
          }
          findFirst: {
            args: Prisma.ExpensesDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpensesDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>
          }
          findMany: {
            args: Prisma.ExpensesDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>[]
          }
          create: {
            args: Prisma.ExpensesDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>
          }
          createMany: {
            args: Prisma.ExpensesDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpensesDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>[]
          }
          delete: {
            args: Prisma.ExpensesDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>
          }
          update: {
            args: Prisma.ExpensesDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>
          }
          deleteMany: {
            args: Prisma.ExpensesDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpensesDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpensesDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>[]
          }
          upsert: {
            args: Prisma.ExpensesDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesDetailsPayload>
          }
          aggregate: {
            args: Prisma.ExpensesDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpensesDetails>
          }
          groupBy: {
            args: Prisma.ExpensesDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpensesDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpensesDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<ExpensesDetailsCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Liability: {
        payload: Prisma.$LiabilityPayload<ExtArgs>
        fields: Prisma.LiabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          findFirst: {
            args: Prisma.LiabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          findMany: {
            args: Prisma.LiabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
          }
          create: {
            args: Prisma.LiabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          createMany: {
            args: Prisma.LiabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
          }
          delete: {
            args: Prisma.LiabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          update: {
            args: Prisma.LiabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          deleteMany: {
            args: Prisma.LiabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
          }
          upsert: {
            args: Prisma.LiabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          aggregate: {
            args: Prisma.LiabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiability>
          }
          groupBy: {
            args: Prisma.LiabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiabilityCountArgs<ExtArgs>
            result: $Utils.Optional<LiabilityCountAggregateOutputType> | number
          }
        }
      }
      GoalsAndWishes: {
        payload: Prisma.$GoalsAndWishesPayload<ExtArgs>
        fields: Prisma.GoalsAndWishesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalsAndWishesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalsAndWishesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>
          }
          findFirst: {
            args: Prisma.GoalsAndWishesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalsAndWishesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>
          }
          findMany: {
            args: Prisma.GoalsAndWishesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>[]
          }
          create: {
            args: Prisma.GoalsAndWishesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>
          }
          createMany: {
            args: Prisma.GoalsAndWishesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalsAndWishesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>[]
          }
          delete: {
            args: Prisma.GoalsAndWishesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>
          }
          update: {
            args: Prisma.GoalsAndWishesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>
          }
          deleteMany: {
            args: Prisma.GoalsAndWishesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalsAndWishesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoalsAndWishesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>[]
          }
          upsert: {
            args: Prisma.GoalsAndWishesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalsAndWishesPayload>
          }
          aggregate: {
            args: Prisma.GoalsAndWishesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoalsAndWishes>
          }
          groupBy: {
            args: Prisma.GoalsAndWishesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalsAndWishesGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalsAndWishesCountArgs<ExtArgs>
            result: $Utils.Optional<GoalsAndWishesCountAggregateOutputType> | number
          }
        }
      }
      RiskAppetite: {
        payload: Prisma.$RiskAppetitePayload<ExtArgs>
        fields: Prisma.RiskAppetiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskAppetiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskAppetiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>
          }
          findFirst: {
            args: Prisma.RiskAppetiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskAppetiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>
          }
          findMany: {
            args: Prisma.RiskAppetiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>[]
          }
          create: {
            args: Prisma.RiskAppetiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>
          }
          createMany: {
            args: Prisma.RiskAppetiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskAppetiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>[]
          }
          delete: {
            args: Prisma.RiskAppetiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>
          }
          update: {
            args: Prisma.RiskAppetiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>
          }
          deleteMany: {
            args: Prisma.RiskAppetiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskAppetiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskAppetiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>[]
          }
          upsert: {
            args: Prisma.RiskAppetiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAppetitePayload>
          }
          aggregate: {
            args: Prisma.RiskAppetiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskAppetite>
          }
          groupBy: {
            args: Prisma.RiskAppetiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskAppetiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskAppetiteCountArgs<ExtArgs>
            result: $Utils.Optional<RiskAppetiteCountAggregateOutputType> | number
          }
        }
      }
      Consent: {
        payload: Prisma.$ConsentPayload<ExtArgs>
        fields: Prisma.ConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          findFirst: {
            args: Prisma.ConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          findMany: {
            args: Prisma.ConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>[]
          }
          create: {
            args: Prisma.ConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          createMany: {
            args: Prisma.ConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>[]
          }
          delete: {
            args: Prisma.ConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          update: {
            args: Prisma.ConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          deleteMany: {
            args: Prisma.ConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>[]
          }
          upsert: {
            args: Prisma.ConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          aggregate: {
            args: Prisma.ConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsent>
          }
          groupBy: {
            args: Prisma.ConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsentCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Form: {
        payload: Prisma.$FormPayload<ExtArgs>
        fields: Prisma.FormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findFirst: {
            args: Prisma.FormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findMany: {
            args: Prisma.FormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          create: {
            args: Prisma.FormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          createMany: {
            args: Prisma.FormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          delete: {
            args: Prisma.FormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          update: {
            args: Prisma.FormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          deleteMany: {
            args: Prisma.FormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          upsert: {
            args: Prisma.FormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          aggregate: {
            args: Prisma.FormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForm>
          }
          groupBy: {
            args: Prisma.FormGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormCountArgs<ExtArgs>
            result: $Utils.Optional<FormCountAggregateOutputType> | number
          }
        }
      }
      CustomForm: {
        payload: Prisma.$CustomFormPayload<ExtArgs>
        fields: Prisma.CustomFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>
          }
          findFirst: {
            args: Prisma.CustomFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>
          }
          findMany: {
            args: Prisma.CustomFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>[]
          }
          create: {
            args: Prisma.CustomFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>
          }
          createMany: {
            args: Prisma.CustomFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>[]
          }
          delete: {
            args: Prisma.CustomFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>
          }
          update: {
            args: Prisma.CustomFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>
          }
          deleteMany: {
            args: Prisma.CustomFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>[]
          }
          upsert: {
            args: Prisma.CustomFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFormPayload>
          }
          aggregate: {
            args: Prisma.CustomFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomForm>
          }
          groupBy: {
            args: Prisma.CustomFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomFormCountArgs<ExtArgs>
            result: $Utils.Optional<CustomFormCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    child?: ChildOmit
    applicant?: ApplicantOmit
    immobillionApplicantDetails?: ImmobillionApplicantDetailsOmit
    immobillionForm?: ImmobillionFormOmit
    analysisForm?: AnalysisFormOmit
    personalDetails?: PersonalDetailsOmit
    employmentDetails?: EmploymentDetailsOmit
    incomeDetails?: IncomeDetailsOmit
    expensesDetails?: ExpensesDetailsOmit
    asset?: AssetOmit
    liability?: LiabilityOmit
    goalsAndWishes?: GoalsAndWishesOmit
    riskAppetite?: RiskAppetiteOmit
    consent?: ConsentOmit
    document?: DocumentOmit
    form?: FormOmit
    customForm?: CustomFormOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    analysisForms: number
    immobillionForms: number
    clientsAsCoach: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisForms?: boolean | UserCountOutputTypeCountAnalysisFormsArgs
    immobillionForms?: boolean | UserCountOutputTypeCountImmobillionFormsArgs
    clientsAsCoach?: boolean | UserCountOutputTypeCountClientsAsCoachArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalysisFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisFormWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImmobillionFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmobillionFormWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientsAsCoachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalDetailsWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ImmobillionFormCountOutputType
   */

  export type ImmobillionFormCountOutputType = {
    applicants: number
  }

  export type ImmobillionFormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicants?: boolean | ImmobillionFormCountOutputTypeCountApplicantsArgs
  }

  // Custom InputTypes
  /**
   * ImmobillionFormCountOutputType without action
   */
  export type ImmobillionFormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionFormCountOutputType
     */
    select?: ImmobillionFormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImmobillionFormCountOutputType without action
   */
  export type ImmobillionFormCountOutputTypeCountApplicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantWhereInput
  }


  /**
   * Count Type AnalysisFormCountOutputType
   */

  export type AnalysisFormCountOutputType = {
    children: number
    applicants: number
  }

  export type AnalysisFormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | AnalysisFormCountOutputTypeCountChildrenArgs
    applicants?: boolean | AnalysisFormCountOutputTypeCountApplicantsArgs
  }

  // Custom InputTypes
  /**
   * AnalysisFormCountOutputType without action
   */
  export type AnalysisFormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisFormCountOutputType
     */
    select?: AnalysisFormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnalysisFormCountOutputType without action
   */
  export type AnalysisFormCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
  }

  /**
   * AnalysisFormCountOutputType without action
   */
  export type AnalysisFormCountOutputTypeCountApplicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantWhereInput
  }


  /**
   * Count Type PersonalDetailsCountOutputType
   */

  export type PersonalDetailsCountOutputType = {
    employmentDetails: number
    incomeDetails: number
    expensesDetails: number
    assets: number
    liabilities: number
    consents: number
    documents: number
    forms: number
    customForms: number
  }

  export type PersonalDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employmentDetails?: boolean | PersonalDetailsCountOutputTypeCountEmploymentDetailsArgs
    incomeDetails?: boolean | PersonalDetailsCountOutputTypeCountIncomeDetailsArgs
    expensesDetails?: boolean | PersonalDetailsCountOutputTypeCountExpensesDetailsArgs
    assets?: boolean | PersonalDetailsCountOutputTypeCountAssetsArgs
    liabilities?: boolean | PersonalDetailsCountOutputTypeCountLiabilitiesArgs
    consents?: boolean | PersonalDetailsCountOutputTypeCountConsentsArgs
    documents?: boolean | PersonalDetailsCountOutputTypeCountDocumentsArgs
    forms?: boolean | PersonalDetailsCountOutputTypeCountFormsArgs
    customForms?: boolean | PersonalDetailsCountOutputTypeCountCustomFormsArgs
  }

  // Custom InputTypes
  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetailsCountOutputType
     */
    select?: PersonalDetailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountEmploymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentDetailsWhereInput
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountIncomeDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeDetailsWhereInput
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountExpensesDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpensesDetailsWhereInput
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountLiabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiabilityWhereInput
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentWhereInput
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
  }

  /**
   * PersonalDetailsCountOutputType without action
   */
  export type PersonalDetailsCountOutputTypeCountCustomFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFormWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    displayName: string | null
    emailVerified: boolean | null
    profileImage: string | null
    phoneNumber: string | null
    firebaseUid: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roleId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    displayName: string | null
    emailVerified: boolean | null
    profileImage: string | null
    phoneNumber: string | null
    firebaseUid: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roleId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    displayName: number
    emailVerified: number
    profileImage: number
    phoneNumber: number
    firebaseUid: number
    createdAt: number
    updatedAt: number
    roleId: number
    resetToken: number
    resetTokenExpiry: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    displayName?: true
    emailVerified?: true
    profileImage?: true
    phoneNumber?: true
    firebaseUid?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    resetToken?: true
    resetTokenExpiry?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    displayName?: true
    emailVerified?: true
    profileImage?: true
    phoneNumber?: true
    firebaseUid?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    resetToken?: true
    resetTokenExpiry?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    displayName?: true
    emailVerified?: true
    profileImage?: true
    phoneNumber?: true
    firebaseUid?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    resetToken?: true
    resetTokenExpiry?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    displayName: string | null
    emailVerified: boolean
    profileImage: string | null
    phoneNumber: string | null
    firebaseUid: string | null
    createdAt: Date
    updatedAt: Date
    roleId: string
    resetToken: string | null
    resetTokenExpiry: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    displayName?: boolean
    emailVerified?: boolean
    profileImage?: boolean
    phoneNumber?: boolean
    firebaseUid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    analysisForms?: boolean | User$analysisFormsArgs<ExtArgs>
    immobillionForms?: boolean | User$immobillionFormsArgs<ExtArgs>
    personalDetails?: boolean | User$personalDetailsArgs<ExtArgs>
    clientsAsCoach?: boolean | User$clientsAsCoachArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    displayName?: boolean
    emailVerified?: boolean
    profileImage?: boolean
    phoneNumber?: boolean
    firebaseUid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    displayName?: boolean
    emailVerified?: boolean
    profileImage?: boolean
    phoneNumber?: boolean
    firebaseUid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    displayName?: boolean
    emailVerified?: boolean
    profileImage?: boolean
    phoneNumber?: boolean
    firebaseUid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "displayName" | "emailVerified" | "profileImage" | "phoneNumber" | "firebaseUid" | "createdAt" | "updatedAt" | "roleId" | "resetToken" | "resetTokenExpiry", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    analysisForms?: boolean | User$analysisFormsArgs<ExtArgs>
    immobillionForms?: boolean | User$immobillionFormsArgs<ExtArgs>
    personalDetails?: boolean | User$personalDetailsArgs<ExtArgs>
    clientsAsCoach?: boolean | User$clientsAsCoachArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      analysisForms: Prisma.$AnalysisFormPayload<ExtArgs>[]
      immobillionForms: Prisma.$ImmobillionFormPayload<ExtArgs>[]
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs> | null
      clientsAsCoach: Prisma.$PersonalDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      displayName: string | null
      emailVerified: boolean
      profileImage: string | null
      phoneNumber: string | null
      firebaseUid: string | null
      createdAt: Date
      updatedAt: Date
      roleId: string
      resetToken: string | null
      resetTokenExpiry: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    analysisForms<T extends User$analysisFormsArgs<ExtArgs> = {}>(args?: Subset<T, User$analysisFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    immobillionForms<T extends User$immobillionFormsArgs<ExtArgs> = {}>(args?: Subset<T, User$immobillionFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personalDetails<T extends User$personalDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$personalDetailsArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientsAsCoach<T extends User$clientsAsCoachArgs<ExtArgs> = {}>(args?: Subset<T, User$clientsAsCoachArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly firebaseUid: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.analysisForms
   */
  export type User$analysisFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    where?: AnalysisFormWhereInput
    orderBy?: AnalysisFormOrderByWithRelationInput | AnalysisFormOrderByWithRelationInput[]
    cursor?: AnalysisFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysisFormScalarFieldEnum | AnalysisFormScalarFieldEnum[]
  }

  /**
   * User.immobillionForms
   */
  export type User$immobillionFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    where?: ImmobillionFormWhereInput
    orderBy?: ImmobillionFormOrderByWithRelationInput | ImmobillionFormOrderByWithRelationInput[]
    cursor?: ImmobillionFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImmobillionFormScalarFieldEnum | ImmobillionFormScalarFieldEnum[]
  }

  /**
   * User.personalDetails
   */
  export type User$personalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    where?: PersonalDetailsWhereInput
  }

  /**
   * User.clientsAsCoach
   */
  export type User$clientsAsCoachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    where?: PersonalDetailsWhereInput
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    cursor?: PersonalDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalDetailsScalarFieldEnum | PersonalDetailsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    permissions: string[]
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      permissions: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'String[]'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Child
   */

  export type AggregateChild = {
    _count: ChildCountAggregateOutputType | null
    _min: ChildMinAggregateOutputType | null
    _max: ChildMaxAggregateOutputType | null
  }

  export type ChildMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    birthPlace: string | null
    nationality: string | null
    createdAt: Date | null
    updatedAt: Date | null
    analysisFormId: string | null
  }

  export type ChildMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    birthPlace: string | null
    nationality: string | null
    createdAt: Date | null
    updatedAt: Date | null
    analysisFormId: string | null
  }

  export type ChildCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    birthDate: number
    birthPlace: number
    nationality: number
    createdAt: number
    updatedAt: number
    analysisFormId: number
    _all: number
  }


  export type ChildMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    birthPlace?: true
    nationality?: true
    createdAt?: true
    updatedAt?: true
    analysisFormId?: true
  }

  export type ChildMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    birthPlace?: true
    nationality?: true
    createdAt?: true
    updatedAt?: true
    analysisFormId?: true
  }

  export type ChildCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    birthPlace?: true
    nationality?: true
    createdAt?: true
    updatedAt?: true
    analysisFormId?: true
    _all?: true
  }

  export type ChildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Child to aggregate.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Children
    **/
    _count?: true | ChildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChildMaxAggregateInputType
  }

  export type GetChildAggregateType<T extends ChildAggregateArgs> = {
        [P in keyof T & keyof AggregateChild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChild[P]>
      : GetScalarType<T[P], AggregateChild[P]>
  }




  export type ChildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithAggregationInput | ChildOrderByWithAggregationInput[]
    by: ChildScalarFieldEnum[] | ChildScalarFieldEnum
    having?: ChildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChildCountAggregateInputType | true
    _min?: ChildMinAggregateInputType
    _max?: ChildMaxAggregateInputType
  }

  export type ChildGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    birthDate: Date
    birthPlace: string
    nationality: string
    createdAt: Date
    updatedAt: Date
    analysisFormId: string
    _count: ChildCountAggregateOutputType | null
    _min: ChildMinAggregateOutputType | null
    _max: ChildMaxAggregateOutputType | null
  }

  type GetChildGroupByPayload<T extends ChildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChildGroupByOutputType[P]>
            : GetScalarType<T[P], ChildGroupByOutputType[P]>
        }
      >
    >


  export type ChildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    nationality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analysisFormId?: boolean
    analysisForm?: boolean | AnalysisFormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    nationality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analysisFormId?: boolean
    analysisForm?: boolean | AnalysisFormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    nationality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analysisFormId?: boolean
    analysisForm?: boolean | AnalysisFormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    nationality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    analysisFormId?: boolean
  }

  export type ChildOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "birthDate" | "birthPlace" | "nationality" | "createdAt" | "updatedAt" | "analysisFormId", ExtArgs["result"]["child"]>
  export type ChildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisForm?: boolean | AnalysisFormDefaultArgs<ExtArgs>
  }
  export type ChildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisForm?: boolean | AnalysisFormDefaultArgs<ExtArgs>
  }
  export type ChildIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisForm?: boolean | AnalysisFormDefaultArgs<ExtArgs>
  }

  export type $ChildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Child"
    objects: {
      analysisForm: Prisma.$AnalysisFormPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      birthDate: Date
      birthPlace: string
      nationality: string
      createdAt: Date
      updatedAt: Date
      analysisFormId: string
    }, ExtArgs["result"]["child"]>
    composites: {}
  }

  type ChildGetPayload<S extends boolean | null | undefined | ChildDefaultArgs> = $Result.GetResult<Prisma.$ChildPayload, S>

  type ChildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChildFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChildCountAggregateInputType | true
    }

  export interface ChildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Child'], meta: { name: 'Child' } }
    /**
     * Find zero or one Child that matches the filter.
     * @param {ChildFindUniqueArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChildFindUniqueArgs>(args: SelectSubset<T, ChildFindUniqueArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Child that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChildFindUniqueOrThrowArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChildFindUniqueOrThrowArgs>(args: SelectSubset<T, ChildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Child that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindFirstArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChildFindFirstArgs>(args?: SelectSubset<T, ChildFindFirstArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Child that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindFirstOrThrowArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChildFindFirstOrThrowArgs>(args?: SelectSubset<T, ChildFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Children that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Children
     * const children = await prisma.child.findMany()
     * 
     * // Get first 10 Children
     * const children = await prisma.child.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const childWithIdOnly = await prisma.child.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChildFindManyArgs>(args?: SelectSubset<T, ChildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Child.
     * @param {ChildCreateArgs} args - Arguments to create a Child.
     * @example
     * // Create one Child
     * const Child = await prisma.child.create({
     *   data: {
     *     // ... data to create a Child
     *   }
     * })
     * 
     */
    create<T extends ChildCreateArgs>(args: SelectSubset<T, ChildCreateArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Children.
     * @param {ChildCreateManyArgs} args - Arguments to create many Children.
     * @example
     * // Create many Children
     * const child = await prisma.child.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChildCreateManyArgs>(args?: SelectSubset<T, ChildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Children and returns the data saved in the database.
     * @param {ChildCreateManyAndReturnArgs} args - Arguments to create many Children.
     * @example
     * // Create many Children
     * const child = await prisma.child.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Children and only return the `id`
     * const childWithIdOnly = await prisma.child.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChildCreateManyAndReturnArgs>(args?: SelectSubset<T, ChildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Child.
     * @param {ChildDeleteArgs} args - Arguments to delete one Child.
     * @example
     * // Delete one Child
     * const Child = await prisma.child.delete({
     *   where: {
     *     // ... filter to delete one Child
     *   }
     * })
     * 
     */
    delete<T extends ChildDeleteArgs>(args: SelectSubset<T, ChildDeleteArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Child.
     * @param {ChildUpdateArgs} args - Arguments to update one Child.
     * @example
     * // Update one Child
     * const child = await prisma.child.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChildUpdateArgs>(args: SelectSubset<T, ChildUpdateArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Children.
     * @param {ChildDeleteManyArgs} args - Arguments to filter Children to delete.
     * @example
     * // Delete a few Children
     * const { count } = await prisma.child.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChildDeleteManyArgs>(args?: SelectSubset<T, ChildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Children
     * const child = await prisma.child.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChildUpdateManyArgs>(args: SelectSubset<T, ChildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Children and returns the data updated in the database.
     * @param {ChildUpdateManyAndReturnArgs} args - Arguments to update many Children.
     * @example
     * // Update many Children
     * const child = await prisma.child.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Children and only return the `id`
     * const childWithIdOnly = await prisma.child.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChildUpdateManyAndReturnArgs>(args: SelectSubset<T, ChildUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Child.
     * @param {ChildUpsertArgs} args - Arguments to update or create a Child.
     * @example
     * // Update or create a Child
     * const child = await prisma.child.upsert({
     *   create: {
     *     // ... data to create a Child
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Child we want to update
     *   }
     * })
     */
    upsert<T extends ChildUpsertArgs>(args: SelectSubset<T, ChildUpsertArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildCountArgs} args - Arguments to filter Children to count.
     * @example
     * // Count the number of Children
     * const count = await prisma.child.count({
     *   where: {
     *     // ... the filter for the Children we want to count
     *   }
     * })
    **/
    count<T extends ChildCountArgs>(
      args?: Subset<T, ChildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Child.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChildAggregateArgs>(args: Subset<T, ChildAggregateArgs>): Prisma.PrismaPromise<GetChildAggregateType<T>>

    /**
     * Group by Child.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChildGroupByArgs['orderBy'] }
        : { orderBy?: ChildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Child model
   */
  readonly fields: ChildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Child.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analysisForm<T extends AnalysisFormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnalysisFormDefaultArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Child model
   */
  interface ChildFieldRefs {
    readonly id: FieldRef<"Child", 'String'>
    readonly firstName: FieldRef<"Child", 'String'>
    readonly lastName: FieldRef<"Child", 'String'>
    readonly birthDate: FieldRef<"Child", 'DateTime'>
    readonly birthPlace: FieldRef<"Child", 'String'>
    readonly nationality: FieldRef<"Child", 'String'>
    readonly createdAt: FieldRef<"Child", 'DateTime'>
    readonly updatedAt: FieldRef<"Child", 'DateTime'>
    readonly analysisFormId: FieldRef<"Child", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Child findUnique
   */
  export type ChildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child findUniqueOrThrow
   */
  export type ChildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child findFirst
   */
  export type ChildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Children.
     */
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child findFirstOrThrow
   */
  export type ChildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Children.
     */
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child findMany
   */
  export type ChildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Children to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child create
   */
  export type ChildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The data needed to create a Child.
     */
    data: XOR<ChildCreateInput, ChildUncheckedCreateInput>
  }

  /**
   * Child createMany
   */
  export type ChildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Children.
     */
    data: ChildCreateManyInput | ChildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Child createManyAndReturn
   */
  export type ChildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * The data used to create many Children.
     */
    data: ChildCreateManyInput | ChildCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Child update
   */
  export type ChildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The data needed to update a Child.
     */
    data: XOR<ChildUpdateInput, ChildUncheckedUpdateInput>
    /**
     * Choose, which Child to update.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child updateMany
   */
  export type ChildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Children.
     */
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyInput>
    /**
     * Filter which Children to update
     */
    where?: ChildWhereInput
    /**
     * Limit how many Children to update.
     */
    limit?: number
  }

  /**
   * Child updateManyAndReturn
   */
  export type ChildUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * The data used to update Children.
     */
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyInput>
    /**
     * Filter which Children to update
     */
    where?: ChildWhereInput
    /**
     * Limit how many Children to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Child upsert
   */
  export type ChildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The filter to search for the Child to update in case it exists.
     */
    where: ChildWhereUniqueInput
    /**
     * In case the Child found by the `where` argument doesn't exist, create a new Child with this data.
     */
    create: XOR<ChildCreateInput, ChildUncheckedCreateInput>
    /**
     * In case the Child was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChildUpdateInput, ChildUncheckedUpdateInput>
  }

  /**
   * Child delete
   */
  export type ChildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter which Child to delete.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child deleteMany
   */
  export type ChildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Children to delete
     */
    where?: ChildWhereInput
    /**
     * Limit how many Children to delete.
     */
    limit?: number
  }

  /**
   * Child without action
   */
  export type ChildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
  }


  /**
   * Model Applicant
   */

  export type AggregateApplicant = {
    _count: ApplicantCountAggregateOutputType | null
    _avg: ApplicantAvgAggregateOutputType | null
    _sum: ApplicantSumAggregateOutputType | null
    _min: ApplicantMinAggregateOutputType | null
    _max: ApplicantMaxAggregateOutputType | null
  }

  export type ApplicantAvgAggregateOutputType = {
    numberOfChildren: number | null
    netIncome: Decimal | null
    grossIncome: Decimal | null
    numberOfSalaries: number | null
    childBenefit: Decimal | null
    otherIncome: Decimal | null
  }

  export type ApplicantSumAggregateOutputType = {
    numberOfChildren: number | null
    netIncome: Decimal | null
    grossIncome: Decimal | null
    numberOfSalaries: number | null
    childBenefit: Decimal | null
    otherIncome: Decimal | null
  }

  export type ApplicantMinAggregateOutputType = {
    id: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    salutation: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    maidenName: string | null
    birthDate: Date | null
    birthPlace: string | null
    birthCountry: string | null
    nationality: string | null
    isEUCitizen: boolean | null
    residencePermit: string | null
    inGermanySince: Date | null
    street: string | null
    houseNumber: string | null
    postalCode: string | null
    city: string | null
    residentSince: Date | null
    phoneLandline: string | null
    phoneMobile: string | null
    email: string | null
    taxId: string | null
    maritalStatus: string | null
    separationOfGoods: boolean | null
    numberOfChildren: number | null
    profession: string | null
    employmentType: string | null
    employedSince: Date | null
    contractType: string | null
    contractUntil: Date | null
    employerName: string | null
    employerInGermany: boolean | null
    netIncome: Decimal | null
    grossIncome: Decimal | null
    numberOfSalaries: number | null
    childBenefit: Decimal | null
    otherIncome: Decimal | null
    iban: string | null
    bic: string | null
    analysisFormId: string | null
    immobillionFormId: string | null
  }

  export type ApplicantMaxAggregateOutputType = {
    id: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    salutation: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    maidenName: string | null
    birthDate: Date | null
    birthPlace: string | null
    birthCountry: string | null
    nationality: string | null
    isEUCitizen: boolean | null
    residencePermit: string | null
    inGermanySince: Date | null
    street: string | null
    houseNumber: string | null
    postalCode: string | null
    city: string | null
    residentSince: Date | null
    phoneLandline: string | null
    phoneMobile: string | null
    email: string | null
    taxId: string | null
    maritalStatus: string | null
    separationOfGoods: boolean | null
    numberOfChildren: number | null
    profession: string | null
    employmentType: string | null
    employedSince: Date | null
    contractType: string | null
    contractUntil: Date | null
    employerName: string | null
    employerInGermany: boolean | null
    netIncome: Decimal | null
    grossIncome: Decimal | null
    numberOfSalaries: number | null
    childBenefit: Decimal | null
    otherIncome: Decimal | null
    iban: string | null
    bic: string | null
    analysisFormId: string | null
    immobillionFormId: string | null
  }

  export type ApplicantCountAggregateOutputType = {
    id: number
    type: number
    createdAt: number
    updatedAt: number
    salutation: number
    title: number
    firstName: number
    lastName: number
    maidenName: number
    birthDate: number
    birthPlace: number
    birthCountry: number
    nationality: number
    isEUCitizen: number
    residencePermit: number
    inGermanySince: number
    street: number
    houseNumber: number
    postalCode: number
    city: number
    residentSince: number
    previousAddress: number
    phoneLandline: number
    phoneMobile: number
    email: number
    taxId: number
    maritalStatus: number
    separationOfGoods: number
    numberOfChildren: number
    childrenBirthDates: number
    profession: number
    employmentType: number
    employedSince: number
    contractType: number
    contractUntil: number
    employerName: number
    employerInGermany: number
    netIncome: number
    grossIncome: number
    numberOfSalaries: number
    childBenefit: number
    otherIncome: number
    iban: number
    bic: number
    analysisFormId: number
    immobillionFormId: number
    _all: number
  }


  export type ApplicantAvgAggregateInputType = {
    numberOfChildren?: true
    netIncome?: true
    grossIncome?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
  }

  export type ApplicantSumAggregateInputType = {
    numberOfChildren?: true
    netIncome?: true
    grossIncome?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
  }

  export type ApplicantMinAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    salutation?: true
    title?: true
    firstName?: true
    lastName?: true
    maidenName?: true
    birthDate?: true
    birthPlace?: true
    birthCountry?: true
    nationality?: true
    isEUCitizen?: true
    residencePermit?: true
    inGermanySince?: true
    street?: true
    houseNumber?: true
    postalCode?: true
    city?: true
    residentSince?: true
    phoneLandline?: true
    phoneMobile?: true
    email?: true
    taxId?: true
    maritalStatus?: true
    separationOfGoods?: true
    numberOfChildren?: true
    profession?: true
    employmentType?: true
    employedSince?: true
    contractType?: true
    contractUntil?: true
    employerName?: true
    employerInGermany?: true
    netIncome?: true
    grossIncome?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
    iban?: true
    bic?: true
    analysisFormId?: true
    immobillionFormId?: true
  }

  export type ApplicantMaxAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    salutation?: true
    title?: true
    firstName?: true
    lastName?: true
    maidenName?: true
    birthDate?: true
    birthPlace?: true
    birthCountry?: true
    nationality?: true
    isEUCitizen?: true
    residencePermit?: true
    inGermanySince?: true
    street?: true
    houseNumber?: true
    postalCode?: true
    city?: true
    residentSince?: true
    phoneLandline?: true
    phoneMobile?: true
    email?: true
    taxId?: true
    maritalStatus?: true
    separationOfGoods?: true
    numberOfChildren?: true
    profession?: true
    employmentType?: true
    employedSince?: true
    contractType?: true
    contractUntil?: true
    employerName?: true
    employerInGermany?: true
    netIncome?: true
    grossIncome?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
    iban?: true
    bic?: true
    analysisFormId?: true
    immobillionFormId?: true
  }

  export type ApplicantCountAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    salutation?: true
    title?: true
    firstName?: true
    lastName?: true
    maidenName?: true
    birthDate?: true
    birthPlace?: true
    birthCountry?: true
    nationality?: true
    isEUCitizen?: true
    residencePermit?: true
    inGermanySince?: true
    street?: true
    houseNumber?: true
    postalCode?: true
    city?: true
    residentSince?: true
    previousAddress?: true
    phoneLandline?: true
    phoneMobile?: true
    email?: true
    taxId?: true
    maritalStatus?: true
    separationOfGoods?: true
    numberOfChildren?: true
    childrenBirthDates?: true
    profession?: true
    employmentType?: true
    employedSince?: true
    contractType?: true
    contractUntil?: true
    employerName?: true
    employerInGermany?: true
    netIncome?: true
    grossIncome?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
    iban?: true
    bic?: true
    analysisFormId?: true
    immobillionFormId?: true
    _all?: true
  }

  export type ApplicantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applicant to aggregate.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applicants
    **/
    _count?: true | ApplicantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicantMaxAggregateInputType
  }

  export type GetApplicantAggregateType<T extends ApplicantAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicant[P]>
      : GetScalarType<T[P], AggregateApplicant[P]>
  }




  export type ApplicantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantWhereInput
    orderBy?: ApplicantOrderByWithAggregationInput | ApplicantOrderByWithAggregationInput[]
    by: ApplicantScalarFieldEnum[] | ApplicantScalarFieldEnum
    having?: ApplicantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicantCountAggregateInputType | true
    _avg?: ApplicantAvgAggregateInputType
    _sum?: ApplicantSumAggregateInputType
    _min?: ApplicantMinAggregateInputType
    _max?: ApplicantMaxAggregateInputType
  }

  export type ApplicantGroupByOutputType = {
    id: string
    type: string
    createdAt: Date
    updatedAt: Date
    salutation: string | null
    title: string | null
    firstName: string
    lastName: string
    maidenName: string | null
    birthDate: Date
    birthPlace: string
    birthCountry: string | null
    nationality: string
    isEUCitizen: boolean | null
    residencePermit: string | null
    inGermanySince: Date | null
    street: string
    houseNumber: string | null
    postalCode: string
    city: string
    residentSince: Date | null
    previousAddress: JsonValue | null
    phoneLandline: string | null
    phoneMobile: string
    email: string
    taxId: string | null
    maritalStatus: string
    separationOfGoods: boolean | null
    numberOfChildren: number
    childrenBirthDates: Date[]
    profession: string
    employmentType: string | null
    employedSince: Date | null
    contractType: string
    contractUntil: Date | null
    employerName: string | null
    employerInGermany: boolean | null
    netIncome: Decimal
    grossIncome: Decimal
    numberOfSalaries: number
    childBenefit: Decimal
    otherIncome: Decimal
    iban: string | null
    bic: string | null
    analysisFormId: string | null
    immobillionFormId: string | null
    _count: ApplicantCountAggregateOutputType | null
    _avg: ApplicantAvgAggregateOutputType | null
    _sum: ApplicantSumAggregateOutputType | null
    _min: ApplicantMinAggregateOutputType | null
    _max: ApplicantMaxAggregateOutputType | null
  }

  type GetApplicantGroupByPayload<T extends ApplicantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicantGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicantGroupByOutputType[P]>
        }
      >
    >


  export type ApplicantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salutation?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    maidenName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    birthCountry?: boolean
    nationality?: boolean
    isEUCitizen?: boolean
    residencePermit?: boolean
    inGermanySince?: boolean
    street?: boolean
    houseNumber?: boolean
    postalCode?: boolean
    city?: boolean
    residentSince?: boolean
    previousAddress?: boolean
    phoneLandline?: boolean
    phoneMobile?: boolean
    email?: boolean
    taxId?: boolean
    maritalStatus?: boolean
    separationOfGoods?: boolean
    numberOfChildren?: boolean
    childrenBirthDates?: boolean
    profession?: boolean
    employmentType?: boolean
    employedSince?: boolean
    contractType?: boolean
    contractUntil?: boolean
    employerName?: boolean
    employerInGermany?: boolean
    netIncome?: boolean
    grossIncome?: boolean
    numberOfSalaries?: boolean
    childBenefit?: boolean
    otherIncome?: boolean
    iban?: boolean
    bic?: boolean
    analysisFormId?: boolean
    immobillionFormId?: boolean
    analysisForm?: boolean | Applicant$analysisFormArgs<ExtArgs>
    immobillionForm?: boolean | Applicant$immobillionFormArgs<ExtArgs>
    immobillionDetails?: boolean | Applicant$immobillionDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["applicant"]>

  export type ApplicantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salutation?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    maidenName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    birthCountry?: boolean
    nationality?: boolean
    isEUCitizen?: boolean
    residencePermit?: boolean
    inGermanySince?: boolean
    street?: boolean
    houseNumber?: boolean
    postalCode?: boolean
    city?: boolean
    residentSince?: boolean
    previousAddress?: boolean
    phoneLandline?: boolean
    phoneMobile?: boolean
    email?: boolean
    taxId?: boolean
    maritalStatus?: boolean
    separationOfGoods?: boolean
    numberOfChildren?: boolean
    childrenBirthDates?: boolean
    profession?: boolean
    employmentType?: boolean
    employedSince?: boolean
    contractType?: boolean
    contractUntil?: boolean
    employerName?: boolean
    employerInGermany?: boolean
    netIncome?: boolean
    grossIncome?: boolean
    numberOfSalaries?: boolean
    childBenefit?: boolean
    otherIncome?: boolean
    iban?: boolean
    bic?: boolean
    analysisFormId?: boolean
    immobillionFormId?: boolean
    analysisForm?: boolean | Applicant$analysisFormArgs<ExtArgs>
    immobillionForm?: boolean | Applicant$immobillionFormArgs<ExtArgs>
  }, ExtArgs["result"]["applicant"]>

  export type ApplicantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salutation?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    maidenName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    birthCountry?: boolean
    nationality?: boolean
    isEUCitizen?: boolean
    residencePermit?: boolean
    inGermanySince?: boolean
    street?: boolean
    houseNumber?: boolean
    postalCode?: boolean
    city?: boolean
    residentSince?: boolean
    previousAddress?: boolean
    phoneLandline?: boolean
    phoneMobile?: boolean
    email?: boolean
    taxId?: boolean
    maritalStatus?: boolean
    separationOfGoods?: boolean
    numberOfChildren?: boolean
    childrenBirthDates?: boolean
    profession?: boolean
    employmentType?: boolean
    employedSince?: boolean
    contractType?: boolean
    contractUntil?: boolean
    employerName?: boolean
    employerInGermany?: boolean
    netIncome?: boolean
    grossIncome?: boolean
    numberOfSalaries?: boolean
    childBenefit?: boolean
    otherIncome?: boolean
    iban?: boolean
    bic?: boolean
    analysisFormId?: boolean
    immobillionFormId?: boolean
    analysisForm?: boolean | Applicant$analysisFormArgs<ExtArgs>
    immobillionForm?: boolean | Applicant$immobillionFormArgs<ExtArgs>
  }, ExtArgs["result"]["applicant"]>

  export type ApplicantSelectScalar = {
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salutation?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    maidenName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    birthCountry?: boolean
    nationality?: boolean
    isEUCitizen?: boolean
    residencePermit?: boolean
    inGermanySince?: boolean
    street?: boolean
    houseNumber?: boolean
    postalCode?: boolean
    city?: boolean
    residentSince?: boolean
    previousAddress?: boolean
    phoneLandline?: boolean
    phoneMobile?: boolean
    email?: boolean
    taxId?: boolean
    maritalStatus?: boolean
    separationOfGoods?: boolean
    numberOfChildren?: boolean
    childrenBirthDates?: boolean
    profession?: boolean
    employmentType?: boolean
    employedSince?: boolean
    contractType?: boolean
    contractUntil?: boolean
    employerName?: boolean
    employerInGermany?: boolean
    netIncome?: boolean
    grossIncome?: boolean
    numberOfSalaries?: boolean
    childBenefit?: boolean
    otherIncome?: boolean
    iban?: boolean
    bic?: boolean
    analysisFormId?: boolean
    immobillionFormId?: boolean
  }

  export type ApplicantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "createdAt" | "updatedAt" | "salutation" | "title" | "firstName" | "lastName" | "maidenName" | "birthDate" | "birthPlace" | "birthCountry" | "nationality" | "isEUCitizen" | "residencePermit" | "inGermanySince" | "street" | "houseNumber" | "postalCode" | "city" | "residentSince" | "previousAddress" | "phoneLandline" | "phoneMobile" | "email" | "taxId" | "maritalStatus" | "separationOfGoods" | "numberOfChildren" | "childrenBirthDates" | "profession" | "employmentType" | "employedSince" | "contractType" | "contractUntil" | "employerName" | "employerInGermany" | "netIncome" | "grossIncome" | "numberOfSalaries" | "childBenefit" | "otherIncome" | "iban" | "bic" | "analysisFormId" | "immobillionFormId", ExtArgs["result"]["applicant"]>
  export type ApplicantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisForm?: boolean | Applicant$analysisFormArgs<ExtArgs>
    immobillionForm?: boolean | Applicant$immobillionFormArgs<ExtArgs>
    immobillionDetails?: boolean | Applicant$immobillionDetailsArgs<ExtArgs>
  }
  export type ApplicantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisForm?: boolean | Applicant$analysisFormArgs<ExtArgs>
    immobillionForm?: boolean | Applicant$immobillionFormArgs<ExtArgs>
  }
  export type ApplicantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisForm?: boolean | Applicant$analysisFormArgs<ExtArgs>
    immobillionForm?: boolean | Applicant$immobillionFormArgs<ExtArgs>
  }

  export type $ApplicantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Applicant"
    objects: {
      analysisForm: Prisma.$AnalysisFormPayload<ExtArgs> | null
      immobillionForm: Prisma.$ImmobillionFormPayload<ExtArgs> | null
      immobillionDetails: Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      createdAt: Date
      updatedAt: Date
      salutation: string | null
      title: string | null
      firstName: string
      lastName: string
      maidenName: string | null
      birthDate: Date
      birthPlace: string
      birthCountry: string | null
      nationality: string
      isEUCitizen: boolean | null
      residencePermit: string | null
      inGermanySince: Date | null
      street: string
      houseNumber: string | null
      postalCode: string
      city: string
      residentSince: Date | null
      previousAddress: Prisma.JsonValue | null
      phoneLandline: string | null
      phoneMobile: string
      email: string
      taxId: string | null
      maritalStatus: string
      separationOfGoods: boolean | null
      numberOfChildren: number
      childrenBirthDates: Date[]
      profession: string
      employmentType: string | null
      employedSince: Date | null
      contractType: string
      contractUntil: Date | null
      employerName: string | null
      employerInGermany: boolean | null
      netIncome: Prisma.Decimal
      grossIncome: Prisma.Decimal
      numberOfSalaries: number
      childBenefit: Prisma.Decimal
      otherIncome: Prisma.Decimal
      iban: string | null
      bic: string | null
      analysisFormId: string | null
      immobillionFormId: string | null
    }, ExtArgs["result"]["applicant"]>
    composites: {}
  }

  type ApplicantGetPayload<S extends boolean | null | undefined | ApplicantDefaultArgs> = $Result.GetResult<Prisma.$ApplicantPayload, S>

  type ApplicantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicantCountAggregateInputType | true
    }

  export interface ApplicantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Applicant'], meta: { name: 'Applicant' } }
    /**
     * Find zero or one Applicant that matches the filter.
     * @param {ApplicantFindUniqueArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicantFindUniqueArgs>(args: SelectSubset<T, ApplicantFindUniqueArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applicant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicantFindUniqueOrThrowArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicantFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindFirstArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicantFindFirstArgs>(args?: SelectSubset<T, ApplicantFindFirstArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindFirstOrThrowArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicantFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicants
     * const applicants = await prisma.applicant.findMany()
     * 
     * // Get first 10 Applicants
     * const applicants = await prisma.applicant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicantWithIdOnly = await prisma.applicant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicantFindManyArgs>(args?: SelectSubset<T, ApplicantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applicant.
     * @param {ApplicantCreateArgs} args - Arguments to create a Applicant.
     * @example
     * // Create one Applicant
     * const Applicant = await prisma.applicant.create({
     *   data: {
     *     // ... data to create a Applicant
     *   }
     * })
     * 
     */
    create<T extends ApplicantCreateArgs>(args: SelectSubset<T, ApplicantCreateArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applicants.
     * @param {ApplicantCreateManyArgs} args - Arguments to create many Applicants.
     * @example
     * // Create many Applicants
     * const applicant = await prisma.applicant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicantCreateManyArgs>(args?: SelectSubset<T, ApplicantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applicants and returns the data saved in the database.
     * @param {ApplicantCreateManyAndReturnArgs} args - Arguments to create many Applicants.
     * @example
     * // Create many Applicants
     * const applicant = await prisma.applicant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applicants and only return the `id`
     * const applicantWithIdOnly = await prisma.applicant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicantCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Applicant.
     * @param {ApplicantDeleteArgs} args - Arguments to delete one Applicant.
     * @example
     * // Delete one Applicant
     * const Applicant = await prisma.applicant.delete({
     *   where: {
     *     // ... filter to delete one Applicant
     *   }
     * })
     * 
     */
    delete<T extends ApplicantDeleteArgs>(args: SelectSubset<T, ApplicantDeleteArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applicant.
     * @param {ApplicantUpdateArgs} args - Arguments to update one Applicant.
     * @example
     * // Update one Applicant
     * const applicant = await prisma.applicant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicantUpdateArgs>(args: SelectSubset<T, ApplicantUpdateArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applicants.
     * @param {ApplicantDeleteManyArgs} args - Arguments to filter Applicants to delete.
     * @example
     * // Delete a few Applicants
     * const { count } = await prisma.applicant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicantDeleteManyArgs>(args?: SelectSubset<T, ApplicantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicants
     * const applicant = await prisma.applicant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicantUpdateManyArgs>(args: SelectSubset<T, ApplicantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicants and returns the data updated in the database.
     * @param {ApplicantUpdateManyAndReturnArgs} args - Arguments to update many Applicants.
     * @example
     * // Update many Applicants
     * const applicant = await prisma.applicant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Applicants and only return the `id`
     * const applicantWithIdOnly = await prisma.applicant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicantUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Applicant.
     * @param {ApplicantUpsertArgs} args - Arguments to update or create a Applicant.
     * @example
     * // Update or create a Applicant
     * const applicant = await prisma.applicant.upsert({
     *   create: {
     *     // ... data to create a Applicant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicant we want to update
     *   }
     * })
     */
    upsert<T extends ApplicantUpsertArgs>(args: SelectSubset<T, ApplicantUpsertArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantCountArgs} args - Arguments to filter Applicants to count.
     * @example
     * // Count the number of Applicants
     * const count = await prisma.applicant.count({
     *   where: {
     *     // ... the filter for the Applicants we want to count
     *   }
     * })
    **/
    count<T extends ApplicantCountArgs>(
      args?: Subset<T, ApplicantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicantAggregateArgs>(args: Subset<T, ApplicantAggregateArgs>): Prisma.PrismaPromise<GetApplicantAggregateType<T>>

    /**
     * Group by Applicant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicantGroupByArgs['orderBy'] }
        : { orderBy?: ApplicantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Applicant model
   */
  readonly fields: ApplicantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Applicant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analysisForm<T extends Applicant$analysisFormArgs<ExtArgs> = {}>(args?: Subset<T, Applicant$analysisFormArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    immobillionForm<T extends Applicant$immobillionFormArgs<ExtArgs> = {}>(args?: Subset<T, Applicant$immobillionFormArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    immobillionDetails<T extends Applicant$immobillionDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Applicant$immobillionDetailsArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Applicant model
   */
  interface ApplicantFieldRefs {
    readonly id: FieldRef<"Applicant", 'String'>
    readonly type: FieldRef<"Applicant", 'String'>
    readonly createdAt: FieldRef<"Applicant", 'DateTime'>
    readonly updatedAt: FieldRef<"Applicant", 'DateTime'>
    readonly salutation: FieldRef<"Applicant", 'String'>
    readonly title: FieldRef<"Applicant", 'String'>
    readonly firstName: FieldRef<"Applicant", 'String'>
    readonly lastName: FieldRef<"Applicant", 'String'>
    readonly maidenName: FieldRef<"Applicant", 'String'>
    readonly birthDate: FieldRef<"Applicant", 'DateTime'>
    readonly birthPlace: FieldRef<"Applicant", 'String'>
    readonly birthCountry: FieldRef<"Applicant", 'String'>
    readonly nationality: FieldRef<"Applicant", 'String'>
    readonly isEUCitizen: FieldRef<"Applicant", 'Boolean'>
    readonly residencePermit: FieldRef<"Applicant", 'String'>
    readonly inGermanySince: FieldRef<"Applicant", 'DateTime'>
    readonly street: FieldRef<"Applicant", 'String'>
    readonly houseNumber: FieldRef<"Applicant", 'String'>
    readonly postalCode: FieldRef<"Applicant", 'String'>
    readonly city: FieldRef<"Applicant", 'String'>
    readonly residentSince: FieldRef<"Applicant", 'DateTime'>
    readonly previousAddress: FieldRef<"Applicant", 'Json'>
    readonly phoneLandline: FieldRef<"Applicant", 'String'>
    readonly phoneMobile: FieldRef<"Applicant", 'String'>
    readonly email: FieldRef<"Applicant", 'String'>
    readonly taxId: FieldRef<"Applicant", 'String'>
    readonly maritalStatus: FieldRef<"Applicant", 'String'>
    readonly separationOfGoods: FieldRef<"Applicant", 'Boolean'>
    readonly numberOfChildren: FieldRef<"Applicant", 'Int'>
    readonly childrenBirthDates: FieldRef<"Applicant", 'DateTime[]'>
    readonly profession: FieldRef<"Applicant", 'String'>
    readonly employmentType: FieldRef<"Applicant", 'String'>
    readonly employedSince: FieldRef<"Applicant", 'DateTime'>
    readonly contractType: FieldRef<"Applicant", 'String'>
    readonly contractUntil: FieldRef<"Applicant", 'DateTime'>
    readonly employerName: FieldRef<"Applicant", 'String'>
    readonly employerInGermany: FieldRef<"Applicant", 'Boolean'>
    readonly netIncome: FieldRef<"Applicant", 'Decimal'>
    readonly grossIncome: FieldRef<"Applicant", 'Decimal'>
    readonly numberOfSalaries: FieldRef<"Applicant", 'Int'>
    readonly childBenefit: FieldRef<"Applicant", 'Decimal'>
    readonly otherIncome: FieldRef<"Applicant", 'Decimal'>
    readonly iban: FieldRef<"Applicant", 'String'>
    readonly bic: FieldRef<"Applicant", 'String'>
    readonly analysisFormId: FieldRef<"Applicant", 'String'>
    readonly immobillionFormId: FieldRef<"Applicant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Applicant findUnique
   */
  export type ApplicantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant findUniqueOrThrow
   */
  export type ApplicantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant findFirst
   */
  export type ApplicantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applicants.
     */
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant findFirstOrThrow
   */
  export type ApplicantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applicants.
     */
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant findMany
   */
  export type ApplicantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicants to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant create
   */
  export type ApplicantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The data needed to create a Applicant.
     */
    data: XOR<ApplicantCreateInput, ApplicantUncheckedCreateInput>
  }

  /**
   * Applicant createMany
   */
  export type ApplicantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applicants.
     */
    data: ApplicantCreateManyInput | ApplicantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Applicant createManyAndReturn
   */
  export type ApplicantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * The data used to create many Applicants.
     */
    data: ApplicantCreateManyInput | ApplicantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Applicant update
   */
  export type ApplicantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The data needed to update a Applicant.
     */
    data: XOR<ApplicantUpdateInput, ApplicantUncheckedUpdateInput>
    /**
     * Choose, which Applicant to update.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant updateMany
   */
  export type ApplicantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applicants.
     */
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyInput>
    /**
     * Filter which Applicants to update
     */
    where?: ApplicantWhereInput
    /**
     * Limit how many Applicants to update.
     */
    limit?: number
  }

  /**
   * Applicant updateManyAndReturn
   */
  export type ApplicantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * The data used to update Applicants.
     */
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyInput>
    /**
     * Filter which Applicants to update
     */
    where?: ApplicantWhereInput
    /**
     * Limit how many Applicants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Applicant upsert
   */
  export type ApplicantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The filter to search for the Applicant to update in case it exists.
     */
    where: ApplicantWhereUniqueInput
    /**
     * In case the Applicant found by the `where` argument doesn't exist, create a new Applicant with this data.
     */
    create: XOR<ApplicantCreateInput, ApplicantUncheckedCreateInput>
    /**
     * In case the Applicant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicantUpdateInput, ApplicantUncheckedUpdateInput>
  }

  /**
   * Applicant delete
   */
  export type ApplicantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter which Applicant to delete.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant deleteMany
   */
  export type ApplicantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applicants to delete
     */
    where?: ApplicantWhereInput
    /**
     * Limit how many Applicants to delete.
     */
    limit?: number
  }

  /**
   * Applicant.analysisForm
   */
  export type Applicant$analysisFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    where?: AnalysisFormWhereInput
  }

  /**
   * Applicant.immobillionForm
   */
  export type Applicant$immobillionFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    where?: ImmobillionFormWhereInput
  }

  /**
   * Applicant.immobillionDetails
   */
  export type Applicant$immobillionDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    where?: ImmobillionApplicantDetailsWhereInput
  }

  /**
   * Applicant without action
   */
  export type ApplicantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
  }


  /**
   * Model ImmobillionApplicantDetails
   */

  export type AggregateImmobillionApplicantDetails = {
    _count: ImmobillionApplicantDetailsCountAggregateOutputType | null
    _avg: ImmobillionApplicantDetailsAvgAggregateOutputType | null
    _sum: ImmobillionApplicantDetailsSumAggregateOutputType | null
    _min: ImmobillionApplicantDetailsMinAggregateOutputType | null
    _max: ImmobillionApplicantDetailsMaxAggregateOutputType | null
  }

  export type ImmobillionApplicantDetailsAvgAggregateOutputType = {
    vehiclesInHousehold: number | null
    statutoryPension: Decimal | null
    privatePension: Decimal | null
  }

  export type ImmobillionApplicantDetailsSumAggregateOutputType = {
    vehiclesInHousehold: number | null
    statutoryPension: Decimal | null
    privatePension: Decimal | null
  }

  export type ImmobillionApplicantDetailsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    applicantId: string | null
    salaryCurrency: string | null
    salaryCurrencyOther: string | null
    hasPartTimeJob: boolean | null
    partTimeSince: Date | null
    isFreelancer: boolean | null
    isSelfEmployed: boolean | null
    selfEmployedAs: string | null
    selfEmployedSince: Date | null
    selfEmployedCompany: string | null
    vehiclesInHousehold: number | null
    retirementStart: Date | null
    statutoryPension: Decimal | null
    privatePension: Decimal | null
    interpreterRequired: boolean | null
  }

  export type ImmobillionApplicantDetailsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    applicantId: string | null
    salaryCurrency: string | null
    salaryCurrencyOther: string | null
    hasPartTimeJob: boolean | null
    partTimeSince: Date | null
    isFreelancer: boolean | null
    isSelfEmployed: boolean | null
    selfEmployedAs: string | null
    selfEmployedSince: Date | null
    selfEmployedCompany: string | null
    vehiclesInHousehold: number | null
    retirementStart: Date | null
    statutoryPension: Decimal | null
    privatePension: Decimal | null
    interpreterRequired: boolean | null
  }

  export type ImmobillionApplicantDetailsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    applicantId: number
    salaryCurrency: number
    salaryCurrencyOther: number
    hasPartTimeJob: number
    partTimeSince: number
    isFreelancer: number
    isSelfEmployed: number
    selfEmployedAs: number
    selfEmployedSince: number
    selfEmployedCompany: number
    vehiclesInHousehold: number
    retirementStart: number
    statutoryPension: number
    privatePension: number
    interpreterRequired: number
    monthlyIncome: number
    monthlyExpenses: number
    assets: number
    liabilities: number
    _all: number
  }


  export type ImmobillionApplicantDetailsAvgAggregateInputType = {
    vehiclesInHousehold?: true
    statutoryPension?: true
    privatePension?: true
  }

  export type ImmobillionApplicantDetailsSumAggregateInputType = {
    vehiclesInHousehold?: true
    statutoryPension?: true
    privatePension?: true
  }

  export type ImmobillionApplicantDetailsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    salaryCurrency?: true
    salaryCurrencyOther?: true
    hasPartTimeJob?: true
    partTimeSince?: true
    isFreelancer?: true
    isSelfEmployed?: true
    selfEmployedAs?: true
    selfEmployedSince?: true
    selfEmployedCompany?: true
    vehiclesInHousehold?: true
    retirementStart?: true
    statutoryPension?: true
    privatePension?: true
    interpreterRequired?: true
  }

  export type ImmobillionApplicantDetailsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    salaryCurrency?: true
    salaryCurrencyOther?: true
    hasPartTimeJob?: true
    partTimeSince?: true
    isFreelancer?: true
    isSelfEmployed?: true
    selfEmployedAs?: true
    selfEmployedSince?: true
    selfEmployedCompany?: true
    vehiclesInHousehold?: true
    retirementStart?: true
    statutoryPension?: true
    privatePension?: true
    interpreterRequired?: true
  }

  export type ImmobillionApplicantDetailsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    salaryCurrency?: true
    salaryCurrencyOther?: true
    hasPartTimeJob?: true
    partTimeSince?: true
    isFreelancer?: true
    isSelfEmployed?: true
    selfEmployedAs?: true
    selfEmployedSince?: true
    selfEmployedCompany?: true
    vehiclesInHousehold?: true
    retirementStart?: true
    statutoryPension?: true
    privatePension?: true
    interpreterRequired?: true
    monthlyIncome?: true
    monthlyExpenses?: true
    assets?: true
    liabilities?: true
    _all?: true
  }

  export type ImmobillionApplicantDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImmobillionApplicantDetails to aggregate.
     */
    where?: ImmobillionApplicantDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmobillionApplicantDetails to fetch.
     */
    orderBy?: ImmobillionApplicantDetailsOrderByWithRelationInput | ImmobillionApplicantDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImmobillionApplicantDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmobillionApplicantDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmobillionApplicantDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImmobillionApplicantDetails
    **/
    _count?: true | ImmobillionApplicantDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImmobillionApplicantDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImmobillionApplicantDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImmobillionApplicantDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImmobillionApplicantDetailsMaxAggregateInputType
  }

  export type GetImmobillionApplicantDetailsAggregateType<T extends ImmobillionApplicantDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateImmobillionApplicantDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImmobillionApplicantDetails[P]>
      : GetScalarType<T[P], AggregateImmobillionApplicantDetails[P]>
  }




  export type ImmobillionApplicantDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmobillionApplicantDetailsWhereInput
    orderBy?: ImmobillionApplicantDetailsOrderByWithAggregationInput | ImmobillionApplicantDetailsOrderByWithAggregationInput[]
    by: ImmobillionApplicantDetailsScalarFieldEnum[] | ImmobillionApplicantDetailsScalarFieldEnum
    having?: ImmobillionApplicantDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImmobillionApplicantDetailsCountAggregateInputType | true
    _avg?: ImmobillionApplicantDetailsAvgAggregateInputType
    _sum?: ImmobillionApplicantDetailsSumAggregateInputType
    _min?: ImmobillionApplicantDetailsMinAggregateInputType
    _max?: ImmobillionApplicantDetailsMaxAggregateInputType
  }

  export type ImmobillionApplicantDetailsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    applicantId: string
    salaryCurrency: string | null
    salaryCurrencyOther: string | null
    hasPartTimeJob: boolean
    partTimeSince: Date | null
    isFreelancer: boolean
    isSelfEmployed: boolean
    selfEmployedAs: string | null
    selfEmployedSince: Date | null
    selfEmployedCompany: string | null
    vehiclesInHousehold: number
    retirementStart: Date | null
    statutoryPension: Decimal | null
    privatePension: Decimal | null
    interpreterRequired: boolean
    monthlyIncome: JsonValue
    monthlyExpenses: JsonValue
    assets: JsonValue
    liabilities: JsonValue
    _count: ImmobillionApplicantDetailsCountAggregateOutputType | null
    _avg: ImmobillionApplicantDetailsAvgAggregateOutputType | null
    _sum: ImmobillionApplicantDetailsSumAggregateOutputType | null
    _min: ImmobillionApplicantDetailsMinAggregateOutputType | null
    _max: ImmobillionApplicantDetailsMaxAggregateOutputType | null
  }

  type GetImmobillionApplicantDetailsGroupByPayload<T extends ImmobillionApplicantDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImmobillionApplicantDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImmobillionApplicantDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImmobillionApplicantDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], ImmobillionApplicantDetailsGroupByOutputType[P]>
        }
      >
    >


  export type ImmobillionApplicantDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    salaryCurrency?: boolean
    salaryCurrencyOther?: boolean
    hasPartTimeJob?: boolean
    partTimeSince?: boolean
    isFreelancer?: boolean
    isSelfEmployed?: boolean
    selfEmployedAs?: boolean
    selfEmployedSince?: boolean
    selfEmployedCompany?: boolean
    vehiclesInHousehold?: boolean
    retirementStart?: boolean
    statutoryPension?: boolean
    privatePension?: boolean
    interpreterRequired?: boolean
    monthlyIncome?: boolean
    monthlyExpenses?: boolean
    assets?: boolean
    liabilities?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immobillionApplicantDetails"]>

  export type ImmobillionApplicantDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    salaryCurrency?: boolean
    salaryCurrencyOther?: boolean
    hasPartTimeJob?: boolean
    partTimeSince?: boolean
    isFreelancer?: boolean
    isSelfEmployed?: boolean
    selfEmployedAs?: boolean
    selfEmployedSince?: boolean
    selfEmployedCompany?: boolean
    vehiclesInHousehold?: boolean
    retirementStart?: boolean
    statutoryPension?: boolean
    privatePension?: boolean
    interpreterRequired?: boolean
    monthlyIncome?: boolean
    monthlyExpenses?: boolean
    assets?: boolean
    liabilities?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immobillionApplicantDetails"]>

  export type ImmobillionApplicantDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    salaryCurrency?: boolean
    salaryCurrencyOther?: boolean
    hasPartTimeJob?: boolean
    partTimeSince?: boolean
    isFreelancer?: boolean
    isSelfEmployed?: boolean
    selfEmployedAs?: boolean
    selfEmployedSince?: boolean
    selfEmployedCompany?: boolean
    vehiclesInHousehold?: boolean
    retirementStart?: boolean
    statutoryPension?: boolean
    privatePension?: boolean
    interpreterRequired?: boolean
    monthlyIncome?: boolean
    monthlyExpenses?: boolean
    assets?: boolean
    liabilities?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immobillionApplicantDetails"]>

  export type ImmobillionApplicantDetailsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    salaryCurrency?: boolean
    salaryCurrencyOther?: boolean
    hasPartTimeJob?: boolean
    partTimeSince?: boolean
    isFreelancer?: boolean
    isSelfEmployed?: boolean
    selfEmployedAs?: boolean
    selfEmployedSince?: boolean
    selfEmployedCompany?: boolean
    vehiclesInHousehold?: boolean
    retirementStart?: boolean
    statutoryPension?: boolean
    privatePension?: boolean
    interpreterRequired?: boolean
    monthlyIncome?: boolean
    monthlyExpenses?: boolean
    assets?: boolean
    liabilities?: boolean
  }

  export type ImmobillionApplicantDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "applicantId" | "salaryCurrency" | "salaryCurrencyOther" | "hasPartTimeJob" | "partTimeSince" | "isFreelancer" | "isSelfEmployed" | "selfEmployedAs" | "selfEmployedSince" | "selfEmployedCompany" | "vehiclesInHousehold" | "retirementStart" | "statutoryPension" | "privatePension" | "interpreterRequired" | "monthlyIncome" | "monthlyExpenses" | "assets" | "liabilities", ExtArgs["result"]["immobillionApplicantDetails"]>
  export type ImmobillionApplicantDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }
  export type ImmobillionApplicantDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }
  export type ImmobillionApplicantDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }

  export type $ImmobillionApplicantDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImmobillionApplicantDetails"
    objects: {
      applicant: Prisma.$ApplicantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      applicantId: string
      salaryCurrency: string | null
      salaryCurrencyOther: string | null
      hasPartTimeJob: boolean
      partTimeSince: Date | null
      isFreelancer: boolean
      isSelfEmployed: boolean
      selfEmployedAs: string | null
      selfEmployedSince: Date | null
      selfEmployedCompany: string | null
      vehiclesInHousehold: number
      retirementStart: Date | null
      statutoryPension: Prisma.Decimal | null
      privatePension: Prisma.Decimal | null
      interpreterRequired: boolean
      monthlyIncome: Prisma.JsonValue
      monthlyExpenses: Prisma.JsonValue
      assets: Prisma.JsonValue
      liabilities: Prisma.JsonValue
    }, ExtArgs["result"]["immobillionApplicantDetails"]>
    composites: {}
  }

  type ImmobillionApplicantDetailsGetPayload<S extends boolean | null | undefined | ImmobillionApplicantDetailsDefaultArgs> = $Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload, S>

  type ImmobillionApplicantDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImmobillionApplicantDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImmobillionApplicantDetailsCountAggregateInputType | true
    }

  export interface ImmobillionApplicantDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImmobillionApplicantDetails'], meta: { name: 'ImmobillionApplicantDetails' } }
    /**
     * Find zero or one ImmobillionApplicantDetails that matches the filter.
     * @param {ImmobillionApplicantDetailsFindUniqueArgs} args - Arguments to find a ImmobillionApplicantDetails
     * @example
     * // Get one ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImmobillionApplicantDetailsFindUniqueArgs>(args: SelectSubset<T, ImmobillionApplicantDetailsFindUniqueArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImmobillionApplicantDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImmobillionApplicantDetailsFindUniqueOrThrowArgs} args - Arguments to find a ImmobillionApplicantDetails
     * @example
     * // Get one ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImmobillionApplicantDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, ImmobillionApplicantDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImmobillionApplicantDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionApplicantDetailsFindFirstArgs} args - Arguments to find a ImmobillionApplicantDetails
     * @example
     * // Get one ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImmobillionApplicantDetailsFindFirstArgs>(args?: SelectSubset<T, ImmobillionApplicantDetailsFindFirstArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImmobillionApplicantDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionApplicantDetailsFindFirstOrThrowArgs} args - Arguments to find a ImmobillionApplicantDetails
     * @example
     * // Get one ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImmobillionApplicantDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, ImmobillionApplicantDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImmobillionApplicantDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionApplicantDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.findMany()
     * 
     * // Get first 10 ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const immobillionApplicantDetailsWithIdOnly = await prisma.immobillionApplicantDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImmobillionApplicantDetailsFindManyArgs>(args?: SelectSubset<T, ImmobillionApplicantDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImmobillionApplicantDetails.
     * @param {ImmobillionApplicantDetailsCreateArgs} args - Arguments to create a ImmobillionApplicantDetails.
     * @example
     * // Create one ImmobillionApplicantDetails
     * const ImmobillionApplicantDetails = await prisma.immobillionApplicantDetails.create({
     *   data: {
     *     // ... data to create a ImmobillionApplicantDetails
     *   }
     * })
     * 
     */
    create<T extends ImmobillionApplicantDetailsCreateArgs>(args: SelectSubset<T, ImmobillionApplicantDetailsCreateArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImmobillionApplicantDetails.
     * @param {ImmobillionApplicantDetailsCreateManyArgs} args - Arguments to create many ImmobillionApplicantDetails.
     * @example
     * // Create many ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImmobillionApplicantDetailsCreateManyArgs>(args?: SelectSubset<T, ImmobillionApplicantDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImmobillionApplicantDetails and returns the data saved in the database.
     * @param {ImmobillionApplicantDetailsCreateManyAndReturnArgs} args - Arguments to create many ImmobillionApplicantDetails.
     * @example
     * // Create many ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImmobillionApplicantDetails and only return the `id`
     * const immobillionApplicantDetailsWithIdOnly = await prisma.immobillionApplicantDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImmobillionApplicantDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, ImmobillionApplicantDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImmobillionApplicantDetails.
     * @param {ImmobillionApplicantDetailsDeleteArgs} args - Arguments to delete one ImmobillionApplicantDetails.
     * @example
     * // Delete one ImmobillionApplicantDetails
     * const ImmobillionApplicantDetails = await prisma.immobillionApplicantDetails.delete({
     *   where: {
     *     // ... filter to delete one ImmobillionApplicantDetails
     *   }
     * })
     * 
     */
    delete<T extends ImmobillionApplicantDetailsDeleteArgs>(args: SelectSubset<T, ImmobillionApplicantDetailsDeleteArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImmobillionApplicantDetails.
     * @param {ImmobillionApplicantDetailsUpdateArgs} args - Arguments to update one ImmobillionApplicantDetails.
     * @example
     * // Update one ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImmobillionApplicantDetailsUpdateArgs>(args: SelectSubset<T, ImmobillionApplicantDetailsUpdateArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImmobillionApplicantDetails.
     * @param {ImmobillionApplicantDetailsDeleteManyArgs} args - Arguments to filter ImmobillionApplicantDetails to delete.
     * @example
     * // Delete a few ImmobillionApplicantDetails
     * const { count } = await prisma.immobillionApplicantDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImmobillionApplicantDetailsDeleteManyArgs>(args?: SelectSubset<T, ImmobillionApplicantDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImmobillionApplicantDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionApplicantDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImmobillionApplicantDetailsUpdateManyArgs>(args: SelectSubset<T, ImmobillionApplicantDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImmobillionApplicantDetails and returns the data updated in the database.
     * @param {ImmobillionApplicantDetailsUpdateManyAndReturnArgs} args - Arguments to update many ImmobillionApplicantDetails.
     * @example
     * // Update many ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImmobillionApplicantDetails and only return the `id`
     * const immobillionApplicantDetailsWithIdOnly = await prisma.immobillionApplicantDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImmobillionApplicantDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, ImmobillionApplicantDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImmobillionApplicantDetails.
     * @param {ImmobillionApplicantDetailsUpsertArgs} args - Arguments to update or create a ImmobillionApplicantDetails.
     * @example
     * // Update or create a ImmobillionApplicantDetails
     * const immobillionApplicantDetails = await prisma.immobillionApplicantDetails.upsert({
     *   create: {
     *     // ... data to create a ImmobillionApplicantDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImmobillionApplicantDetails we want to update
     *   }
     * })
     */
    upsert<T extends ImmobillionApplicantDetailsUpsertArgs>(args: SelectSubset<T, ImmobillionApplicantDetailsUpsertArgs<ExtArgs>>): Prisma__ImmobillionApplicantDetailsClient<$Result.GetResult<Prisma.$ImmobillionApplicantDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImmobillionApplicantDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionApplicantDetailsCountArgs} args - Arguments to filter ImmobillionApplicantDetails to count.
     * @example
     * // Count the number of ImmobillionApplicantDetails
     * const count = await prisma.immobillionApplicantDetails.count({
     *   where: {
     *     // ... the filter for the ImmobillionApplicantDetails we want to count
     *   }
     * })
    **/
    count<T extends ImmobillionApplicantDetailsCountArgs>(
      args?: Subset<T, ImmobillionApplicantDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImmobillionApplicantDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImmobillionApplicantDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionApplicantDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImmobillionApplicantDetailsAggregateArgs>(args: Subset<T, ImmobillionApplicantDetailsAggregateArgs>): Prisma.PrismaPromise<GetImmobillionApplicantDetailsAggregateType<T>>

    /**
     * Group by ImmobillionApplicantDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionApplicantDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImmobillionApplicantDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImmobillionApplicantDetailsGroupByArgs['orderBy'] }
        : { orderBy?: ImmobillionApplicantDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImmobillionApplicantDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImmobillionApplicantDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImmobillionApplicantDetails model
   */
  readonly fields: ImmobillionApplicantDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImmobillionApplicantDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImmobillionApplicantDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicant<T extends ApplicantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantDefaultArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImmobillionApplicantDetails model
   */
  interface ImmobillionApplicantDetailsFieldRefs {
    readonly id: FieldRef<"ImmobillionApplicantDetails", 'String'>
    readonly createdAt: FieldRef<"ImmobillionApplicantDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"ImmobillionApplicantDetails", 'DateTime'>
    readonly applicantId: FieldRef<"ImmobillionApplicantDetails", 'String'>
    readonly salaryCurrency: FieldRef<"ImmobillionApplicantDetails", 'String'>
    readonly salaryCurrencyOther: FieldRef<"ImmobillionApplicantDetails", 'String'>
    readonly hasPartTimeJob: FieldRef<"ImmobillionApplicantDetails", 'Boolean'>
    readonly partTimeSince: FieldRef<"ImmobillionApplicantDetails", 'DateTime'>
    readonly isFreelancer: FieldRef<"ImmobillionApplicantDetails", 'Boolean'>
    readonly isSelfEmployed: FieldRef<"ImmobillionApplicantDetails", 'Boolean'>
    readonly selfEmployedAs: FieldRef<"ImmobillionApplicantDetails", 'String'>
    readonly selfEmployedSince: FieldRef<"ImmobillionApplicantDetails", 'DateTime'>
    readonly selfEmployedCompany: FieldRef<"ImmobillionApplicantDetails", 'String'>
    readonly vehiclesInHousehold: FieldRef<"ImmobillionApplicantDetails", 'Int'>
    readonly retirementStart: FieldRef<"ImmobillionApplicantDetails", 'DateTime'>
    readonly statutoryPension: FieldRef<"ImmobillionApplicantDetails", 'Decimal'>
    readonly privatePension: FieldRef<"ImmobillionApplicantDetails", 'Decimal'>
    readonly interpreterRequired: FieldRef<"ImmobillionApplicantDetails", 'Boolean'>
    readonly monthlyIncome: FieldRef<"ImmobillionApplicantDetails", 'Json'>
    readonly monthlyExpenses: FieldRef<"ImmobillionApplicantDetails", 'Json'>
    readonly assets: FieldRef<"ImmobillionApplicantDetails", 'Json'>
    readonly liabilities: FieldRef<"ImmobillionApplicantDetails", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ImmobillionApplicantDetails findUnique
   */
  export type ImmobillionApplicantDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionApplicantDetails to fetch.
     */
    where: ImmobillionApplicantDetailsWhereUniqueInput
  }

  /**
   * ImmobillionApplicantDetails findUniqueOrThrow
   */
  export type ImmobillionApplicantDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionApplicantDetails to fetch.
     */
    where: ImmobillionApplicantDetailsWhereUniqueInput
  }

  /**
   * ImmobillionApplicantDetails findFirst
   */
  export type ImmobillionApplicantDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionApplicantDetails to fetch.
     */
    where?: ImmobillionApplicantDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmobillionApplicantDetails to fetch.
     */
    orderBy?: ImmobillionApplicantDetailsOrderByWithRelationInput | ImmobillionApplicantDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImmobillionApplicantDetails.
     */
    cursor?: ImmobillionApplicantDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmobillionApplicantDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmobillionApplicantDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImmobillionApplicantDetails.
     */
    distinct?: ImmobillionApplicantDetailsScalarFieldEnum | ImmobillionApplicantDetailsScalarFieldEnum[]
  }

  /**
   * ImmobillionApplicantDetails findFirstOrThrow
   */
  export type ImmobillionApplicantDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionApplicantDetails to fetch.
     */
    where?: ImmobillionApplicantDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmobillionApplicantDetails to fetch.
     */
    orderBy?: ImmobillionApplicantDetailsOrderByWithRelationInput | ImmobillionApplicantDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImmobillionApplicantDetails.
     */
    cursor?: ImmobillionApplicantDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmobillionApplicantDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmobillionApplicantDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImmobillionApplicantDetails.
     */
    distinct?: ImmobillionApplicantDetailsScalarFieldEnum | ImmobillionApplicantDetailsScalarFieldEnum[]
  }

  /**
   * ImmobillionApplicantDetails findMany
   */
  export type ImmobillionApplicantDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionApplicantDetails to fetch.
     */
    where?: ImmobillionApplicantDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmobillionApplicantDetails to fetch.
     */
    orderBy?: ImmobillionApplicantDetailsOrderByWithRelationInput | ImmobillionApplicantDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImmobillionApplicantDetails.
     */
    cursor?: ImmobillionApplicantDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmobillionApplicantDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmobillionApplicantDetails.
     */
    skip?: number
    distinct?: ImmobillionApplicantDetailsScalarFieldEnum | ImmobillionApplicantDetailsScalarFieldEnum[]
  }

  /**
   * ImmobillionApplicantDetails create
   */
  export type ImmobillionApplicantDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a ImmobillionApplicantDetails.
     */
    data: XOR<ImmobillionApplicantDetailsCreateInput, ImmobillionApplicantDetailsUncheckedCreateInput>
  }

  /**
   * ImmobillionApplicantDetails createMany
   */
  export type ImmobillionApplicantDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImmobillionApplicantDetails.
     */
    data: ImmobillionApplicantDetailsCreateManyInput | ImmobillionApplicantDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImmobillionApplicantDetails createManyAndReturn
   */
  export type ImmobillionApplicantDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many ImmobillionApplicantDetails.
     */
    data: ImmobillionApplicantDetailsCreateManyInput | ImmobillionApplicantDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImmobillionApplicantDetails update
   */
  export type ImmobillionApplicantDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a ImmobillionApplicantDetails.
     */
    data: XOR<ImmobillionApplicantDetailsUpdateInput, ImmobillionApplicantDetailsUncheckedUpdateInput>
    /**
     * Choose, which ImmobillionApplicantDetails to update.
     */
    where: ImmobillionApplicantDetailsWhereUniqueInput
  }

  /**
   * ImmobillionApplicantDetails updateMany
   */
  export type ImmobillionApplicantDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImmobillionApplicantDetails.
     */
    data: XOR<ImmobillionApplicantDetailsUpdateManyMutationInput, ImmobillionApplicantDetailsUncheckedUpdateManyInput>
    /**
     * Filter which ImmobillionApplicantDetails to update
     */
    where?: ImmobillionApplicantDetailsWhereInput
    /**
     * Limit how many ImmobillionApplicantDetails to update.
     */
    limit?: number
  }

  /**
   * ImmobillionApplicantDetails updateManyAndReturn
   */
  export type ImmobillionApplicantDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * The data used to update ImmobillionApplicantDetails.
     */
    data: XOR<ImmobillionApplicantDetailsUpdateManyMutationInput, ImmobillionApplicantDetailsUncheckedUpdateManyInput>
    /**
     * Filter which ImmobillionApplicantDetails to update
     */
    where?: ImmobillionApplicantDetailsWhereInput
    /**
     * Limit how many ImmobillionApplicantDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImmobillionApplicantDetails upsert
   */
  export type ImmobillionApplicantDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the ImmobillionApplicantDetails to update in case it exists.
     */
    where: ImmobillionApplicantDetailsWhereUniqueInput
    /**
     * In case the ImmobillionApplicantDetails found by the `where` argument doesn't exist, create a new ImmobillionApplicantDetails with this data.
     */
    create: XOR<ImmobillionApplicantDetailsCreateInput, ImmobillionApplicantDetailsUncheckedCreateInput>
    /**
     * In case the ImmobillionApplicantDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImmobillionApplicantDetailsUpdateInput, ImmobillionApplicantDetailsUncheckedUpdateInput>
  }

  /**
   * ImmobillionApplicantDetails delete
   */
  export type ImmobillionApplicantDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
    /**
     * Filter which ImmobillionApplicantDetails to delete.
     */
    where: ImmobillionApplicantDetailsWhereUniqueInput
  }

  /**
   * ImmobillionApplicantDetails deleteMany
   */
  export type ImmobillionApplicantDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImmobillionApplicantDetails to delete
     */
    where?: ImmobillionApplicantDetailsWhereInput
    /**
     * Limit how many ImmobillionApplicantDetails to delete.
     */
    limit?: number
  }

  /**
   * ImmobillionApplicantDetails without action
   */
  export type ImmobillionApplicantDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionApplicantDetails
     */
    select?: ImmobillionApplicantDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionApplicantDetails
     */
    omit?: ImmobillionApplicantDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionApplicantDetailsInclude<ExtArgs> | null
  }


  /**
   * Model ImmobillionForm
   */

  export type AggregateImmobillionForm = {
    _count: ImmobillionFormCountAggregateOutputType | null
    _min: ImmobillionFormMinAggregateOutputType | null
    _max: ImmobillionFormMaxAggregateOutputType | null
  }

  export type ImmobillionFormMinAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    formType: string | null
    formVersion: string | null
  }

  export type ImmobillionFormMaxAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    formType: string | null
    formVersion: string | null
  }

  export type ImmobillionFormCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    formType: number
    formVersion: number
    _all: number
  }


  export type ImmobillionFormMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    formType?: true
    formVersion?: true
  }

  export type ImmobillionFormMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    formType?: true
    formVersion?: true
  }

  export type ImmobillionFormCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    formType?: true
    formVersion?: true
    _all?: true
  }

  export type ImmobillionFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImmobillionForm to aggregate.
     */
    where?: ImmobillionFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmobillionForms to fetch.
     */
    orderBy?: ImmobillionFormOrderByWithRelationInput | ImmobillionFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImmobillionFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmobillionForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmobillionForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImmobillionForms
    **/
    _count?: true | ImmobillionFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImmobillionFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImmobillionFormMaxAggregateInputType
  }

  export type GetImmobillionFormAggregateType<T extends ImmobillionFormAggregateArgs> = {
        [P in keyof T & keyof AggregateImmobillionForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImmobillionForm[P]>
      : GetScalarType<T[P], AggregateImmobillionForm[P]>
  }




  export type ImmobillionFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmobillionFormWhereInput
    orderBy?: ImmobillionFormOrderByWithAggregationInput | ImmobillionFormOrderByWithAggregationInput[]
    by: ImmobillionFormScalarFieldEnum[] | ImmobillionFormScalarFieldEnum
    having?: ImmobillionFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImmobillionFormCountAggregateInputType | true
    _min?: ImmobillionFormMinAggregateInputType
    _max?: ImmobillionFormMaxAggregateInputType
  }

  export type ImmobillionFormGroupByOutputType = {
    id: string
    status: string
    createdAt: Date
    updatedAt: Date
    userId: string
    formType: string
    formVersion: string
    _count: ImmobillionFormCountAggregateOutputType | null
    _min: ImmobillionFormMinAggregateOutputType | null
    _max: ImmobillionFormMaxAggregateOutputType | null
  }

  type GetImmobillionFormGroupByPayload<T extends ImmobillionFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImmobillionFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImmobillionFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImmobillionFormGroupByOutputType[P]>
            : GetScalarType<T[P], ImmobillionFormGroupByOutputType[P]>
        }
      >
    >


  export type ImmobillionFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    formType?: boolean
    formVersion?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    applicants?: boolean | ImmobillionForm$applicantsArgs<ExtArgs>
    _count?: boolean | ImmobillionFormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immobillionForm"]>

  export type ImmobillionFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    formType?: boolean
    formVersion?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immobillionForm"]>

  export type ImmobillionFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    formType?: boolean
    formVersion?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immobillionForm"]>

  export type ImmobillionFormSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    formType?: boolean
    formVersion?: boolean
  }

  export type ImmobillionFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "createdAt" | "updatedAt" | "userId" | "formType" | "formVersion", ExtArgs["result"]["immobillionForm"]>
  export type ImmobillionFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    applicants?: boolean | ImmobillionForm$applicantsArgs<ExtArgs>
    _count?: boolean | ImmobillionFormCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImmobillionFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ImmobillionFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ImmobillionFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImmobillionForm"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      applicants: Prisma.$ApplicantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      createdAt: Date
      updatedAt: Date
      userId: string
      formType: string
      formVersion: string
    }, ExtArgs["result"]["immobillionForm"]>
    composites: {}
  }

  type ImmobillionFormGetPayload<S extends boolean | null | undefined | ImmobillionFormDefaultArgs> = $Result.GetResult<Prisma.$ImmobillionFormPayload, S>

  type ImmobillionFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImmobillionFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImmobillionFormCountAggregateInputType | true
    }

  export interface ImmobillionFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImmobillionForm'], meta: { name: 'ImmobillionForm' } }
    /**
     * Find zero or one ImmobillionForm that matches the filter.
     * @param {ImmobillionFormFindUniqueArgs} args - Arguments to find a ImmobillionForm
     * @example
     * // Get one ImmobillionForm
     * const immobillionForm = await prisma.immobillionForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImmobillionFormFindUniqueArgs>(args: SelectSubset<T, ImmobillionFormFindUniqueArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImmobillionForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImmobillionFormFindUniqueOrThrowArgs} args - Arguments to find a ImmobillionForm
     * @example
     * // Get one ImmobillionForm
     * const immobillionForm = await prisma.immobillionForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImmobillionFormFindUniqueOrThrowArgs>(args: SelectSubset<T, ImmobillionFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImmobillionForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionFormFindFirstArgs} args - Arguments to find a ImmobillionForm
     * @example
     * // Get one ImmobillionForm
     * const immobillionForm = await prisma.immobillionForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImmobillionFormFindFirstArgs>(args?: SelectSubset<T, ImmobillionFormFindFirstArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImmobillionForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionFormFindFirstOrThrowArgs} args - Arguments to find a ImmobillionForm
     * @example
     * // Get one ImmobillionForm
     * const immobillionForm = await prisma.immobillionForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImmobillionFormFindFirstOrThrowArgs>(args?: SelectSubset<T, ImmobillionFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImmobillionForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImmobillionForms
     * const immobillionForms = await prisma.immobillionForm.findMany()
     * 
     * // Get first 10 ImmobillionForms
     * const immobillionForms = await prisma.immobillionForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const immobillionFormWithIdOnly = await prisma.immobillionForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImmobillionFormFindManyArgs>(args?: SelectSubset<T, ImmobillionFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImmobillionForm.
     * @param {ImmobillionFormCreateArgs} args - Arguments to create a ImmobillionForm.
     * @example
     * // Create one ImmobillionForm
     * const ImmobillionForm = await prisma.immobillionForm.create({
     *   data: {
     *     // ... data to create a ImmobillionForm
     *   }
     * })
     * 
     */
    create<T extends ImmobillionFormCreateArgs>(args: SelectSubset<T, ImmobillionFormCreateArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImmobillionForms.
     * @param {ImmobillionFormCreateManyArgs} args - Arguments to create many ImmobillionForms.
     * @example
     * // Create many ImmobillionForms
     * const immobillionForm = await prisma.immobillionForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImmobillionFormCreateManyArgs>(args?: SelectSubset<T, ImmobillionFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImmobillionForms and returns the data saved in the database.
     * @param {ImmobillionFormCreateManyAndReturnArgs} args - Arguments to create many ImmobillionForms.
     * @example
     * // Create many ImmobillionForms
     * const immobillionForm = await prisma.immobillionForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImmobillionForms and only return the `id`
     * const immobillionFormWithIdOnly = await prisma.immobillionForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImmobillionFormCreateManyAndReturnArgs>(args?: SelectSubset<T, ImmobillionFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImmobillionForm.
     * @param {ImmobillionFormDeleteArgs} args - Arguments to delete one ImmobillionForm.
     * @example
     * // Delete one ImmobillionForm
     * const ImmobillionForm = await prisma.immobillionForm.delete({
     *   where: {
     *     // ... filter to delete one ImmobillionForm
     *   }
     * })
     * 
     */
    delete<T extends ImmobillionFormDeleteArgs>(args: SelectSubset<T, ImmobillionFormDeleteArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImmobillionForm.
     * @param {ImmobillionFormUpdateArgs} args - Arguments to update one ImmobillionForm.
     * @example
     * // Update one ImmobillionForm
     * const immobillionForm = await prisma.immobillionForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImmobillionFormUpdateArgs>(args: SelectSubset<T, ImmobillionFormUpdateArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImmobillionForms.
     * @param {ImmobillionFormDeleteManyArgs} args - Arguments to filter ImmobillionForms to delete.
     * @example
     * // Delete a few ImmobillionForms
     * const { count } = await prisma.immobillionForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImmobillionFormDeleteManyArgs>(args?: SelectSubset<T, ImmobillionFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImmobillionForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImmobillionForms
     * const immobillionForm = await prisma.immobillionForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImmobillionFormUpdateManyArgs>(args: SelectSubset<T, ImmobillionFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImmobillionForms and returns the data updated in the database.
     * @param {ImmobillionFormUpdateManyAndReturnArgs} args - Arguments to update many ImmobillionForms.
     * @example
     * // Update many ImmobillionForms
     * const immobillionForm = await prisma.immobillionForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImmobillionForms and only return the `id`
     * const immobillionFormWithIdOnly = await prisma.immobillionForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImmobillionFormUpdateManyAndReturnArgs>(args: SelectSubset<T, ImmobillionFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImmobillionForm.
     * @param {ImmobillionFormUpsertArgs} args - Arguments to update or create a ImmobillionForm.
     * @example
     * // Update or create a ImmobillionForm
     * const immobillionForm = await prisma.immobillionForm.upsert({
     *   create: {
     *     // ... data to create a ImmobillionForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImmobillionForm we want to update
     *   }
     * })
     */
    upsert<T extends ImmobillionFormUpsertArgs>(args: SelectSubset<T, ImmobillionFormUpsertArgs<ExtArgs>>): Prisma__ImmobillionFormClient<$Result.GetResult<Prisma.$ImmobillionFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImmobillionForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionFormCountArgs} args - Arguments to filter ImmobillionForms to count.
     * @example
     * // Count the number of ImmobillionForms
     * const count = await prisma.immobillionForm.count({
     *   where: {
     *     // ... the filter for the ImmobillionForms we want to count
     *   }
     * })
    **/
    count<T extends ImmobillionFormCountArgs>(
      args?: Subset<T, ImmobillionFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImmobillionFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImmobillionForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImmobillionFormAggregateArgs>(args: Subset<T, ImmobillionFormAggregateArgs>): Prisma.PrismaPromise<GetImmobillionFormAggregateType<T>>

    /**
     * Group by ImmobillionForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmobillionFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImmobillionFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImmobillionFormGroupByArgs['orderBy'] }
        : { orderBy?: ImmobillionFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImmobillionFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImmobillionFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImmobillionForm model
   */
  readonly fields: ImmobillionFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImmobillionForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImmobillionFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applicants<T extends ImmobillionForm$applicantsArgs<ExtArgs> = {}>(args?: Subset<T, ImmobillionForm$applicantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImmobillionForm model
   */
  interface ImmobillionFormFieldRefs {
    readonly id: FieldRef<"ImmobillionForm", 'String'>
    readonly status: FieldRef<"ImmobillionForm", 'String'>
    readonly createdAt: FieldRef<"ImmobillionForm", 'DateTime'>
    readonly updatedAt: FieldRef<"ImmobillionForm", 'DateTime'>
    readonly userId: FieldRef<"ImmobillionForm", 'String'>
    readonly formType: FieldRef<"ImmobillionForm", 'String'>
    readonly formVersion: FieldRef<"ImmobillionForm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImmobillionForm findUnique
   */
  export type ImmobillionFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionForm to fetch.
     */
    where: ImmobillionFormWhereUniqueInput
  }

  /**
   * ImmobillionForm findUniqueOrThrow
   */
  export type ImmobillionFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionForm to fetch.
     */
    where: ImmobillionFormWhereUniqueInput
  }

  /**
   * ImmobillionForm findFirst
   */
  export type ImmobillionFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionForm to fetch.
     */
    where?: ImmobillionFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmobillionForms to fetch.
     */
    orderBy?: ImmobillionFormOrderByWithRelationInput | ImmobillionFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImmobillionForms.
     */
    cursor?: ImmobillionFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmobillionForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmobillionForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImmobillionForms.
     */
    distinct?: ImmobillionFormScalarFieldEnum | ImmobillionFormScalarFieldEnum[]
  }

  /**
   * ImmobillionForm findFirstOrThrow
   */
  export type ImmobillionFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionForm to fetch.
     */
    where?: ImmobillionFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmobillionForms to fetch.
     */
    orderBy?: ImmobillionFormOrderByWithRelationInput | ImmobillionFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImmobillionForms.
     */
    cursor?: ImmobillionFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmobillionForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmobillionForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImmobillionForms.
     */
    distinct?: ImmobillionFormScalarFieldEnum | ImmobillionFormScalarFieldEnum[]
  }

  /**
   * ImmobillionForm findMany
   */
  export type ImmobillionFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * Filter, which ImmobillionForms to fetch.
     */
    where?: ImmobillionFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmobillionForms to fetch.
     */
    orderBy?: ImmobillionFormOrderByWithRelationInput | ImmobillionFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImmobillionForms.
     */
    cursor?: ImmobillionFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmobillionForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmobillionForms.
     */
    skip?: number
    distinct?: ImmobillionFormScalarFieldEnum | ImmobillionFormScalarFieldEnum[]
  }

  /**
   * ImmobillionForm create
   */
  export type ImmobillionFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ImmobillionForm.
     */
    data: XOR<ImmobillionFormCreateInput, ImmobillionFormUncheckedCreateInput>
  }

  /**
   * ImmobillionForm createMany
   */
  export type ImmobillionFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImmobillionForms.
     */
    data: ImmobillionFormCreateManyInput | ImmobillionFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImmobillionForm createManyAndReturn
   */
  export type ImmobillionFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * The data used to create many ImmobillionForms.
     */
    data: ImmobillionFormCreateManyInput | ImmobillionFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImmobillionForm update
   */
  export type ImmobillionFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ImmobillionForm.
     */
    data: XOR<ImmobillionFormUpdateInput, ImmobillionFormUncheckedUpdateInput>
    /**
     * Choose, which ImmobillionForm to update.
     */
    where: ImmobillionFormWhereUniqueInput
  }

  /**
   * ImmobillionForm updateMany
   */
  export type ImmobillionFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImmobillionForms.
     */
    data: XOR<ImmobillionFormUpdateManyMutationInput, ImmobillionFormUncheckedUpdateManyInput>
    /**
     * Filter which ImmobillionForms to update
     */
    where?: ImmobillionFormWhereInput
    /**
     * Limit how many ImmobillionForms to update.
     */
    limit?: number
  }

  /**
   * ImmobillionForm updateManyAndReturn
   */
  export type ImmobillionFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * The data used to update ImmobillionForms.
     */
    data: XOR<ImmobillionFormUpdateManyMutationInput, ImmobillionFormUncheckedUpdateManyInput>
    /**
     * Filter which ImmobillionForms to update
     */
    where?: ImmobillionFormWhereInput
    /**
     * Limit how many ImmobillionForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImmobillionForm upsert
   */
  export type ImmobillionFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ImmobillionForm to update in case it exists.
     */
    where: ImmobillionFormWhereUniqueInput
    /**
     * In case the ImmobillionForm found by the `where` argument doesn't exist, create a new ImmobillionForm with this data.
     */
    create: XOR<ImmobillionFormCreateInput, ImmobillionFormUncheckedCreateInput>
    /**
     * In case the ImmobillionForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImmobillionFormUpdateInput, ImmobillionFormUncheckedUpdateInput>
  }

  /**
   * ImmobillionForm delete
   */
  export type ImmobillionFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
    /**
     * Filter which ImmobillionForm to delete.
     */
    where: ImmobillionFormWhereUniqueInput
  }

  /**
   * ImmobillionForm deleteMany
   */
  export type ImmobillionFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImmobillionForms to delete
     */
    where?: ImmobillionFormWhereInput
    /**
     * Limit how many ImmobillionForms to delete.
     */
    limit?: number
  }

  /**
   * ImmobillionForm.applicants
   */
  export type ImmobillionForm$applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    where?: ApplicantWhereInput
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    cursor?: ApplicantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * ImmobillionForm without action
   */
  export type ImmobillionFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmobillionForm
     */
    select?: ImmobillionFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmobillionForm
     */
    omit?: ImmobillionFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmobillionFormInclude<ExtArgs> | null
  }


  /**
   * Model AnalysisForm
   */

  export type AggregateAnalysisForm = {
    _count: AnalysisFormCountAggregateOutputType | null
    _avg: AnalysisFormAvgAggregateOutputType | null
    _sum: AnalysisFormSumAggregateOutputType | null
    _min: AnalysisFormMinAggregateOutputType | null
    _max: AnalysisFormMaxAggregateOutputType | null
  }

  export type AnalysisFormAvgAggregateOutputType = {
    coldRent: Decimal | null
    gas: Decimal | null
    electricity: Decimal | null
    telecommunication: Decimal | null
    subscriptions: Decimal | null
    accountMaintenanceFee: Decimal | null
    livingExpenses: Decimal | null
    alimony: Decimal | null
    otherExpenses: Decimal | null
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
  }

  export type AnalysisFormSumAggregateOutputType = {
    coldRent: Decimal | null
    gas: Decimal | null
    electricity: Decimal | null
    telecommunication: Decimal | null
    subscriptions: Decimal | null
    accountMaintenanceFee: Decimal | null
    livingExpenses: Decimal | null
    alimony: Decimal | null
    otherExpenses: Decimal | null
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
  }

  export type AnalysisFormMinAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    consultantName: string | null
    officeLocation: string | null
    analysisDate: Date | null
    coldRent: Decimal | null
    gas: Decimal | null
    electricity: Decimal | null
    telecommunication: Decimal | null
    subscriptions: Decimal | null
    accountMaintenanceFee: Decimal | null
    livingExpenses: Decimal | null
    alimony: Decimal | null
    otherExpenses: Decimal | null
    addLoanOrLeasing: boolean | null
    loanBank: string | null
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
    analysisConsent: boolean | null
    analysisConsentText: string | null
    analysisConsentSignature: string | null
    analysisLocation: string | null
    analysisConsentDate: Date | null
  }

  export type AnalysisFormMaxAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    consultantName: string | null
    officeLocation: string | null
    analysisDate: Date | null
    coldRent: Decimal | null
    gas: Decimal | null
    electricity: Decimal | null
    telecommunication: Decimal | null
    subscriptions: Decimal | null
    accountMaintenanceFee: Decimal | null
    livingExpenses: Decimal | null
    alimony: Decimal | null
    otherExpenses: Decimal | null
    addLoanOrLeasing: boolean | null
    loanBank: string | null
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
    analysisConsent: boolean | null
    analysisConsentText: string | null
    analysisConsentSignature: string | null
    analysisLocation: string | null
    analysisConsentDate: Date | null
  }

  export type AnalysisFormCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    consultantName: number
    officeLocation: number
    analysisDate: number
    coldRent: number
    gas: number
    electricity: number
    telecommunication: number
    subscriptions: number
    accountMaintenanceFee: number
    livingExpenses: number
    alimony: number
    otherExpenses: number
    addLoanOrLeasing: number
    loanBank: number
    loanAmount: number
    loanMonthlyRate: number
    loanInterest: number
    analysisConsent: number
    analysisConsentText: number
    analysisConsentSignature: number
    analysisLocation: number
    analysisConsentDate: number
    _all: number
  }


  export type AnalysisFormAvgAggregateInputType = {
    coldRent?: true
    gas?: true
    electricity?: true
    telecommunication?: true
    subscriptions?: true
    accountMaintenanceFee?: true
    livingExpenses?: true
    alimony?: true
    otherExpenses?: true
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
  }

  export type AnalysisFormSumAggregateInputType = {
    coldRent?: true
    gas?: true
    electricity?: true
    telecommunication?: true
    subscriptions?: true
    accountMaintenanceFee?: true
    livingExpenses?: true
    alimony?: true
    otherExpenses?: true
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
  }

  export type AnalysisFormMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    consultantName?: true
    officeLocation?: true
    analysisDate?: true
    coldRent?: true
    gas?: true
    electricity?: true
    telecommunication?: true
    subscriptions?: true
    accountMaintenanceFee?: true
    livingExpenses?: true
    alimony?: true
    otherExpenses?: true
    addLoanOrLeasing?: true
    loanBank?: true
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
    analysisConsent?: true
    analysisConsentText?: true
    analysisConsentSignature?: true
    analysisLocation?: true
    analysisConsentDate?: true
  }

  export type AnalysisFormMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    consultantName?: true
    officeLocation?: true
    analysisDate?: true
    coldRent?: true
    gas?: true
    electricity?: true
    telecommunication?: true
    subscriptions?: true
    accountMaintenanceFee?: true
    livingExpenses?: true
    alimony?: true
    otherExpenses?: true
    addLoanOrLeasing?: true
    loanBank?: true
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
    analysisConsent?: true
    analysisConsentText?: true
    analysisConsentSignature?: true
    analysisLocation?: true
    analysisConsentDate?: true
  }

  export type AnalysisFormCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    consultantName?: true
    officeLocation?: true
    analysisDate?: true
    coldRent?: true
    gas?: true
    electricity?: true
    telecommunication?: true
    subscriptions?: true
    accountMaintenanceFee?: true
    livingExpenses?: true
    alimony?: true
    otherExpenses?: true
    addLoanOrLeasing?: true
    loanBank?: true
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
    analysisConsent?: true
    analysisConsentText?: true
    analysisConsentSignature?: true
    analysisLocation?: true
    analysisConsentDate?: true
    _all?: true
  }

  export type AnalysisFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisForm to aggregate.
     */
    where?: AnalysisFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisForms to fetch.
     */
    orderBy?: AnalysisFormOrderByWithRelationInput | AnalysisFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalysisForms
    **/
    _count?: true | AnalysisFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalysisFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalysisFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisFormMaxAggregateInputType
  }

  export type GetAnalysisFormAggregateType<T extends AnalysisFormAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysisForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysisForm[P]>
      : GetScalarType<T[P], AggregateAnalysisForm[P]>
  }




  export type AnalysisFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisFormWhereInput
    orderBy?: AnalysisFormOrderByWithAggregationInput | AnalysisFormOrderByWithAggregationInput[]
    by: AnalysisFormScalarFieldEnum[] | AnalysisFormScalarFieldEnum
    having?: AnalysisFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisFormCountAggregateInputType | true
    _avg?: AnalysisFormAvgAggregateInputType
    _sum?: AnalysisFormSumAggregateInputType
    _min?: AnalysisFormMinAggregateInputType
    _max?: AnalysisFormMaxAggregateInputType
  }

  export type AnalysisFormGroupByOutputType = {
    id: string
    status: string
    createdAt: Date
    updatedAt: Date
    userId: string
    consultantName: string
    officeLocation: string
    analysisDate: Date
    coldRent: Decimal
    gas: Decimal
    electricity: Decimal
    telecommunication: Decimal
    subscriptions: Decimal
    accountMaintenanceFee: Decimal
    livingExpenses: Decimal
    alimony: Decimal
    otherExpenses: Decimal
    addLoanOrLeasing: boolean
    loanBank: string | null
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date
    _count: AnalysisFormCountAggregateOutputType | null
    _avg: AnalysisFormAvgAggregateOutputType | null
    _sum: AnalysisFormSumAggregateOutputType | null
    _min: AnalysisFormMinAggregateOutputType | null
    _max: AnalysisFormMaxAggregateOutputType | null
  }

  type GetAnalysisFormGroupByPayload<T extends AnalysisFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisFormGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisFormGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    consultantName?: boolean
    officeLocation?: boolean
    analysisDate?: boolean
    coldRent?: boolean
    gas?: boolean
    electricity?: boolean
    telecommunication?: boolean
    subscriptions?: boolean
    accountMaintenanceFee?: boolean
    livingExpenses?: boolean
    alimony?: boolean
    otherExpenses?: boolean
    addLoanOrLeasing?: boolean
    loanBank?: boolean
    loanAmount?: boolean
    loanMonthlyRate?: boolean
    loanInterest?: boolean
    analysisConsent?: boolean
    analysisConsentText?: boolean
    analysisConsentSignature?: boolean
    analysisLocation?: boolean
    analysisConsentDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    children?: boolean | AnalysisForm$childrenArgs<ExtArgs>
    applicants?: boolean | AnalysisForm$applicantsArgs<ExtArgs>
    _count?: boolean | AnalysisFormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisForm"]>

  export type AnalysisFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    consultantName?: boolean
    officeLocation?: boolean
    analysisDate?: boolean
    coldRent?: boolean
    gas?: boolean
    electricity?: boolean
    telecommunication?: boolean
    subscriptions?: boolean
    accountMaintenanceFee?: boolean
    livingExpenses?: boolean
    alimony?: boolean
    otherExpenses?: boolean
    addLoanOrLeasing?: boolean
    loanBank?: boolean
    loanAmount?: boolean
    loanMonthlyRate?: boolean
    loanInterest?: boolean
    analysisConsent?: boolean
    analysisConsentText?: boolean
    analysisConsentSignature?: boolean
    analysisLocation?: boolean
    analysisConsentDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisForm"]>

  export type AnalysisFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    consultantName?: boolean
    officeLocation?: boolean
    analysisDate?: boolean
    coldRent?: boolean
    gas?: boolean
    electricity?: boolean
    telecommunication?: boolean
    subscriptions?: boolean
    accountMaintenanceFee?: boolean
    livingExpenses?: boolean
    alimony?: boolean
    otherExpenses?: boolean
    addLoanOrLeasing?: boolean
    loanBank?: boolean
    loanAmount?: boolean
    loanMonthlyRate?: boolean
    loanInterest?: boolean
    analysisConsent?: boolean
    analysisConsentText?: boolean
    analysisConsentSignature?: boolean
    analysisLocation?: boolean
    analysisConsentDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisForm"]>

  export type AnalysisFormSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    consultantName?: boolean
    officeLocation?: boolean
    analysisDate?: boolean
    coldRent?: boolean
    gas?: boolean
    electricity?: boolean
    telecommunication?: boolean
    subscriptions?: boolean
    accountMaintenanceFee?: boolean
    livingExpenses?: boolean
    alimony?: boolean
    otherExpenses?: boolean
    addLoanOrLeasing?: boolean
    loanBank?: boolean
    loanAmount?: boolean
    loanMonthlyRate?: boolean
    loanInterest?: boolean
    analysisConsent?: boolean
    analysisConsentText?: boolean
    analysisConsentSignature?: boolean
    analysisLocation?: boolean
    analysisConsentDate?: boolean
  }

  export type AnalysisFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "createdAt" | "updatedAt" | "userId" | "consultantName" | "officeLocation" | "analysisDate" | "coldRent" | "gas" | "electricity" | "telecommunication" | "subscriptions" | "accountMaintenanceFee" | "livingExpenses" | "alimony" | "otherExpenses" | "addLoanOrLeasing" | "loanBank" | "loanAmount" | "loanMonthlyRate" | "loanInterest" | "analysisConsent" | "analysisConsentText" | "analysisConsentSignature" | "analysisLocation" | "analysisConsentDate", ExtArgs["result"]["analysisForm"]>
  export type AnalysisFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    children?: boolean | AnalysisForm$childrenArgs<ExtArgs>
    applicants?: boolean | AnalysisForm$applicantsArgs<ExtArgs>
    _count?: boolean | AnalysisFormCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnalysisFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalysisFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnalysisFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalysisForm"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      children: Prisma.$ChildPayload<ExtArgs>[]
      applicants: Prisma.$ApplicantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      createdAt: Date
      updatedAt: Date
      userId: string
      consultantName: string
      officeLocation: string
      analysisDate: Date
      coldRent: Prisma.Decimal
      gas: Prisma.Decimal
      electricity: Prisma.Decimal
      telecommunication: Prisma.Decimal
      subscriptions: Prisma.Decimal
      accountMaintenanceFee: Prisma.Decimal
      livingExpenses: Prisma.Decimal
      alimony: Prisma.Decimal
      otherExpenses: Prisma.Decimal
      addLoanOrLeasing: boolean
      loanBank: string | null
      loanAmount: Prisma.Decimal | null
      loanMonthlyRate: Prisma.Decimal | null
      loanInterest: Prisma.Decimal | null
      analysisConsent: boolean
      analysisConsentText: string
      analysisConsentSignature: string
      analysisLocation: string
      analysisConsentDate: Date
    }, ExtArgs["result"]["analysisForm"]>
    composites: {}
  }

  type AnalysisFormGetPayload<S extends boolean | null | undefined | AnalysisFormDefaultArgs> = $Result.GetResult<Prisma.$AnalysisFormPayload, S>

  type AnalysisFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalysisFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalysisFormCountAggregateInputType | true
    }

  export interface AnalysisFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalysisForm'], meta: { name: 'AnalysisForm' } }
    /**
     * Find zero or one AnalysisForm that matches the filter.
     * @param {AnalysisFormFindUniqueArgs} args - Arguments to find a AnalysisForm
     * @example
     * // Get one AnalysisForm
     * const analysisForm = await prisma.analysisForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisFormFindUniqueArgs>(args: SelectSubset<T, AnalysisFormFindUniqueArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalysisForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalysisFormFindUniqueOrThrowArgs} args - Arguments to find a AnalysisForm
     * @example
     * // Get one AnalysisForm
     * const analysisForm = await prisma.analysisForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisFormFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFormFindFirstArgs} args - Arguments to find a AnalysisForm
     * @example
     * // Get one AnalysisForm
     * const analysisForm = await prisma.analysisForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisFormFindFirstArgs>(args?: SelectSubset<T, AnalysisFormFindFirstArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFormFindFirstOrThrowArgs} args - Arguments to find a AnalysisForm
     * @example
     * // Get one AnalysisForm
     * const analysisForm = await prisma.analysisForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisFormFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalysisForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalysisForms
     * const analysisForms = await prisma.analysisForm.findMany()
     * 
     * // Get first 10 AnalysisForms
     * const analysisForms = await prisma.analysisForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisFormWithIdOnly = await prisma.analysisForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisFormFindManyArgs>(args?: SelectSubset<T, AnalysisFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalysisForm.
     * @param {AnalysisFormCreateArgs} args - Arguments to create a AnalysisForm.
     * @example
     * // Create one AnalysisForm
     * const AnalysisForm = await prisma.analysisForm.create({
     *   data: {
     *     // ... data to create a AnalysisForm
     *   }
     * })
     * 
     */
    create<T extends AnalysisFormCreateArgs>(args: SelectSubset<T, AnalysisFormCreateArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalysisForms.
     * @param {AnalysisFormCreateManyArgs} args - Arguments to create many AnalysisForms.
     * @example
     * // Create many AnalysisForms
     * const analysisForm = await prisma.analysisForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisFormCreateManyArgs>(args?: SelectSubset<T, AnalysisFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalysisForms and returns the data saved in the database.
     * @param {AnalysisFormCreateManyAndReturnArgs} args - Arguments to create many AnalysisForms.
     * @example
     * // Create many AnalysisForms
     * const analysisForm = await prisma.analysisForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalysisForms and only return the `id`
     * const analysisFormWithIdOnly = await prisma.analysisForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisFormCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalysisForm.
     * @param {AnalysisFormDeleteArgs} args - Arguments to delete one AnalysisForm.
     * @example
     * // Delete one AnalysisForm
     * const AnalysisForm = await prisma.analysisForm.delete({
     *   where: {
     *     // ... filter to delete one AnalysisForm
     *   }
     * })
     * 
     */
    delete<T extends AnalysisFormDeleteArgs>(args: SelectSubset<T, AnalysisFormDeleteArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalysisForm.
     * @param {AnalysisFormUpdateArgs} args - Arguments to update one AnalysisForm.
     * @example
     * // Update one AnalysisForm
     * const analysisForm = await prisma.analysisForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisFormUpdateArgs>(args: SelectSubset<T, AnalysisFormUpdateArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalysisForms.
     * @param {AnalysisFormDeleteManyArgs} args - Arguments to filter AnalysisForms to delete.
     * @example
     * // Delete a few AnalysisForms
     * const { count } = await prisma.analysisForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisFormDeleteManyArgs>(args?: SelectSubset<T, AnalysisFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalysisForms
     * const analysisForm = await prisma.analysisForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisFormUpdateManyArgs>(args: SelectSubset<T, AnalysisFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisForms and returns the data updated in the database.
     * @param {AnalysisFormUpdateManyAndReturnArgs} args - Arguments to update many AnalysisForms.
     * @example
     * // Update many AnalysisForms
     * const analysisForm = await prisma.analysisForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalysisForms and only return the `id`
     * const analysisFormWithIdOnly = await prisma.analysisForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalysisFormUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalysisFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalysisForm.
     * @param {AnalysisFormUpsertArgs} args - Arguments to update or create a AnalysisForm.
     * @example
     * // Update or create a AnalysisForm
     * const analysisForm = await prisma.analysisForm.upsert({
     *   create: {
     *     // ... data to create a AnalysisForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalysisForm we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisFormUpsertArgs>(args: SelectSubset<T, AnalysisFormUpsertArgs<ExtArgs>>): Prisma__AnalysisFormClient<$Result.GetResult<Prisma.$AnalysisFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalysisForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFormCountArgs} args - Arguments to filter AnalysisForms to count.
     * @example
     * // Count the number of AnalysisForms
     * const count = await prisma.analysisForm.count({
     *   where: {
     *     // ... the filter for the AnalysisForms we want to count
     *   }
     * })
    **/
    count<T extends AnalysisFormCountArgs>(
      args?: Subset<T, AnalysisFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalysisForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisFormAggregateArgs>(args: Subset<T, AnalysisFormAggregateArgs>): Prisma.PrismaPromise<GetAnalysisFormAggregateType<T>>

    /**
     * Group by AnalysisForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisFormGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalysisForm model
   */
  readonly fields: AnalysisFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalysisForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    children<T extends AnalysisForm$childrenArgs<ExtArgs> = {}>(args?: Subset<T, AnalysisForm$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applicants<T extends AnalysisForm$applicantsArgs<ExtArgs> = {}>(args?: Subset<T, AnalysisForm$applicantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalysisForm model
   */
  interface AnalysisFormFieldRefs {
    readonly id: FieldRef<"AnalysisForm", 'String'>
    readonly status: FieldRef<"AnalysisForm", 'String'>
    readonly createdAt: FieldRef<"AnalysisForm", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalysisForm", 'DateTime'>
    readonly userId: FieldRef<"AnalysisForm", 'String'>
    readonly consultantName: FieldRef<"AnalysisForm", 'String'>
    readonly officeLocation: FieldRef<"AnalysisForm", 'String'>
    readonly analysisDate: FieldRef<"AnalysisForm", 'DateTime'>
    readonly coldRent: FieldRef<"AnalysisForm", 'Decimal'>
    readonly gas: FieldRef<"AnalysisForm", 'Decimal'>
    readonly electricity: FieldRef<"AnalysisForm", 'Decimal'>
    readonly telecommunication: FieldRef<"AnalysisForm", 'Decimal'>
    readonly subscriptions: FieldRef<"AnalysisForm", 'Decimal'>
    readonly accountMaintenanceFee: FieldRef<"AnalysisForm", 'Decimal'>
    readonly livingExpenses: FieldRef<"AnalysisForm", 'Decimal'>
    readonly alimony: FieldRef<"AnalysisForm", 'Decimal'>
    readonly otherExpenses: FieldRef<"AnalysisForm", 'Decimal'>
    readonly addLoanOrLeasing: FieldRef<"AnalysisForm", 'Boolean'>
    readonly loanBank: FieldRef<"AnalysisForm", 'String'>
    readonly loanAmount: FieldRef<"AnalysisForm", 'Decimal'>
    readonly loanMonthlyRate: FieldRef<"AnalysisForm", 'Decimal'>
    readonly loanInterest: FieldRef<"AnalysisForm", 'Decimal'>
    readonly analysisConsent: FieldRef<"AnalysisForm", 'Boolean'>
    readonly analysisConsentText: FieldRef<"AnalysisForm", 'String'>
    readonly analysisConsentSignature: FieldRef<"AnalysisForm", 'String'>
    readonly analysisLocation: FieldRef<"AnalysisForm", 'String'>
    readonly analysisConsentDate: FieldRef<"AnalysisForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalysisForm findUnique
   */
  export type AnalysisFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisForm to fetch.
     */
    where: AnalysisFormWhereUniqueInput
  }

  /**
   * AnalysisForm findUniqueOrThrow
   */
  export type AnalysisFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisForm to fetch.
     */
    where: AnalysisFormWhereUniqueInput
  }

  /**
   * AnalysisForm findFirst
   */
  export type AnalysisFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisForm to fetch.
     */
    where?: AnalysisFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisForms to fetch.
     */
    orderBy?: AnalysisFormOrderByWithRelationInput | AnalysisFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisForms.
     */
    cursor?: AnalysisFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisForms.
     */
    distinct?: AnalysisFormScalarFieldEnum | AnalysisFormScalarFieldEnum[]
  }

  /**
   * AnalysisForm findFirstOrThrow
   */
  export type AnalysisFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisForm to fetch.
     */
    where?: AnalysisFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisForms to fetch.
     */
    orderBy?: AnalysisFormOrderByWithRelationInput | AnalysisFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisForms.
     */
    cursor?: AnalysisFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisForms.
     */
    distinct?: AnalysisFormScalarFieldEnum | AnalysisFormScalarFieldEnum[]
  }

  /**
   * AnalysisForm findMany
   */
  export type AnalysisFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisForms to fetch.
     */
    where?: AnalysisFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisForms to fetch.
     */
    orderBy?: AnalysisFormOrderByWithRelationInput | AnalysisFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalysisForms.
     */
    cursor?: AnalysisFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisForms.
     */
    skip?: number
    distinct?: AnalysisFormScalarFieldEnum | AnalysisFormScalarFieldEnum[]
  }

  /**
   * AnalysisForm create
   */
  export type AnalysisFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalysisForm.
     */
    data: XOR<AnalysisFormCreateInput, AnalysisFormUncheckedCreateInput>
  }

  /**
   * AnalysisForm createMany
   */
  export type AnalysisFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalysisForms.
     */
    data: AnalysisFormCreateManyInput | AnalysisFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalysisForm createManyAndReturn
   */
  export type AnalysisFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * The data used to create many AnalysisForms.
     */
    data: AnalysisFormCreateManyInput | AnalysisFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisForm update
   */
  export type AnalysisFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalysisForm.
     */
    data: XOR<AnalysisFormUpdateInput, AnalysisFormUncheckedUpdateInput>
    /**
     * Choose, which AnalysisForm to update.
     */
    where: AnalysisFormWhereUniqueInput
  }

  /**
   * AnalysisForm updateMany
   */
  export type AnalysisFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalysisForms.
     */
    data: XOR<AnalysisFormUpdateManyMutationInput, AnalysisFormUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisForms to update
     */
    where?: AnalysisFormWhereInput
    /**
     * Limit how many AnalysisForms to update.
     */
    limit?: number
  }

  /**
   * AnalysisForm updateManyAndReturn
   */
  export type AnalysisFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * The data used to update AnalysisForms.
     */
    data: XOR<AnalysisFormUpdateManyMutationInput, AnalysisFormUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisForms to update
     */
    where?: AnalysisFormWhereInput
    /**
     * Limit how many AnalysisForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisForm upsert
   */
  export type AnalysisFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalysisForm to update in case it exists.
     */
    where: AnalysisFormWhereUniqueInput
    /**
     * In case the AnalysisForm found by the `where` argument doesn't exist, create a new AnalysisForm with this data.
     */
    create: XOR<AnalysisFormCreateInput, AnalysisFormUncheckedCreateInput>
    /**
     * In case the AnalysisForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisFormUpdateInput, AnalysisFormUncheckedUpdateInput>
  }

  /**
   * AnalysisForm delete
   */
  export type AnalysisFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
    /**
     * Filter which AnalysisForm to delete.
     */
    where: AnalysisFormWhereUniqueInput
  }

  /**
   * AnalysisForm deleteMany
   */
  export type AnalysisFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisForms to delete
     */
    where?: AnalysisFormWhereInput
    /**
     * Limit how many AnalysisForms to delete.
     */
    limit?: number
  }

  /**
   * AnalysisForm.children
   */
  export type AnalysisForm$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    cursor?: ChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * AnalysisForm.applicants
   */
  export type AnalysisForm$applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    where?: ApplicantWhereInput
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    cursor?: ApplicantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * AnalysisForm without action
   */
  export type AnalysisFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisForm
     */
    select?: AnalysisFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisForm
     */
    omit?: AnalysisFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisFormInclude<ExtArgs> | null
  }


  /**
   * Model PersonalDetails
   */

  export type AggregatePersonalDetails = {
    _count: PersonalDetailsCountAggregateOutputType | null
    _min: PersonalDetailsMinAggregateOutputType | null
    _max: PersonalDetailsMaxAggregateOutputType | null
  }

  export type PersonalDetailsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    coachId: string | null
    applicantType: $Enums.ApplicantType | null
    firstName: string | null
    lastName: string | null
    streetAddress: string | null
    postalCode: string | null
    city: string | null
    phone: string | null
    email: string | null
    birthDate: Date | null
    birthPlace: string | null
    maritalStatus: string | null
    nationality: string | null
    housing: string | null
  }

  export type PersonalDetailsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    coachId: string | null
    applicantType: $Enums.ApplicantType | null
    firstName: string | null
    lastName: string | null
    streetAddress: string | null
    postalCode: string | null
    city: string | null
    phone: string | null
    email: string | null
    birthDate: Date | null
    birthPlace: string | null
    maritalStatus: string | null
    nationality: string | null
    housing: string | null
  }

  export type PersonalDetailsCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    coachId: number
    applicantType: number
    firstName: number
    lastName: number
    streetAddress: number
    postalCode: number
    city: number
    phone: number
    email: number
    birthDate: number
    birthPlace: number
    maritalStatus: number
    nationality: number
    housing: number
    _all: number
  }


  export type PersonalDetailsMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    coachId?: true
    applicantType?: true
    firstName?: true
    lastName?: true
    streetAddress?: true
    postalCode?: true
    city?: true
    phone?: true
    email?: true
    birthDate?: true
    birthPlace?: true
    maritalStatus?: true
    nationality?: true
    housing?: true
  }

  export type PersonalDetailsMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    coachId?: true
    applicantType?: true
    firstName?: true
    lastName?: true
    streetAddress?: true
    postalCode?: true
    city?: true
    phone?: true
    email?: true
    birthDate?: true
    birthPlace?: true
    maritalStatus?: true
    nationality?: true
    housing?: true
  }

  export type PersonalDetailsCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    coachId?: true
    applicantType?: true
    firstName?: true
    lastName?: true
    streetAddress?: true
    postalCode?: true
    city?: true
    phone?: true
    email?: true
    birthDate?: true
    birthPlace?: true
    maritalStatus?: true
    nationality?: true
    housing?: true
    _all?: true
  }

  export type PersonalDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalDetails to aggregate.
     */
    where?: PersonalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalDetails
    **/
    _count?: true | PersonalDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalDetailsMaxAggregateInputType
  }

  export type GetPersonalDetailsAggregateType<T extends PersonalDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalDetails[P]>
      : GetScalarType<T[P], AggregatePersonalDetails[P]>
  }




  export type PersonalDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalDetailsWhereInput
    orderBy?: PersonalDetailsOrderByWithAggregationInput | PersonalDetailsOrderByWithAggregationInput[]
    by: PersonalDetailsScalarFieldEnum[] | PersonalDetailsScalarFieldEnum
    having?: PersonalDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalDetailsCountAggregateInputType | true
    _min?: PersonalDetailsMinAggregateInputType
    _max?: PersonalDetailsMaxAggregateInputType
  }

  export type PersonalDetailsGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    _count: PersonalDetailsCountAggregateOutputType | null
    _min: PersonalDetailsMinAggregateOutputType | null
    _max: PersonalDetailsMaxAggregateOutputType | null
  }

  type GetPersonalDetailsGroupByPayload<T extends PersonalDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalDetailsGroupByOutputType[P]>
        }
      >
    >


  export type PersonalDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coachId?: boolean
    applicantType?: boolean
    firstName?: boolean
    lastName?: boolean
    streetAddress?: boolean
    postalCode?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    housing?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | UserDefaultArgs<ExtArgs>
    employmentDetails?: boolean | PersonalDetails$employmentDetailsArgs<ExtArgs>
    incomeDetails?: boolean | PersonalDetails$incomeDetailsArgs<ExtArgs>
    expensesDetails?: boolean | PersonalDetails$expensesDetailsArgs<ExtArgs>
    assets?: boolean | PersonalDetails$assetsArgs<ExtArgs>
    liabilities?: boolean | PersonalDetails$liabilitiesArgs<ExtArgs>
    goalsAndWishes?: boolean | PersonalDetails$goalsAndWishesArgs<ExtArgs>
    riskAppetite?: boolean | PersonalDetails$riskAppetiteArgs<ExtArgs>
    consents?: boolean | PersonalDetails$consentsArgs<ExtArgs>
    documents?: boolean | PersonalDetails$documentsArgs<ExtArgs>
    forms?: boolean | PersonalDetails$formsArgs<ExtArgs>
    customForms?: boolean | PersonalDetails$customFormsArgs<ExtArgs>
    _count?: boolean | PersonalDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalDetails"]>

  export type PersonalDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coachId?: boolean
    applicantType?: boolean
    firstName?: boolean
    lastName?: boolean
    streetAddress?: boolean
    postalCode?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    housing?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalDetails"]>

  export type PersonalDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coachId?: boolean
    applicantType?: boolean
    firstName?: boolean
    lastName?: boolean
    streetAddress?: boolean
    postalCode?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    housing?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalDetails"]>

  export type PersonalDetailsSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coachId?: boolean
    applicantType?: boolean
    firstName?: boolean
    lastName?: boolean
    streetAddress?: boolean
    postalCode?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    housing?: boolean
  }

  export type PersonalDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt" | "coachId" | "applicantType" | "firstName" | "lastName" | "streetAddress" | "postalCode" | "city" | "phone" | "email" | "birthDate" | "birthPlace" | "maritalStatus" | "nationality" | "housing", ExtArgs["result"]["personalDetails"]>
  export type PersonalDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | UserDefaultArgs<ExtArgs>
    employmentDetails?: boolean | PersonalDetails$employmentDetailsArgs<ExtArgs>
    incomeDetails?: boolean | PersonalDetails$incomeDetailsArgs<ExtArgs>
    expensesDetails?: boolean | PersonalDetails$expensesDetailsArgs<ExtArgs>
    assets?: boolean | PersonalDetails$assetsArgs<ExtArgs>
    liabilities?: boolean | PersonalDetails$liabilitiesArgs<ExtArgs>
    goalsAndWishes?: boolean | PersonalDetails$goalsAndWishesArgs<ExtArgs>
    riskAppetite?: boolean | PersonalDetails$riskAppetiteArgs<ExtArgs>
    consents?: boolean | PersonalDetails$consentsArgs<ExtArgs>
    documents?: boolean | PersonalDetails$documentsArgs<ExtArgs>
    forms?: boolean | PersonalDetails$formsArgs<ExtArgs>
    customForms?: boolean | PersonalDetails$customFormsArgs<ExtArgs>
    _count?: boolean | PersonalDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonalDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PersonalDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PersonalDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalDetails"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coach: Prisma.$UserPayload<ExtArgs>
      employmentDetails: Prisma.$EmploymentDetailsPayload<ExtArgs>[]
      incomeDetails: Prisma.$IncomeDetailsPayload<ExtArgs>[]
      expensesDetails: Prisma.$ExpensesDetailsPayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      liabilities: Prisma.$LiabilityPayload<ExtArgs>[]
      goalsAndWishes: Prisma.$GoalsAndWishesPayload<ExtArgs> | null
      riskAppetite: Prisma.$RiskAppetitePayload<ExtArgs> | null
      consents: Prisma.$ConsentPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      forms: Prisma.$FormPayload<ExtArgs>[]
      customForms: Prisma.$CustomFormPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
      coachId: string
      applicantType: $Enums.ApplicantType
      firstName: string
      lastName: string
      streetAddress: string
      postalCode: string
      city: string
      phone: string
      email: string
      birthDate: Date
      birthPlace: string
      maritalStatus: string
      nationality: string
      housing: string
    }, ExtArgs["result"]["personalDetails"]>
    composites: {}
  }

  type PersonalDetailsGetPayload<S extends boolean | null | undefined | PersonalDetailsDefaultArgs> = $Result.GetResult<Prisma.$PersonalDetailsPayload, S>

  type PersonalDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalDetailsCountAggregateInputType | true
    }

  export interface PersonalDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalDetails'], meta: { name: 'PersonalDetails' } }
    /**
     * Find zero or one PersonalDetails that matches the filter.
     * @param {PersonalDetailsFindUniqueArgs} args - Arguments to find a PersonalDetails
     * @example
     * // Get one PersonalDetails
     * const personalDetails = await prisma.personalDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalDetailsFindUniqueArgs>(args: SelectSubset<T, PersonalDetailsFindUniqueArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalDetailsFindUniqueOrThrowArgs} args - Arguments to find a PersonalDetails
     * @example
     * // Get one PersonalDetails
     * const personalDetails = await prisma.personalDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsFindFirstArgs} args - Arguments to find a PersonalDetails
     * @example
     * // Get one PersonalDetails
     * const personalDetails = await prisma.personalDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalDetailsFindFirstArgs>(args?: SelectSubset<T, PersonalDetailsFindFirstArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsFindFirstOrThrowArgs} args - Arguments to find a PersonalDetails
     * @example
     * // Get one PersonalDetails
     * const personalDetails = await prisma.personalDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalDetails
     * const personalDetails = await prisma.personalDetails.findMany()
     * 
     * // Get first 10 PersonalDetails
     * const personalDetails = await prisma.personalDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalDetailsWithIdOnly = await prisma.personalDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalDetailsFindManyArgs>(args?: SelectSubset<T, PersonalDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalDetails.
     * @param {PersonalDetailsCreateArgs} args - Arguments to create a PersonalDetails.
     * @example
     * // Create one PersonalDetails
     * const PersonalDetails = await prisma.personalDetails.create({
     *   data: {
     *     // ... data to create a PersonalDetails
     *   }
     * })
     * 
     */
    create<T extends PersonalDetailsCreateArgs>(args: SelectSubset<T, PersonalDetailsCreateArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalDetails.
     * @param {PersonalDetailsCreateManyArgs} args - Arguments to create many PersonalDetails.
     * @example
     * // Create many PersonalDetails
     * const personalDetails = await prisma.personalDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalDetailsCreateManyArgs>(args?: SelectSubset<T, PersonalDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalDetails and returns the data saved in the database.
     * @param {PersonalDetailsCreateManyAndReturnArgs} args - Arguments to create many PersonalDetails.
     * @example
     * // Create many PersonalDetails
     * const personalDetails = await prisma.personalDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalDetails and only return the `id`
     * const personalDetailsWithIdOnly = await prisma.personalDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalDetails.
     * @param {PersonalDetailsDeleteArgs} args - Arguments to delete one PersonalDetails.
     * @example
     * // Delete one PersonalDetails
     * const PersonalDetails = await prisma.personalDetails.delete({
     *   where: {
     *     // ... filter to delete one PersonalDetails
     *   }
     * })
     * 
     */
    delete<T extends PersonalDetailsDeleteArgs>(args: SelectSubset<T, PersonalDetailsDeleteArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalDetails.
     * @param {PersonalDetailsUpdateArgs} args - Arguments to update one PersonalDetails.
     * @example
     * // Update one PersonalDetails
     * const personalDetails = await prisma.personalDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalDetailsUpdateArgs>(args: SelectSubset<T, PersonalDetailsUpdateArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalDetails.
     * @param {PersonalDetailsDeleteManyArgs} args - Arguments to filter PersonalDetails to delete.
     * @example
     * // Delete a few PersonalDetails
     * const { count } = await prisma.personalDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalDetailsDeleteManyArgs>(args?: SelectSubset<T, PersonalDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalDetails
     * const personalDetails = await prisma.personalDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalDetailsUpdateManyArgs>(args: SelectSubset<T, PersonalDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalDetails and returns the data updated in the database.
     * @param {PersonalDetailsUpdateManyAndReturnArgs} args - Arguments to update many PersonalDetails.
     * @example
     * // Update many PersonalDetails
     * const personalDetails = await prisma.personalDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalDetails and only return the `id`
     * const personalDetailsWithIdOnly = await prisma.personalDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalDetails.
     * @param {PersonalDetailsUpsertArgs} args - Arguments to update or create a PersonalDetails.
     * @example
     * // Update or create a PersonalDetails
     * const personalDetails = await prisma.personalDetails.upsert({
     *   create: {
     *     // ... data to create a PersonalDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalDetails we want to update
     *   }
     * })
     */
    upsert<T extends PersonalDetailsUpsertArgs>(args: SelectSubset<T, PersonalDetailsUpsertArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsCountArgs} args - Arguments to filter PersonalDetails to count.
     * @example
     * // Count the number of PersonalDetails
     * const count = await prisma.personalDetails.count({
     *   where: {
     *     // ... the filter for the PersonalDetails we want to count
     *   }
     * })
    **/
    count<T extends PersonalDetailsCountArgs>(
      args?: Subset<T, PersonalDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalDetailsAggregateArgs>(args: Subset<T, PersonalDetailsAggregateArgs>): Prisma.PrismaPromise<GetPersonalDetailsAggregateType<T>>

    /**
     * Group by PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalDetailsGroupByArgs['orderBy'] }
        : { orderBy?: PersonalDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalDetails model
   */
  readonly fields: PersonalDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coach<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employmentDetails<T extends PersonalDetails$employmentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$employmentDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incomeDetails<T extends PersonalDetails$incomeDetailsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$incomeDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expensesDetails<T extends PersonalDetails$expensesDetailsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$expensesDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assets<T extends PersonalDetails$assetsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liabilities<T extends PersonalDetails$liabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$liabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    goalsAndWishes<T extends PersonalDetails$goalsAndWishesArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$goalsAndWishesArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    riskAppetite<T extends PersonalDetails$riskAppetiteArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$riskAppetiteArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    consents<T extends PersonalDetails$consentsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends PersonalDetails$documentsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forms<T extends PersonalDetails$formsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$formsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customForms<T extends PersonalDetails$customFormsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetails$customFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalDetails model
   */
  interface PersonalDetailsFieldRefs {
    readonly id: FieldRef<"PersonalDetails", 'String'>
    readonly userId: FieldRef<"PersonalDetails", 'String'>
    readonly createdAt: FieldRef<"PersonalDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonalDetails", 'DateTime'>
    readonly coachId: FieldRef<"PersonalDetails", 'String'>
    readonly applicantType: FieldRef<"PersonalDetails", 'ApplicantType'>
    readonly firstName: FieldRef<"PersonalDetails", 'String'>
    readonly lastName: FieldRef<"PersonalDetails", 'String'>
    readonly streetAddress: FieldRef<"PersonalDetails", 'String'>
    readonly postalCode: FieldRef<"PersonalDetails", 'String'>
    readonly city: FieldRef<"PersonalDetails", 'String'>
    readonly phone: FieldRef<"PersonalDetails", 'String'>
    readonly email: FieldRef<"PersonalDetails", 'String'>
    readonly birthDate: FieldRef<"PersonalDetails", 'DateTime'>
    readonly birthPlace: FieldRef<"PersonalDetails", 'String'>
    readonly maritalStatus: FieldRef<"PersonalDetails", 'String'>
    readonly nationality: FieldRef<"PersonalDetails", 'String'>
    readonly housing: FieldRef<"PersonalDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PersonalDetails findUnique
   */
  export type PersonalDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where: PersonalDetailsWhereUniqueInput
  }

  /**
   * PersonalDetails findUniqueOrThrow
   */
  export type PersonalDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where: PersonalDetailsWhereUniqueInput
  }

  /**
   * PersonalDetails findFirst
   */
  export type PersonalDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where?: PersonalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalDetails.
     */
    cursor?: PersonalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalDetails.
     */
    distinct?: PersonalDetailsScalarFieldEnum | PersonalDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails findFirstOrThrow
   */
  export type PersonalDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where?: PersonalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalDetails.
     */
    cursor?: PersonalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalDetails.
     */
    distinct?: PersonalDetailsScalarFieldEnum | PersonalDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails findMany
   */
  export type PersonalDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where?: PersonalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalDetails.
     */
    cursor?: PersonalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    distinct?: PersonalDetailsScalarFieldEnum | PersonalDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails create
   */
  export type PersonalDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalDetails.
     */
    data: XOR<PersonalDetailsCreateInput, PersonalDetailsUncheckedCreateInput>
  }

  /**
   * PersonalDetails createMany
   */
  export type PersonalDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalDetails.
     */
    data: PersonalDetailsCreateManyInput | PersonalDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalDetails createManyAndReturn
   */
  export type PersonalDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalDetails.
     */
    data: PersonalDetailsCreateManyInput | PersonalDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalDetails update
   */
  export type PersonalDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalDetails.
     */
    data: XOR<PersonalDetailsUpdateInput, PersonalDetailsUncheckedUpdateInput>
    /**
     * Choose, which PersonalDetails to update.
     */
    where: PersonalDetailsWhereUniqueInput
  }

  /**
   * PersonalDetails updateMany
   */
  export type PersonalDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalDetails.
     */
    data: XOR<PersonalDetailsUpdateManyMutationInput, PersonalDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PersonalDetails to update
     */
    where?: PersonalDetailsWhereInput
    /**
     * Limit how many PersonalDetails to update.
     */
    limit?: number
  }

  /**
   * PersonalDetails updateManyAndReturn
   */
  export type PersonalDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * The data used to update PersonalDetails.
     */
    data: XOR<PersonalDetailsUpdateManyMutationInput, PersonalDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PersonalDetails to update
     */
    where?: PersonalDetailsWhereInput
    /**
     * Limit how many PersonalDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalDetails upsert
   */
  export type PersonalDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalDetails to update in case it exists.
     */
    where: PersonalDetailsWhereUniqueInput
    /**
     * In case the PersonalDetails found by the `where` argument doesn't exist, create a new PersonalDetails with this data.
     */
    create: XOR<PersonalDetailsCreateInput, PersonalDetailsUncheckedCreateInput>
    /**
     * In case the PersonalDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalDetailsUpdateInput, PersonalDetailsUncheckedUpdateInput>
  }

  /**
   * PersonalDetails delete
   */
  export type PersonalDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter which PersonalDetails to delete.
     */
    where: PersonalDetailsWhereUniqueInput
  }

  /**
   * PersonalDetails deleteMany
   */
  export type PersonalDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalDetails to delete
     */
    where?: PersonalDetailsWhereInput
    /**
     * Limit how many PersonalDetails to delete.
     */
    limit?: number
  }

  /**
   * PersonalDetails.employmentDetails
   */
  export type PersonalDetails$employmentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    where?: EmploymentDetailsWhereInput
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    cursor?: EmploymentDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentDetailsScalarFieldEnum | EmploymentDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails.incomeDetails
   */
  export type PersonalDetails$incomeDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    where?: IncomeDetailsWhereInput
    orderBy?: IncomeDetailsOrderByWithRelationInput | IncomeDetailsOrderByWithRelationInput[]
    cursor?: IncomeDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncomeDetailsScalarFieldEnum | IncomeDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails.expensesDetails
   */
  export type PersonalDetails$expensesDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    where?: ExpensesDetailsWhereInput
    orderBy?: ExpensesDetailsOrderByWithRelationInput | ExpensesDetailsOrderByWithRelationInput[]
    cursor?: ExpensesDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpensesDetailsScalarFieldEnum | ExpensesDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails.assets
   */
  export type PersonalDetails$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * PersonalDetails.liabilities
   */
  export type PersonalDetails$liabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    where?: LiabilityWhereInput
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    cursor?: LiabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * PersonalDetails.goalsAndWishes
   */
  export type PersonalDetails$goalsAndWishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    where?: GoalsAndWishesWhereInput
  }

  /**
   * PersonalDetails.riskAppetite
   */
  export type PersonalDetails$riskAppetiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    where?: RiskAppetiteWhereInput
  }

  /**
   * PersonalDetails.consents
   */
  export type PersonalDetails$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    where?: ConsentWhereInput
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    cursor?: ConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * PersonalDetails.documents
   */
  export type PersonalDetails$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * PersonalDetails.forms
   */
  export type PersonalDetails$formsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    where?: FormWhereInput
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    cursor?: FormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * PersonalDetails.customForms
   */
  export type PersonalDetails$customFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    where?: CustomFormWhereInput
    orderBy?: CustomFormOrderByWithRelationInput | CustomFormOrderByWithRelationInput[]
    cursor?: CustomFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFormScalarFieldEnum | CustomFormScalarFieldEnum[]
  }

  /**
   * PersonalDetails without action
   */
  export type PersonalDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetails
     */
    omit?: PersonalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
  }


  /**
   * Model EmploymentDetails
   */

  export type AggregateEmploymentDetails = {
    _count: EmploymentDetailsCountAggregateOutputType | null
    _min: EmploymentDetailsMinAggregateOutputType | null
    _max: EmploymentDetailsMaxAggregateOutputType | null
  }

  export type EmploymentDetailsMinAggregateOutputType = {
    id: string | null
    employmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    employmentType: $Enums.EmploymentType | null
    occupation: string | null
    contractType: string | null
    contractDuration: string | null
    employerName: string | null
    employedSince: Date | null
  }

  export type EmploymentDetailsMaxAggregateOutputType = {
    id: string | null
    employmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    employmentType: $Enums.EmploymentType | null
    occupation: string | null
    contractType: string | null
    contractDuration: string | null
    employerName: string | null
    employedSince: Date | null
  }

  export type EmploymentDetailsCountAggregateOutputType = {
    id: number
    employmentId: number
    createdAt: number
    updatedAt: number
    personalId: number
    employmentType: number
    occupation: number
    contractType: number
    contractDuration: number
    employerName: number
    employedSince: number
    _all: number
  }


  export type EmploymentDetailsMinAggregateInputType = {
    id?: true
    employmentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    employmentType?: true
    occupation?: true
    contractType?: true
    contractDuration?: true
    employerName?: true
    employedSince?: true
  }

  export type EmploymentDetailsMaxAggregateInputType = {
    id?: true
    employmentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    employmentType?: true
    occupation?: true
    contractType?: true
    contractDuration?: true
    employerName?: true
    employedSince?: true
  }

  export type EmploymentDetailsCountAggregateInputType = {
    id?: true
    employmentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    employmentType?: true
    occupation?: true
    contractType?: true
    contractDuration?: true
    employerName?: true
    employedSince?: true
    _all?: true
  }

  export type EmploymentDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentDetails to aggregate.
     */
    where?: EmploymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmploymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmploymentDetails
    **/
    _count?: true | EmploymentDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploymentDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploymentDetailsMaxAggregateInputType
  }

  export type GetEmploymentDetailsAggregateType<T extends EmploymentDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploymentDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploymentDetails[P]>
      : GetScalarType<T[P], AggregateEmploymentDetails[P]>
  }




  export type EmploymentDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentDetailsWhereInput
    orderBy?: EmploymentDetailsOrderByWithAggregationInput | EmploymentDetailsOrderByWithAggregationInput[]
    by: EmploymentDetailsScalarFieldEnum[] | EmploymentDetailsScalarFieldEnum
    having?: EmploymentDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploymentDetailsCountAggregateInputType | true
    _min?: EmploymentDetailsMinAggregateInputType
    _max?: EmploymentDetailsMaxAggregateInputType
  }

  export type EmploymentDetailsGroupByOutputType = {
    id: string
    employmentId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    employmentType: $Enums.EmploymentType
    occupation: string
    contractType: string
    contractDuration: string
    employerName: string
    employedSince: Date
    _count: EmploymentDetailsCountAggregateOutputType | null
    _min: EmploymentDetailsMinAggregateOutputType | null
    _max: EmploymentDetailsMaxAggregateOutputType | null
  }

  type GetEmploymentDetailsGroupByPayload<T extends EmploymentDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploymentDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploymentDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploymentDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], EmploymentDetailsGroupByOutputType[P]>
        }
      >
    >


  export type EmploymentDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    employmentType?: boolean
    occupation?: boolean
    contractType?: boolean
    contractDuration?: boolean
    employerName?: boolean
    employedSince?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmentDetails"]>

  export type EmploymentDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    employmentType?: boolean
    occupation?: boolean
    contractType?: boolean
    contractDuration?: boolean
    employerName?: boolean
    employedSince?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmentDetails"]>

  export type EmploymentDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    employmentType?: boolean
    occupation?: boolean
    contractType?: boolean
    contractDuration?: boolean
    employerName?: boolean
    employedSince?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmentDetails"]>

  export type EmploymentDetailsSelectScalar = {
    id?: boolean
    employmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    employmentType?: boolean
    occupation?: boolean
    contractType?: boolean
    contractDuration?: boolean
    employerName?: boolean
    employedSince?: boolean
  }

  export type EmploymentDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employmentId" | "createdAt" | "updatedAt" | "personalId" | "employmentType" | "occupation" | "contractType" | "contractDuration" | "employerName" | "employedSince", ExtArgs["result"]["employmentDetails"]>
  export type EmploymentDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type EmploymentDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type EmploymentDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $EmploymentDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmploymentDetails"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employmentId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      employmentType: $Enums.EmploymentType
      occupation: string
      contractType: string
      contractDuration: string
      employerName: string
      employedSince: Date
    }, ExtArgs["result"]["employmentDetails"]>
    composites: {}
  }

  type EmploymentDetailsGetPayload<S extends boolean | null | undefined | EmploymentDetailsDefaultArgs> = $Result.GetResult<Prisma.$EmploymentDetailsPayload, S>

  type EmploymentDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmploymentDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmploymentDetailsCountAggregateInputType | true
    }

  export interface EmploymentDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmploymentDetails'], meta: { name: 'EmploymentDetails' } }
    /**
     * Find zero or one EmploymentDetails that matches the filter.
     * @param {EmploymentDetailsFindUniqueArgs} args - Arguments to find a EmploymentDetails
     * @example
     * // Get one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmploymentDetailsFindUniqueArgs>(args: SelectSubset<T, EmploymentDetailsFindUniqueArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmploymentDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmploymentDetailsFindUniqueOrThrowArgs} args - Arguments to find a EmploymentDetails
     * @example
     * // Get one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmploymentDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmploymentDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmploymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsFindFirstArgs} args - Arguments to find a EmploymentDetails
     * @example
     * // Get one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmploymentDetailsFindFirstArgs>(args?: SelectSubset<T, EmploymentDetailsFindFirstArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmploymentDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsFindFirstOrThrowArgs} args - Arguments to find a EmploymentDetails
     * @example
     * // Get one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmploymentDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmploymentDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmploymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findMany()
     * 
     * // Get first 10 EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employmentDetailsWithIdOnly = await prisma.employmentDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmploymentDetailsFindManyArgs>(args?: SelectSubset<T, EmploymentDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmploymentDetails.
     * @param {EmploymentDetailsCreateArgs} args - Arguments to create a EmploymentDetails.
     * @example
     * // Create one EmploymentDetails
     * const EmploymentDetails = await prisma.employmentDetails.create({
     *   data: {
     *     // ... data to create a EmploymentDetails
     *   }
     * })
     * 
     */
    create<T extends EmploymentDetailsCreateArgs>(args: SelectSubset<T, EmploymentDetailsCreateArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmploymentDetails.
     * @param {EmploymentDetailsCreateManyArgs} args - Arguments to create many EmploymentDetails.
     * @example
     * // Create many EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmploymentDetailsCreateManyArgs>(args?: SelectSubset<T, EmploymentDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmploymentDetails and returns the data saved in the database.
     * @param {EmploymentDetailsCreateManyAndReturnArgs} args - Arguments to create many EmploymentDetails.
     * @example
     * // Create many EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmploymentDetails and only return the `id`
     * const employmentDetailsWithIdOnly = await prisma.employmentDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmploymentDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, EmploymentDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmploymentDetails.
     * @param {EmploymentDetailsDeleteArgs} args - Arguments to delete one EmploymentDetails.
     * @example
     * // Delete one EmploymentDetails
     * const EmploymentDetails = await prisma.employmentDetails.delete({
     *   where: {
     *     // ... filter to delete one EmploymentDetails
     *   }
     * })
     * 
     */
    delete<T extends EmploymentDetailsDeleteArgs>(args: SelectSubset<T, EmploymentDetailsDeleteArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmploymentDetails.
     * @param {EmploymentDetailsUpdateArgs} args - Arguments to update one EmploymentDetails.
     * @example
     * // Update one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmploymentDetailsUpdateArgs>(args: SelectSubset<T, EmploymentDetailsUpdateArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmploymentDetails.
     * @param {EmploymentDetailsDeleteManyArgs} args - Arguments to filter EmploymentDetails to delete.
     * @example
     * // Delete a few EmploymentDetails
     * const { count } = await prisma.employmentDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmploymentDetailsDeleteManyArgs>(args?: SelectSubset<T, EmploymentDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmploymentDetailsUpdateManyArgs>(args: SelectSubset<T, EmploymentDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploymentDetails and returns the data updated in the database.
     * @param {EmploymentDetailsUpdateManyAndReturnArgs} args - Arguments to update many EmploymentDetails.
     * @example
     * // Update many EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmploymentDetails and only return the `id`
     * const employmentDetailsWithIdOnly = await prisma.employmentDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmploymentDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, EmploymentDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmploymentDetails.
     * @param {EmploymentDetailsUpsertArgs} args - Arguments to update or create a EmploymentDetails.
     * @example
     * // Update or create a EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.upsert({
     *   create: {
     *     // ... data to create a EmploymentDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmploymentDetails we want to update
     *   }
     * })
     */
    upsert<T extends EmploymentDetailsUpsertArgs>(args: SelectSubset<T, EmploymentDetailsUpsertArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsCountArgs} args - Arguments to filter EmploymentDetails to count.
     * @example
     * // Count the number of EmploymentDetails
     * const count = await prisma.employmentDetails.count({
     *   where: {
     *     // ... the filter for the EmploymentDetails we want to count
     *   }
     * })
    **/
    count<T extends EmploymentDetailsCountArgs>(
      args?: Subset<T, EmploymentDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploymentDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploymentDetailsAggregateArgs>(args: Subset<T, EmploymentDetailsAggregateArgs>): Prisma.PrismaPromise<GetEmploymentDetailsAggregateType<T>>

    /**
     * Group by EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmploymentDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmploymentDetailsGroupByArgs['orderBy'] }
        : { orderBy?: EmploymentDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmploymentDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploymentDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmploymentDetails model
   */
  readonly fields: EmploymentDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmploymentDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmploymentDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmploymentDetails model
   */
  interface EmploymentDetailsFieldRefs {
    readonly id: FieldRef<"EmploymentDetails", 'String'>
    readonly employmentId: FieldRef<"EmploymentDetails", 'String'>
    readonly createdAt: FieldRef<"EmploymentDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"EmploymentDetails", 'DateTime'>
    readonly personalId: FieldRef<"EmploymentDetails", 'String'>
    readonly employmentType: FieldRef<"EmploymentDetails", 'EmploymentType'>
    readonly occupation: FieldRef<"EmploymentDetails", 'String'>
    readonly contractType: FieldRef<"EmploymentDetails", 'String'>
    readonly contractDuration: FieldRef<"EmploymentDetails", 'String'>
    readonly employerName: FieldRef<"EmploymentDetails", 'String'>
    readonly employedSince: FieldRef<"EmploymentDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmploymentDetails findUnique
   */
  export type EmploymentDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where: EmploymentDetailsWhereUniqueInput
  }

  /**
   * EmploymentDetails findUniqueOrThrow
   */
  export type EmploymentDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where: EmploymentDetailsWhereUniqueInput
  }

  /**
   * EmploymentDetails findFirst
   */
  export type EmploymentDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where?: EmploymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentDetails.
     */
    cursor?: EmploymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentDetails.
     */
    distinct?: EmploymentDetailsScalarFieldEnum | EmploymentDetailsScalarFieldEnum[]
  }

  /**
   * EmploymentDetails findFirstOrThrow
   */
  export type EmploymentDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where?: EmploymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentDetails.
     */
    cursor?: EmploymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentDetails.
     */
    distinct?: EmploymentDetailsScalarFieldEnum | EmploymentDetailsScalarFieldEnum[]
  }

  /**
   * EmploymentDetails findMany
   */
  export type EmploymentDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where?: EmploymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmploymentDetails.
     */
    cursor?: EmploymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    distinct?: EmploymentDetailsScalarFieldEnum | EmploymentDetailsScalarFieldEnum[]
  }

  /**
   * EmploymentDetails create
   */
  export type EmploymentDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmploymentDetails.
     */
    data: XOR<EmploymentDetailsCreateInput, EmploymentDetailsUncheckedCreateInput>
  }

  /**
   * EmploymentDetails createMany
   */
  export type EmploymentDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmploymentDetails.
     */
    data: EmploymentDetailsCreateManyInput | EmploymentDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmploymentDetails createManyAndReturn
   */
  export type EmploymentDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many EmploymentDetails.
     */
    data: EmploymentDetailsCreateManyInput | EmploymentDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmploymentDetails update
   */
  export type EmploymentDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmploymentDetails.
     */
    data: XOR<EmploymentDetailsUpdateInput, EmploymentDetailsUncheckedUpdateInput>
    /**
     * Choose, which EmploymentDetails to update.
     */
    where: EmploymentDetailsWhereUniqueInput
  }

  /**
   * EmploymentDetails updateMany
   */
  export type EmploymentDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmploymentDetails.
     */
    data: XOR<EmploymentDetailsUpdateManyMutationInput, EmploymentDetailsUncheckedUpdateManyInput>
    /**
     * Filter which EmploymentDetails to update
     */
    where?: EmploymentDetailsWhereInput
    /**
     * Limit how many EmploymentDetails to update.
     */
    limit?: number
  }

  /**
   * EmploymentDetails updateManyAndReturn
   */
  export type EmploymentDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * The data used to update EmploymentDetails.
     */
    data: XOR<EmploymentDetailsUpdateManyMutationInput, EmploymentDetailsUncheckedUpdateManyInput>
    /**
     * Filter which EmploymentDetails to update
     */
    where?: EmploymentDetailsWhereInput
    /**
     * Limit how many EmploymentDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmploymentDetails upsert
   */
  export type EmploymentDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmploymentDetails to update in case it exists.
     */
    where: EmploymentDetailsWhereUniqueInput
    /**
     * In case the EmploymentDetails found by the `where` argument doesn't exist, create a new EmploymentDetails with this data.
     */
    create: XOR<EmploymentDetailsCreateInput, EmploymentDetailsUncheckedCreateInput>
    /**
     * In case the EmploymentDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmploymentDetailsUpdateInput, EmploymentDetailsUncheckedUpdateInput>
  }

  /**
   * EmploymentDetails delete
   */
  export type EmploymentDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter which EmploymentDetails to delete.
     */
    where: EmploymentDetailsWhereUniqueInput
  }

  /**
   * EmploymentDetails deleteMany
   */
  export type EmploymentDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentDetails to delete
     */
    where?: EmploymentDetailsWhereInput
    /**
     * Limit how many EmploymentDetails to delete.
     */
    limit?: number
  }

  /**
   * EmploymentDetails without action
   */
  export type EmploymentDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentDetails
     */
    omit?: EmploymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
  }


  /**
   * Model IncomeDetails
   */

  export type AggregateIncomeDetails = {
    _count: IncomeDetailsCountAggregateOutputType | null
    _avg: IncomeDetailsAvgAggregateOutputType | null
    _sum: IncomeDetailsSumAggregateOutputType | null
    _min: IncomeDetailsMinAggregateOutputType | null
    _max: IncomeDetailsMaxAggregateOutputType | null
  }

  export type IncomeDetailsAvgAggregateOutputType = {
    grossIncome: Decimal | null
    netIncome: Decimal | null
    numberOfSalaries: number | null
    childBenefit: Decimal | null
    otherIncome: Decimal | null
    incomeTradeBusiness: Decimal | null
    incomeSelfEmployedWork: Decimal | null
    incomeSideJob: Decimal | null
  }

  export type IncomeDetailsSumAggregateOutputType = {
    grossIncome: Decimal | null
    netIncome: Decimal | null
    numberOfSalaries: number | null
    childBenefit: Decimal | null
    otherIncome: Decimal | null
    incomeTradeBusiness: Decimal | null
    incomeSelfEmployedWork: Decimal | null
    incomeSideJob: Decimal | null
  }

  export type IncomeDetailsMinAggregateOutputType = {
    id: string | null
    incomeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    grossIncome: Decimal | null
    netIncome: Decimal | null
    taxClass: string | null
    taxId: string | null
    numberOfSalaries: number | null
    childBenefit: Decimal | null
    otherIncome: Decimal | null
    incomeTradeBusiness: Decimal | null
    incomeSelfEmployedWork: Decimal | null
    incomeSideJob: Decimal | null
  }

  export type IncomeDetailsMaxAggregateOutputType = {
    id: string | null
    incomeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    grossIncome: Decimal | null
    netIncome: Decimal | null
    taxClass: string | null
    taxId: string | null
    numberOfSalaries: number | null
    childBenefit: Decimal | null
    otherIncome: Decimal | null
    incomeTradeBusiness: Decimal | null
    incomeSelfEmployedWork: Decimal | null
    incomeSideJob: Decimal | null
  }

  export type IncomeDetailsCountAggregateOutputType = {
    id: number
    incomeId: number
    createdAt: number
    updatedAt: number
    personalId: number
    grossIncome: number
    netIncome: number
    taxClass: number
    taxId: number
    numberOfSalaries: number
    childBenefit: number
    otherIncome: number
    incomeTradeBusiness: number
    incomeSelfEmployedWork: number
    incomeSideJob: number
    _all: number
  }


  export type IncomeDetailsAvgAggregateInputType = {
    grossIncome?: true
    netIncome?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
    incomeTradeBusiness?: true
    incomeSelfEmployedWork?: true
    incomeSideJob?: true
  }

  export type IncomeDetailsSumAggregateInputType = {
    grossIncome?: true
    netIncome?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
    incomeTradeBusiness?: true
    incomeSelfEmployedWork?: true
    incomeSideJob?: true
  }

  export type IncomeDetailsMinAggregateInputType = {
    id?: true
    incomeId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    grossIncome?: true
    netIncome?: true
    taxClass?: true
    taxId?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
    incomeTradeBusiness?: true
    incomeSelfEmployedWork?: true
    incomeSideJob?: true
  }

  export type IncomeDetailsMaxAggregateInputType = {
    id?: true
    incomeId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    grossIncome?: true
    netIncome?: true
    taxClass?: true
    taxId?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
    incomeTradeBusiness?: true
    incomeSelfEmployedWork?: true
    incomeSideJob?: true
  }

  export type IncomeDetailsCountAggregateInputType = {
    id?: true
    incomeId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    grossIncome?: true
    netIncome?: true
    taxClass?: true
    taxId?: true
    numberOfSalaries?: true
    childBenefit?: true
    otherIncome?: true
    incomeTradeBusiness?: true
    incomeSelfEmployedWork?: true
    incomeSideJob?: true
    _all?: true
  }

  export type IncomeDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeDetails to aggregate.
     */
    where?: IncomeDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeDetails to fetch.
     */
    orderBy?: IncomeDetailsOrderByWithRelationInput | IncomeDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomeDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomeDetails
    **/
    _count?: true | IncomeDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomeDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomeDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeDetailsMaxAggregateInputType
  }

  export type GetIncomeDetailsAggregateType<T extends IncomeDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomeDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomeDetails[P]>
      : GetScalarType<T[P], AggregateIncomeDetails[P]>
  }




  export type IncomeDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeDetailsWhereInput
    orderBy?: IncomeDetailsOrderByWithAggregationInput | IncomeDetailsOrderByWithAggregationInput[]
    by: IncomeDetailsScalarFieldEnum[] | IncomeDetailsScalarFieldEnum
    having?: IncomeDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeDetailsCountAggregateInputType | true
    _avg?: IncomeDetailsAvgAggregateInputType
    _sum?: IncomeDetailsSumAggregateInputType
    _min?: IncomeDetailsMinAggregateInputType
    _max?: IncomeDetailsMaxAggregateInputType
  }

  export type IncomeDetailsGroupByOutputType = {
    id: string
    incomeId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    grossIncome: Decimal
    netIncome: Decimal
    taxClass: string
    taxId: string
    numberOfSalaries: number
    childBenefit: Decimal
    otherIncome: Decimal
    incomeTradeBusiness: Decimal
    incomeSelfEmployedWork: Decimal
    incomeSideJob: Decimal
    _count: IncomeDetailsCountAggregateOutputType | null
    _avg: IncomeDetailsAvgAggregateOutputType | null
    _sum: IncomeDetailsSumAggregateOutputType | null
    _min: IncomeDetailsMinAggregateOutputType | null
    _max: IncomeDetailsMaxAggregateOutputType | null
  }

  type GetIncomeDetailsGroupByPayload<T extends IncomeDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomeDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomeDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomeDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], IncomeDetailsGroupByOutputType[P]>
        }
      >
    >


  export type IncomeDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incomeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    grossIncome?: boolean
    netIncome?: boolean
    taxClass?: boolean
    taxId?: boolean
    numberOfSalaries?: boolean
    childBenefit?: boolean
    otherIncome?: boolean
    incomeTradeBusiness?: boolean
    incomeSelfEmployedWork?: boolean
    incomeSideJob?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomeDetails"]>

  export type IncomeDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incomeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    grossIncome?: boolean
    netIncome?: boolean
    taxClass?: boolean
    taxId?: boolean
    numberOfSalaries?: boolean
    childBenefit?: boolean
    otherIncome?: boolean
    incomeTradeBusiness?: boolean
    incomeSelfEmployedWork?: boolean
    incomeSideJob?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomeDetails"]>

  export type IncomeDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incomeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    grossIncome?: boolean
    netIncome?: boolean
    taxClass?: boolean
    taxId?: boolean
    numberOfSalaries?: boolean
    childBenefit?: boolean
    otherIncome?: boolean
    incomeTradeBusiness?: boolean
    incomeSelfEmployedWork?: boolean
    incomeSideJob?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomeDetails"]>

  export type IncomeDetailsSelectScalar = {
    id?: boolean
    incomeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    grossIncome?: boolean
    netIncome?: boolean
    taxClass?: boolean
    taxId?: boolean
    numberOfSalaries?: boolean
    childBenefit?: boolean
    otherIncome?: boolean
    incomeTradeBusiness?: boolean
    incomeSelfEmployedWork?: boolean
    incomeSideJob?: boolean
  }

  export type IncomeDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "incomeId" | "createdAt" | "updatedAt" | "personalId" | "grossIncome" | "netIncome" | "taxClass" | "taxId" | "numberOfSalaries" | "childBenefit" | "otherIncome" | "incomeTradeBusiness" | "incomeSelfEmployedWork" | "incomeSideJob", ExtArgs["result"]["incomeDetails"]>
  export type IncomeDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type IncomeDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type IncomeDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $IncomeDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncomeDetails"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incomeId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      grossIncome: Prisma.Decimal
      netIncome: Prisma.Decimal
      taxClass: string
      taxId: string
      numberOfSalaries: number
      childBenefit: Prisma.Decimal
      otherIncome: Prisma.Decimal
      incomeTradeBusiness: Prisma.Decimal
      incomeSelfEmployedWork: Prisma.Decimal
      incomeSideJob: Prisma.Decimal
    }, ExtArgs["result"]["incomeDetails"]>
    composites: {}
  }

  type IncomeDetailsGetPayload<S extends boolean | null | undefined | IncomeDetailsDefaultArgs> = $Result.GetResult<Prisma.$IncomeDetailsPayload, S>

  type IncomeDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncomeDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncomeDetailsCountAggregateInputType | true
    }

  export interface IncomeDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncomeDetails'], meta: { name: 'IncomeDetails' } }
    /**
     * Find zero or one IncomeDetails that matches the filter.
     * @param {IncomeDetailsFindUniqueArgs} args - Arguments to find a IncomeDetails
     * @example
     * // Get one IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomeDetailsFindUniqueArgs>(args: SelectSubset<T, IncomeDetailsFindUniqueArgs<ExtArgs>>): Prisma__IncomeDetailsClient<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IncomeDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncomeDetailsFindUniqueOrThrowArgs} args - Arguments to find a IncomeDetails
     * @example
     * // Get one IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomeDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomeDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomeDetailsClient<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncomeDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeDetailsFindFirstArgs} args - Arguments to find a IncomeDetails
     * @example
     * // Get one IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomeDetailsFindFirstArgs>(args?: SelectSubset<T, IncomeDetailsFindFirstArgs<ExtArgs>>): Prisma__IncomeDetailsClient<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncomeDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeDetailsFindFirstOrThrowArgs} args - Arguments to find a IncomeDetails
     * @example
     * // Get one IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomeDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomeDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomeDetailsClient<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IncomeDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.findMany()
     * 
     * // Get first 10 IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeDetailsWithIdOnly = await prisma.incomeDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomeDetailsFindManyArgs>(args?: SelectSubset<T, IncomeDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IncomeDetails.
     * @param {IncomeDetailsCreateArgs} args - Arguments to create a IncomeDetails.
     * @example
     * // Create one IncomeDetails
     * const IncomeDetails = await prisma.incomeDetails.create({
     *   data: {
     *     // ... data to create a IncomeDetails
     *   }
     * })
     * 
     */
    create<T extends IncomeDetailsCreateArgs>(args: SelectSubset<T, IncomeDetailsCreateArgs<ExtArgs>>): Prisma__IncomeDetailsClient<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IncomeDetails.
     * @param {IncomeDetailsCreateManyArgs} args - Arguments to create many IncomeDetails.
     * @example
     * // Create many IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomeDetailsCreateManyArgs>(args?: SelectSubset<T, IncomeDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncomeDetails and returns the data saved in the database.
     * @param {IncomeDetailsCreateManyAndReturnArgs} args - Arguments to create many IncomeDetails.
     * @example
     * // Create many IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncomeDetails and only return the `id`
     * const incomeDetailsWithIdOnly = await prisma.incomeDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncomeDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, IncomeDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IncomeDetails.
     * @param {IncomeDetailsDeleteArgs} args - Arguments to delete one IncomeDetails.
     * @example
     * // Delete one IncomeDetails
     * const IncomeDetails = await prisma.incomeDetails.delete({
     *   where: {
     *     // ... filter to delete one IncomeDetails
     *   }
     * })
     * 
     */
    delete<T extends IncomeDetailsDeleteArgs>(args: SelectSubset<T, IncomeDetailsDeleteArgs<ExtArgs>>): Prisma__IncomeDetailsClient<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IncomeDetails.
     * @param {IncomeDetailsUpdateArgs} args - Arguments to update one IncomeDetails.
     * @example
     * // Update one IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomeDetailsUpdateArgs>(args: SelectSubset<T, IncomeDetailsUpdateArgs<ExtArgs>>): Prisma__IncomeDetailsClient<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IncomeDetails.
     * @param {IncomeDetailsDeleteManyArgs} args - Arguments to filter IncomeDetails to delete.
     * @example
     * // Delete a few IncomeDetails
     * const { count } = await prisma.incomeDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomeDetailsDeleteManyArgs>(args?: SelectSubset<T, IncomeDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomeDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomeDetailsUpdateManyArgs>(args: SelectSubset<T, IncomeDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomeDetails and returns the data updated in the database.
     * @param {IncomeDetailsUpdateManyAndReturnArgs} args - Arguments to update many IncomeDetails.
     * @example
     * // Update many IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IncomeDetails and only return the `id`
     * const incomeDetailsWithIdOnly = await prisma.incomeDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncomeDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, IncomeDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IncomeDetails.
     * @param {IncomeDetailsUpsertArgs} args - Arguments to update or create a IncomeDetails.
     * @example
     * // Update or create a IncomeDetails
     * const incomeDetails = await prisma.incomeDetails.upsert({
     *   create: {
     *     // ... data to create a IncomeDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomeDetails we want to update
     *   }
     * })
     */
    upsert<T extends IncomeDetailsUpsertArgs>(args: SelectSubset<T, IncomeDetailsUpsertArgs<ExtArgs>>): Prisma__IncomeDetailsClient<$Result.GetResult<Prisma.$IncomeDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IncomeDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeDetailsCountArgs} args - Arguments to filter IncomeDetails to count.
     * @example
     * // Count the number of IncomeDetails
     * const count = await prisma.incomeDetails.count({
     *   where: {
     *     // ... the filter for the IncomeDetails we want to count
     *   }
     * })
    **/
    count<T extends IncomeDetailsCountArgs>(
      args?: Subset<T, IncomeDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomeDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeDetailsAggregateArgs>(args: Subset<T, IncomeDetailsAggregateArgs>): Prisma.PrismaPromise<GetIncomeDetailsAggregateType<T>>

    /**
     * Group by IncomeDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeDetailsGroupByArgs['orderBy'] }
        : { orderBy?: IncomeDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncomeDetails model
   */
  readonly fields: IncomeDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomeDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomeDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncomeDetails model
   */
  interface IncomeDetailsFieldRefs {
    readonly id: FieldRef<"IncomeDetails", 'String'>
    readonly incomeId: FieldRef<"IncomeDetails", 'String'>
    readonly createdAt: FieldRef<"IncomeDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"IncomeDetails", 'DateTime'>
    readonly personalId: FieldRef<"IncomeDetails", 'String'>
    readonly grossIncome: FieldRef<"IncomeDetails", 'Decimal'>
    readonly netIncome: FieldRef<"IncomeDetails", 'Decimal'>
    readonly taxClass: FieldRef<"IncomeDetails", 'String'>
    readonly taxId: FieldRef<"IncomeDetails", 'String'>
    readonly numberOfSalaries: FieldRef<"IncomeDetails", 'Int'>
    readonly childBenefit: FieldRef<"IncomeDetails", 'Decimal'>
    readonly otherIncome: FieldRef<"IncomeDetails", 'Decimal'>
    readonly incomeTradeBusiness: FieldRef<"IncomeDetails", 'Decimal'>
    readonly incomeSelfEmployedWork: FieldRef<"IncomeDetails", 'Decimal'>
    readonly incomeSideJob: FieldRef<"IncomeDetails", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * IncomeDetails findUnique
   */
  export type IncomeDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeDetails to fetch.
     */
    where: IncomeDetailsWhereUniqueInput
  }

  /**
   * IncomeDetails findUniqueOrThrow
   */
  export type IncomeDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeDetails to fetch.
     */
    where: IncomeDetailsWhereUniqueInput
  }

  /**
   * IncomeDetails findFirst
   */
  export type IncomeDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeDetails to fetch.
     */
    where?: IncomeDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeDetails to fetch.
     */
    orderBy?: IncomeDetailsOrderByWithRelationInput | IncomeDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeDetails.
     */
    cursor?: IncomeDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeDetails.
     */
    distinct?: IncomeDetailsScalarFieldEnum | IncomeDetailsScalarFieldEnum[]
  }

  /**
   * IncomeDetails findFirstOrThrow
   */
  export type IncomeDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeDetails to fetch.
     */
    where?: IncomeDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeDetails to fetch.
     */
    orderBy?: IncomeDetailsOrderByWithRelationInput | IncomeDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeDetails.
     */
    cursor?: IncomeDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeDetails.
     */
    distinct?: IncomeDetailsScalarFieldEnum | IncomeDetailsScalarFieldEnum[]
  }

  /**
   * IncomeDetails findMany
   */
  export type IncomeDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeDetails to fetch.
     */
    where?: IncomeDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeDetails to fetch.
     */
    orderBy?: IncomeDetailsOrderByWithRelationInput | IncomeDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomeDetails.
     */
    cursor?: IncomeDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeDetails.
     */
    skip?: number
    distinct?: IncomeDetailsScalarFieldEnum | IncomeDetailsScalarFieldEnum[]
  }

  /**
   * IncomeDetails create
   */
  export type IncomeDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a IncomeDetails.
     */
    data: XOR<IncomeDetailsCreateInput, IncomeDetailsUncheckedCreateInput>
  }

  /**
   * IncomeDetails createMany
   */
  export type IncomeDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncomeDetails.
     */
    data: IncomeDetailsCreateManyInput | IncomeDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncomeDetails createManyAndReturn
   */
  export type IncomeDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many IncomeDetails.
     */
    data: IncomeDetailsCreateManyInput | IncomeDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncomeDetails update
   */
  export type IncomeDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a IncomeDetails.
     */
    data: XOR<IncomeDetailsUpdateInput, IncomeDetailsUncheckedUpdateInput>
    /**
     * Choose, which IncomeDetails to update.
     */
    where: IncomeDetailsWhereUniqueInput
  }

  /**
   * IncomeDetails updateMany
   */
  export type IncomeDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncomeDetails.
     */
    data: XOR<IncomeDetailsUpdateManyMutationInput, IncomeDetailsUncheckedUpdateManyInput>
    /**
     * Filter which IncomeDetails to update
     */
    where?: IncomeDetailsWhereInput
    /**
     * Limit how many IncomeDetails to update.
     */
    limit?: number
  }

  /**
   * IncomeDetails updateManyAndReturn
   */
  export type IncomeDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * The data used to update IncomeDetails.
     */
    data: XOR<IncomeDetailsUpdateManyMutationInput, IncomeDetailsUncheckedUpdateManyInput>
    /**
     * Filter which IncomeDetails to update
     */
    where?: IncomeDetailsWhereInput
    /**
     * Limit how many IncomeDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncomeDetails upsert
   */
  export type IncomeDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the IncomeDetails to update in case it exists.
     */
    where: IncomeDetailsWhereUniqueInput
    /**
     * In case the IncomeDetails found by the `where` argument doesn't exist, create a new IncomeDetails with this data.
     */
    create: XOR<IncomeDetailsCreateInput, IncomeDetailsUncheckedCreateInput>
    /**
     * In case the IncomeDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomeDetailsUpdateInput, IncomeDetailsUncheckedUpdateInput>
  }

  /**
   * IncomeDetails delete
   */
  export type IncomeDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
    /**
     * Filter which IncomeDetails to delete.
     */
    where: IncomeDetailsWhereUniqueInput
  }

  /**
   * IncomeDetails deleteMany
   */
  export type IncomeDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeDetails to delete
     */
    where?: IncomeDetailsWhereInput
    /**
     * Limit how many IncomeDetails to delete.
     */
    limit?: number
  }

  /**
   * IncomeDetails without action
   */
  export type IncomeDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeDetails
     */
    select?: IncomeDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeDetails
     */
    omit?: IncomeDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeDetailsInclude<ExtArgs> | null
  }


  /**
   * Model ExpensesDetails
   */

  export type AggregateExpensesDetails = {
    _count: ExpensesDetailsCountAggregateOutputType | null
    _avg: ExpensesDetailsAvgAggregateOutputType | null
    _sum: ExpensesDetailsSumAggregateOutputType | null
    _min: ExpensesDetailsMinAggregateOutputType | null
    _max: ExpensesDetailsMaxAggregateOutputType | null
  }

  export type ExpensesDetailsAvgAggregateOutputType = {
    coldRent: Decimal | null
    electricity: Decimal | null
    livingExpenses: Decimal | null
    gas: Decimal | null
    telecommunication: Decimal | null
    accountMaintenanceFee: Decimal | null
    alimony: Decimal | null
    subscriptions: Decimal | null
    otherExpenses: Decimal | null
  }

  export type ExpensesDetailsSumAggregateOutputType = {
    coldRent: Decimal | null
    electricity: Decimal | null
    livingExpenses: Decimal | null
    gas: Decimal | null
    telecommunication: Decimal | null
    accountMaintenanceFee: Decimal | null
    alimony: Decimal | null
    subscriptions: Decimal | null
    otherExpenses: Decimal | null
  }

  export type ExpensesDetailsMinAggregateOutputType = {
    id: string | null
    expensesId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    coldRent: Decimal | null
    electricity: Decimal | null
    livingExpenses: Decimal | null
    gas: Decimal | null
    telecommunication: Decimal | null
    accountMaintenanceFee: Decimal | null
    alimony: Decimal | null
    subscriptions: Decimal | null
    otherExpenses: Decimal | null
  }

  export type ExpensesDetailsMaxAggregateOutputType = {
    id: string | null
    expensesId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    coldRent: Decimal | null
    electricity: Decimal | null
    livingExpenses: Decimal | null
    gas: Decimal | null
    telecommunication: Decimal | null
    accountMaintenanceFee: Decimal | null
    alimony: Decimal | null
    subscriptions: Decimal | null
    otherExpenses: Decimal | null
  }

  export type ExpensesDetailsCountAggregateOutputType = {
    id: number
    expensesId: number
    createdAt: number
    updatedAt: number
    personalId: number
    coldRent: number
    electricity: number
    livingExpenses: number
    gas: number
    telecommunication: number
    accountMaintenanceFee: number
    alimony: number
    subscriptions: number
    otherExpenses: number
    _all: number
  }


  export type ExpensesDetailsAvgAggregateInputType = {
    coldRent?: true
    electricity?: true
    livingExpenses?: true
    gas?: true
    telecommunication?: true
    accountMaintenanceFee?: true
    alimony?: true
    subscriptions?: true
    otherExpenses?: true
  }

  export type ExpensesDetailsSumAggregateInputType = {
    coldRent?: true
    electricity?: true
    livingExpenses?: true
    gas?: true
    telecommunication?: true
    accountMaintenanceFee?: true
    alimony?: true
    subscriptions?: true
    otherExpenses?: true
  }

  export type ExpensesDetailsMinAggregateInputType = {
    id?: true
    expensesId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    coldRent?: true
    electricity?: true
    livingExpenses?: true
    gas?: true
    telecommunication?: true
    accountMaintenanceFee?: true
    alimony?: true
    subscriptions?: true
    otherExpenses?: true
  }

  export type ExpensesDetailsMaxAggregateInputType = {
    id?: true
    expensesId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    coldRent?: true
    electricity?: true
    livingExpenses?: true
    gas?: true
    telecommunication?: true
    accountMaintenanceFee?: true
    alimony?: true
    subscriptions?: true
    otherExpenses?: true
  }

  export type ExpensesDetailsCountAggregateInputType = {
    id?: true
    expensesId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    coldRent?: true
    electricity?: true
    livingExpenses?: true
    gas?: true
    telecommunication?: true
    accountMaintenanceFee?: true
    alimony?: true
    subscriptions?: true
    otherExpenses?: true
    _all?: true
  }

  export type ExpensesDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpensesDetails to aggregate.
     */
    where?: ExpensesDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpensesDetails to fetch.
     */
    orderBy?: ExpensesDetailsOrderByWithRelationInput | ExpensesDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpensesDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpensesDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpensesDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpensesDetails
    **/
    _count?: true | ExpensesDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpensesDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpensesDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpensesDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpensesDetailsMaxAggregateInputType
  }

  export type GetExpensesDetailsAggregateType<T extends ExpensesDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateExpensesDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpensesDetails[P]>
      : GetScalarType<T[P], AggregateExpensesDetails[P]>
  }




  export type ExpensesDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpensesDetailsWhereInput
    orderBy?: ExpensesDetailsOrderByWithAggregationInput | ExpensesDetailsOrderByWithAggregationInput[]
    by: ExpensesDetailsScalarFieldEnum[] | ExpensesDetailsScalarFieldEnum
    having?: ExpensesDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpensesDetailsCountAggregateInputType | true
    _avg?: ExpensesDetailsAvgAggregateInputType
    _sum?: ExpensesDetailsSumAggregateInputType
    _min?: ExpensesDetailsMinAggregateInputType
    _max?: ExpensesDetailsMaxAggregateInputType
  }

  export type ExpensesDetailsGroupByOutputType = {
    id: string
    expensesId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    coldRent: Decimal
    electricity: Decimal
    livingExpenses: Decimal
    gas: Decimal
    telecommunication: Decimal
    accountMaintenanceFee: Decimal
    alimony: Decimal
    subscriptions: Decimal
    otherExpenses: Decimal
    _count: ExpensesDetailsCountAggregateOutputType | null
    _avg: ExpensesDetailsAvgAggregateOutputType | null
    _sum: ExpensesDetailsSumAggregateOutputType | null
    _min: ExpensesDetailsMinAggregateOutputType | null
    _max: ExpensesDetailsMaxAggregateOutputType | null
  }

  type GetExpensesDetailsGroupByPayload<T extends ExpensesDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpensesDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpensesDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpensesDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], ExpensesDetailsGroupByOutputType[P]>
        }
      >
    >


  export type ExpensesDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expensesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    coldRent?: boolean
    electricity?: boolean
    livingExpenses?: boolean
    gas?: boolean
    telecommunication?: boolean
    accountMaintenanceFee?: boolean
    alimony?: boolean
    subscriptions?: boolean
    otherExpenses?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expensesDetails"]>

  export type ExpensesDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expensesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    coldRent?: boolean
    electricity?: boolean
    livingExpenses?: boolean
    gas?: boolean
    telecommunication?: boolean
    accountMaintenanceFee?: boolean
    alimony?: boolean
    subscriptions?: boolean
    otherExpenses?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expensesDetails"]>

  export type ExpensesDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expensesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    coldRent?: boolean
    electricity?: boolean
    livingExpenses?: boolean
    gas?: boolean
    telecommunication?: boolean
    accountMaintenanceFee?: boolean
    alimony?: boolean
    subscriptions?: boolean
    otherExpenses?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expensesDetails"]>

  export type ExpensesDetailsSelectScalar = {
    id?: boolean
    expensesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    coldRent?: boolean
    electricity?: boolean
    livingExpenses?: boolean
    gas?: boolean
    telecommunication?: boolean
    accountMaintenanceFee?: boolean
    alimony?: boolean
    subscriptions?: boolean
    otherExpenses?: boolean
  }

  export type ExpensesDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expensesId" | "createdAt" | "updatedAt" | "personalId" | "coldRent" | "electricity" | "livingExpenses" | "gas" | "telecommunication" | "accountMaintenanceFee" | "alimony" | "subscriptions" | "otherExpenses", ExtArgs["result"]["expensesDetails"]>
  export type ExpensesDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type ExpensesDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type ExpensesDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $ExpensesDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpensesDetails"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expensesId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      coldRent: Prisma.Decimal
      electricity: Prisma.Decimal
      livingExpenses: Prisma.Decimal
      gas: Prisma.Decimal
      telecommunication: Prisma.Decimal
      accountMaintenanceFee: Prisma.Decimal
      alimony: Prisma.Decimal
      subscriptions: Prisma.Decimal
      otherExpenses: Prisma.Decimal
    }, ExtArgs["result"]["expensesDetails"]>
    composites: {}
  }

  type ExpensesDetailsGetPayload<S extends boolean | null | undefined | ExpensesDetailsDefaultArgs> = $Result.GetResult<Prisma.$ExpensesDetailsPayload, S>

  type ExpensesDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpensesDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpensesDetailsCountAggregateInputType | true
    }

  export interface ExpensesDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpensesDetails'], meta: { name: 'ExpensesDetails' } }
    /**
     * Find zero or one ExpensesDetails that matches the filter.
     * @param {ExpensesDetailsFindUniqueArgs} args - Arguments to find a ExpensesDetails
     * @example
     * // Get one ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpensesDetailsFindUniqueArgs>(args: SelectSubset<T, ExpensesDetailsFindUniqueArgs<ExtArgs>>): Prisma__ExpensesDetailsClient<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpensesDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpensesDetailsFindUniqueOrThrowArgs} args - Arguments to find a ExpensesDetails
     * @example
     * // Get one ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpensesDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpensesDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpensesDetailsClient<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpensesDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesDetailsFindFirstArgs} args - Arguments to find a ExpensesDetails
     * @example
     * // Get one ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpensesDetailsFindFirstArgs>(args?: SelectSubset<T, ExpensesDetailsFindFirstArgs<ExtArgs>>): Prisma__ExpensesDetailsClient<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpensesDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesDetailsFindFirstOrThrowArgs} args - Arguments to find a ExpensesDetails
     * @example
     * // Get one ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpensesDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpensesDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpensesDetailsClient<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpensesDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.findMany()
     * 
     * // Get first 10 ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expensesDetailsWithIdOnly = await prisma.expensesDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpensesDetailsFindManyArgs>(args?: SelectSubset<T, ExpensesDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpensesDetails.
     * @param {ExpensesDetailsCreateArgs} args - Arguments to create a ExpensesDetails.
     * @example
     * // Create one ExpensesDetails
     * const ExpensesDetails = await prisma.expensesDetails.create({
     *   data: {
     *     // ... data to create a ExpensesDetails
     *   }
     * })
     * 
     */
    create<T extends ExpensesDetailsCreateArgs>(args: SelectSubset<T, ExpensesDetailsCreateArgs<ExtArgs>>): Prisma__ExpensesDetailsClient<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpensesDetails.
     * @param {ExpensesDetailsCreateManyArgs} args - Arguments to create many ExpensesDetails.
     * @example
     * // Create many ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpensesDetailsCreateManyArgs>(args?: SelectSubset<T, ExpensesDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpensesDetails and returns the data saved in the database.
     * @param {ExpensesDetailsCreateManyAndReturnArgs} args - Arguments to create many ExpensesDetails.
     * @example
     * // Create many ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpensesDetails and only return the `id`
     * const expensesDetailsWithIdOnly = await prisma.expensesDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpensesDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpensesDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpensesDetails.
     * @param {ExpensesDetailsDeleteArgs} args - Arguments to delete one ExpensesDetails.
     * @example
     * // Delete one ExpensesDetails
     * const ExpensesDetails = await prisma.expensesDetails.delete({
     *   where: {
     *     // ... filter to delete one ExpensesDetails
     *   }
     * })
     * 
     */
    delete<T extends ExpensesDetailsDeleteArgs>(args: SelectSubset<T, ExpensesDetailsDeleteArgs<ExtArgs>>): Prisma__ExpensesDetailsClient<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpensesDetails.
     * @param {ExpensesDetailsUpdateArgs} args - Arguments to update one ExpensesDetails.
     * @example
     * // Update one ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpensesDetailsUpdateArgs>(args: SelectSubset<T, ExpensesDetailsUpdateArgs<ExtArgs>>): Prisma__ExpensesDetailsClient<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpensesDetails.
     * @param {ExpensesDetailsDeleteManyArgs} args - Arguments to filter ExpensesDetails to delete.
     * @example
     * // Delete a few ExpensesDetails
     * const { count } = await prisma.expensesDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpensesDetailsDeleteManyArgs>(args?: SelectSubset<T, ExpensesDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpensesDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpensesDetailsUpdateManyArgs>(args: SelectSubset<T, ExpensesDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpensesDetails and returns the data updated in the database.
     * @param {ExpensesDetailsUpdateManyAndReturnArgs} args - Arguments to update many ExpensesDetails.
     * @example
     * // Update many ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpensesDetails and only return the `id`
     * const expensesDetailsWithIdOnly = await prisma.expensesDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpensesDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpensesDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpensesDetails.
     * @param {ExpensesDetailsUpsertArgs} args - Arguments to update or create a ExpensesDetails.
     * @example
     * // Update or create a ExpensesDetails
     * const expensesDetails = await prisma.expensesDetails.upsert({
     *   create: {
     *     // ... data to create a ExpensesDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpensesDetails we want to update
     *   }
     * })
     */
    upsert<T extends ExpensesDetailsUpsertArgs>(args: SelectSubset<T, ExpensesDetailsUpsertArgs<ExtArgs>>): Prisma__ExpensesDetailsClient<$Result.GetResult<Prisma.$ExpensesDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpensesDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesDetailsCountArgs} args - Arguments to filter ExpensesDetails to count.
     * @example
     * // Count the number of ExpensesDetails
     * const count = await prisma.expensesDetails.count({
     *   where: {
     *     // ... the filter for the ExpensesDetails we want to count
     *   }
     * })
    **/
    count<T extends ExpensesDetailsCountArgs>(
      args?: Subset<T, ExpensesDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpensesDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpensesDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpensesDetailsAggregateArgs>(args: Subset<T, ExpensesDetailsAggregateArgs>): Prisma.PrismaPromise<GetExpensesDetailsAggregateType<T>>

    /**
     * Group by ExpensesDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpensesDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpensesDetailsGroupByArgs['orderBy'] }
        : { orderBy?: ExpensesDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpensesDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpensesDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpensesDetails model
   */
  readonly fields: ExpensesDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpensesDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpensesDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpensesDetails model
   */
  interface ExpensesDetailsFieldRefs {
    readonly id: FieldRef<"ExpensesDetails", 'String'>
    readonly expensesId: FieldRef<"ExpensesDetails", 'String'>
    readonly createdAt: FieldRef<"ExpensesDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpensesDetails", 'DateTime'>
    readonly personalId: FieldRef<"ExpensesDetails", 'String'>
    readonly coldRent: FieldRef<"ExpensesDetails", 'Decimal'>
    readonly electricity: FieldRef<"ExpensesDetails", 'Decimal'>
    readonly livingExpenses: FieldRef<"ExpensesDetails", 'Decimal'>
    readonly gas: FieldRef<"ExpensesDetails", 'Decimal'>
    readonly telecommunication: FieldRef<"ExpensesDetails", 'Decimal'>
    readonly accountMaintenanceFee: FieldRef<"ExpensesDetails", 'Decimal'>
    readonly alimony: FieldRef<"ExpensesDetails", 'Decimal'>
    readonly subscriptions: FieldRef<"ExpensesDetails", 'Decimal'>
    readonly otherExpenses: FieldRef<"ExpensesDetails", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ExpensesDetails findUnique
   */
  export type ExpensesDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ExpensesDetails to fetch.
     */
    where: ExpensesDetailsWhereUniqueInput
  }

  /**
   * ExpensesDetails findUniqueOrThrow
   */
  export type ExpensesDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ExpensesDetails to fetch.
     */
    where: ExpensesDetailsWhereUniqueInput
  }

  /**
   * ExpensesDetails findFirst
   */
  export type ExpensesDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ExpensesDetails to fetch.
     */
    where?: ExpensesDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpensesDetails to fetch.
     */
    orderBy?: ExpensesDetailsOrderByWithRelationInput | ExpensesDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpensesDetails.
     */
    cursor?: ExpensesDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpensesDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpensesDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpensesDetails.
     */
    distinct?: ExpensesDetailsScalarFieldEnum | ExpensesDetailsScalarFieldEnum[]
  }

  /**
   * ExpensesDetails findFirstOrThrow
   */
  export type ExpensesDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ExpensesDetails to fetch.
     */
    where?: ExpensesDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpensesDetails to fetch.
     */
    orderBy?: ExpensesDetailsOrderByWithRelationInput | ExpensesDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpensesDetails.
     */
    cursor?: ExpensesDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpensesDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpensesDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpensesDetails.
     */
    distinct?: ExpensesDetailsScalarFieldEnum | ExpensesDetailsScalarFieldEnum[]
  }

  /**
   * ExpensesDetails findMany
   */
  export type ExpensesDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * Filter, which ExpensesDetails to fetch.
     */
    where?: ExpensesDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpensesDetails to fetch.
     */
    orderBy?: ExpensesDetailsOrderByWithRelationInput | ExpensesDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpensesDetails.
     */
    cursor?: ExpensesDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpensesDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpensesDetails.
     */
    skip?: number
    distinct?: ExpensesDetailsScalarFieldEnum | ExpensesDetailsScalarFieldEnum[]
  }

  /**
   * ExpensesDetails create
   */
  export type ExpensesDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpensesDetails.
     */
    data: XOR<ExpensesDetailsCreateInput, ExpensesDetailsUncheckedCreateInput>
  }

  /**
   * ExpensesDetails createMany
   */
  export type ExpensesDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpensesDetails.
     */
    data: ExpensesDetailsCreateManyInput | ExpensesDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpensesDetails createManyAndReturn
   */
  export type ExpensesDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many ExpensesDetails.
     */
    data: ExpensesDetailsCreateManyInput | ExpensesDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpensesDetails update
   */
  export type ExpensesDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpensesDetails.
     */
    data: XOR<ExpensesDetailsUpdateInput, ExpensesDetailsUncheckedUpdateInput>
    /**
     * Choose, which ExpensesDetails to update.
     */
    where: ExpensesDetailsWhereUniqueInput
  }

  /**
   * ExpensesDetails updateMany
   */
  export type ExpensesDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpensesDetails.
     */
    data: XOR<ExpensesDetailsUpdateManyMutationInput, ExpensesDetailsUncheckedUpdateManyInput>
    /**
     * Filter which ExpensesDetails to update
     */
    where?: ExpensesDetailsWhereInput
    /**
     * Limit how many ExpensesDetails to update.
     */
    limit?: number
  }

  /**
   * ExpensesDetails updateManyAndReturn
   */
  export type ExpensesDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * The data used to update ExpensesDetails.
     */
    data: XOR<ExpensesDetailsUpdateManyMutationInput, ExpensesDetailsUncheckedUpdateManyInput>
    /**
     * Filter which ExpensesDetails to update
     */
    where?: ExpensesDetailsWhereInput
    /**
     * Limit how many ExpensesDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpensesDetails upsert
   */
  export type ExpensesDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpensesDetails to update in case it exists.
     */
    where: ExpensesDetailsWhereUniqueInput
    /**
     * In case the ExpensesDetails found by the `where` argument doesn't exist, create a new ExpensesDetails with this data.
     */
    create: XOR<ExpensesDetailsCreateInput, ExpensesDetailsUncheckedCreateInput>
    /**
     * In case the ExpensesDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpensesDetailsUpdateInput, ExpensesDetailsUncheckedUpdateInput>
  }

  /**
   * ExpensesDetails delete
   */
  export type ExpensesDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
    /**
     * Filter which ExpensesDetails to delete.
     */
    where: ExpensesDetailsWhereUniqueInput
  }

  /**
   * ExpensesDetails deleteMany
   */
  export type ExpensesDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpensesDetails to delete
     */
    where?: ExpensesDetailsWhereInput
    /**
     * Limit how many ExpensesDetails to delete.
     */
    limit?: number
  }

  /**
   * ExpensesDetails without action
   */
  export type ExpensesDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpensesDetails
     */
    select?: ExpensesDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpensesDetails
     */
    omit?: ExpensesDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    realEstate: Decimal | null
    securities: Decimal | null
    bankDeposits: Decimal | null
    buildingSavings: Decimal | null
    insuranceValues: Decimal | null
    otherAssets: Decimal | null
  }

  export type AssetSumAggregateOutputType = {
    realEstate: Decimal | null
    securities: Decimal | null
    bankDeposits: Decimal | null
    buildingSavings: Decimal | null
    insuranceValues: Decimal | null
    otherAssets: Decimal | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    assetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    realEstate: Decimal | null
    securities: Decimal | null
    bankDeposits: Decimal | null
    buildingSavings: Decimal | null
    insuranceValues: Decimal | null
    otherAssets: Decimal | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    assetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    realEstate: Decimal | null
    securities: Decimal | null
    bankDeposits: Decimal | null
    buildingSavings: Decimal | null
    insuranceValues: Decimal | null
    otherAssets: Decimal | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    assetId: number
    createdAt: number
    updatedAt: number
    personalId: number
    realEstate: number
    securities: number
    bankDeposits: number
    buildingSavings: number
    insuranceValues: number
    otherAssets: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    realEstate?: true
    securities?: true
    bankDeposits?: true
    buildingSavings?: true
    insuranceValues?: true
    otherAssets?: true
  }

  export type AssetSumAggregateInputType = {
    realEstate?: true
    securities?: true
    bankDeposits?: true
    buildingSavings?: true
    insuranceValues?: true
    otherAssets?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    assetId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    realEstate?: true
    securities?: true
    bankDeposits?: true
    buildingSavings?: true
    insuranceValues?: true
    otherAssets?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    assetId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    realEstate?: true
    securities?: true
    bankDeposits?: true
    buildingSavings?: true
    insuranceValues?: true
    otherAssets?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    assetId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    realEstate?: true
    securities?: true
    bankDeposits?: true
    buildingSavings?: true
    insuranceValues?: true
    otherAssets?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    assetId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    realEstate: Decimal
    securities: Decimal
    bankDeposits: Decimal
    buildingSavings: Decimal
    insuranceValues: Decimal
    otherAssets: Decimal
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    realEstate?: boolean
    securities?: boolean
    bankDeposits?: boolean
    buildingSavings?: boolean
    insuranceValues?: boolean
    otherAssets?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    realEstate?: boolean
    securities?: boolean
    bankDeposits?: boolean
    buildingSavings?: boolean
    insuranceValues?: boolean
    otherAssets?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    realEstate?: boolean
    securities?: boolean
    bankDeposits?: boolean
    buildingSavings?: boolean
    insuranceValues?: boolean
    otherAssets?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    assetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    realEstate?: boolean
    securities?: boolean
    bankDeposits?: boolean
    buildingSavings?: boolean
    insuranceValues?: boolean
    otherAssets?: boolean
  }

  export type AssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assetId" | "createdAt" | "updatedAt" | "personalId" | "realEstate" | "securities" | "bankDeposits" | "buildingSavings" | "insuranceValues" | "otherAssets", ExtArgs["result"]["asset"]>
  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type AssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assetId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      realEstate: Prisma.Decimal
      securities: Prisma.Decimal
      bankDeposits: Prisma.Decimal
      buildingSavings: Prisma.Decimal
      insuranceValues: Prisma.Decimal
      otherAssets: Prisma.Decimal
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets and returns the data updated in the database.
     * @param {AssetUpdateManyAndReturnArgs} args - Arguments to update many Assets.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly assetId: FieldRef<"Asset", 'String'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
    readonly personalId: FieldRef<"Asset", 'String'>
    readonly realEstate: FieldRef<"Asset", 'Decimal'>
    readonly securities: FieldRef<"Asset", 'Decimal'>
    readonly bankDeposits: FieldRef<"Asset", 'Decimal'>
    readonly buildingSavings: FieldRef<"Asset", 'Decimal'>
    readonly insuranceValues: FieldRef<"Asset", 'Decimal'>
    readonly otherAssets: FieldRef<"Asset", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset updateManyAndReturn
   */
  export type AssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to delete.
     */
    limit?: number
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model Liability
   */

  export type AggregateLiability = {
    _count: LiabilityCountAggregateOutputType | null
    _avg: LiabilityAvgAggregateOutputType | null
    _sum: LiabilitySumAggregateOutputType | null
    _min: LiabilityMinAggregateOutputType | null
    _max: LiabilityMaxAggregateOutputType | null
  }

  export type LiabilityAvgAggregateOutputType = {
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
  }

  export type LiabilitySumAggregateOutputType = {
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
  }

  export type LiabilityMinAggregateOutputType = {
    id: string | null
    liabilityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    loanType: $Enums.LoanType | null
    loanBank: string | null
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
  }

  export type LiabilityMaxAggregateOutputType = {
    id: string | null
    liabilityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    loanType: $Enums.LoanType | null
    loanBank: string | null
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
  }

  export type LiabilityCountAggregateOutputType = {
    id: number
    liabilityId: number
    createdAt: number
    updatedAt: number
    personalId: number
    loanType: number
    loanBank: number
    loanAmount: number
    loanMonthlyRate: number
    loanInterest: number
    _all: number
  }


  export type LiabilityAvgAggregateInputType = {
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
  }

  export type LiabilitySumAggregateInputType = {
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
  }

  export type LiabilityMinAggregateInputType = {
    id?: true
    liabilityId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    loanType?: true
    loanBank?: true
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
  }

  export type LiabilityMaxAggregateInputType = {
    id?: true
    liabilityId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    loanType?: true
    loanBank?: true
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
  }

  export type LiabilityCountAggregateInputType = {
    id?: true
    liabilityId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    loanType?: true
    loanBank?: true
    loanAmount?: true
    loanMonthlyRate?: true
    loanInterest?: true
    _all?: true
  }

  export type LiabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liability to aggregate.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Liabilities
    **/
    _count?: true | LiabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiabilityMaxAggregateInputType
  }

  export type GetLiabilityAggregateType<T extends LiabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateLiability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiability[P]>
      : GetScalarType<T[P], AggregateLiability[P]>
  }




  export type LiabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiabilityWhereInput
    orderBy?: LiabilityOrderByWithAggregationInput | LiabilityOrderByWithAggregationInput[]
    by: LiabilityScalarFieldEnum[] | LiabilityScalarFieldEnum
    having?: LiabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiabilityCountAggregateInputType | true
    _avg?: LiabilityAvgAggregateInputType
    _sum?: LiabilitySumAggregateInputType
    _min?: LiabilityMinAggregateInputType
    _max?: LiabilityMaxAggregateInputType
  }

  export type LiabilityGroupByOutputType = {
    id: string
    liabilityId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    loanType: $Enums.LoanType
    loanBank: string | null
    loanAmount: Decimal | null
    loanMonthlyRate: Decimal | null
    loanInterest: Decimal | null
    _count: LiabilityCountAggregateOutputType | null
    _avg: LiabilityAvgAggregateOutputType | null
    _sum: LiabilitySumAggregateOutputType | null
    _min: LiabilityMinAggregateOutputType | null
    _max: LiabilityMaxAggregateOutputType | null
  }

  type GetLiabilityGroupByPayload<T extends LiabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiabilityGroupByOutputType[P]>
            : GetScalarType<T[P], LiabilityGroupByOutputType[P]>
        }
      >
    >


  export type LiabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    liabilityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    loanType?: boolean
    loanBank?: boolean
    loanAmount?: boolean
    loanMonthlyRate?: boolean
    loanInterest?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liability"]>

  export type LiabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    liabilityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    loanType?: boolean
    loanBank?: boolean
    loanAmount?: boolean
    loanMonthlyRate?: boolean
    loanInterest?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liability"]>

  export type LiabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    liabilityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    loanType?: boolean
    loanBank?: boolean
    loanAmount?: boolean
    loanMonthlyRate?: boolean
    loanInterest?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liability"]>

  export type LiabilitySelectScalar = {
    id?: boolean
    liabilityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    loanType?: boolean
    loanBank?: boolean
    loanAmount?: boolean
    loanMonthlyRate?: boolean
    loanInterest?: boolean
  }

  export type LiabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "liabilityId" | "createdAt" | "updatedAt" | "personalId" | "loanType" | "loanBank" | "loanAmount" | "loanMonthlyRate" | "loanInterest", ExtArgs["result"]["liability"]>
  export type LiabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type LiabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type LiabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $LiabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Liability"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      liabilityId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      loanType: $Enums.LoanType
      loanBank: string | null
      loanAmount: Prisma.Decimal | null
      loanMonthlyRate: Prisma.Decimal | null
      loanInterest: Prisma.Decimal | null
    }, ExtArgs["result"]["liability"]>
    composites: {}
  }

  type LiabilityGetPayload<S extends boolean | null | undefined | LiabilityDefaultArgs> = $Result.GetResult<Prisma.$LiabilityPayload, S>

  type LiabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiabilityCountAggregateInputType | true
    }

  export interface LiabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Liability'], meta: { name: 'Liability' } }
    /**
     * Find zero or one Liability that matches the filter.
     * @param {LiabilityFindUniqueArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiabilityFindUniqueArgs>(args: SelectSubset<T, LiabilityFindUniqueArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Liability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiabilityFindUniqueOrThrowArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, LiabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Liability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindFirstArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiabilityFindFirstArgs>(args?: SelectSubset<T, LiabilityFindFirstArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Liability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindFirstOrThrowArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, LiabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Liabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Liabilities
     * const liabilities = await prisma.liability.findMany()
     * 
     * // Get first 10 Liabilities
     * const liabilities = await prisma.liability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liabilityWithIdOnly = await prisma.liability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiabilityFindManyArgs>(args?: SelectSubset<T, LiabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Liability.
     * @param {LiabilityCreateArgs} args - Arguments to create a Liability.
     * @example
     * // Create one Liability
     * const Liability = await prisma.liability.create({
     *   data: {
     *     // ... data to create a Liability
     *   }
     * })
     * 
     */
    create<T extends LiabilityCreateArgs>(args: SelectSubset<T, LiabilityCreateArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Liabilities.
     * @param {LiabilityCreateManyArgs} args - Arguments to create many Liabilities.
     * @example
     * // Create many Liabilities
     * const liability = await prisma.liability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiabilityCreateManyArgs>(args?: SelectSubset<T, LiabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Liabilities and returns the data saved in the database.
     * @param {LiabilityCreateManyAndReturnArgs} args - Arguments to create many Liabilities.
     * @example
     * // Create many Liabilities
     * const liability = await prisma.liability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Liabilities and only return the `id`
     * const liabilityWithIdOnly = await prisma.liability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, LiabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Liability.
     * @param {LiabilityDeleteArgs} args - Arguments to delete one Liability.
     * @example
     * // Delete one Liability
     * const Liability = await prisma.liability.delete({
     *   where: {
     *     // ... filter to delete one Liability
     *   }
     * })
     * 
     */
    delete<T extends LiabilityDeleteArgs>(args: SelectSubset<T, LiabilityDeleteArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Liability.
     * @param {LiabilityUpdateArgs} args - Arguments to update one Liability.
     * @example
     * // Update one Liability
     * const liability = await prisma.liability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiabilityUpdateArgs>(args: SelectSubset<T, LiabilityUpdateArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Liabilities.
     * @param {LiabilityDeleteManyArgs} args - Arguments to filter Liabilities to delete.
     * @example
     * // Delete a few Liabilities
     * const { count } = await prisma.liability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiabilityDeleteManyArgs>(args?: SelectSubset<T, LiabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Liabilities
     * const liability = await prisma.liability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiabilityUpdateManyArgs>(args: SelectSubset<T, LiabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liabilities and returns the data updated in the database.
     * @param {LiabilityUpdateManyAndReturnArgs} args - Arguments to update many Liabilities.
     * @example
     * // Update many Liabilities
     * const liability = await prisma.liability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Liabilities and only return the `id`
     * const liabilityWithIdOnly = await prisma.liability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, LiabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Liability.
     * @param {LiabilityUpsertArgs} args - Arguments to update or create a Liability.
     * @example
     * // Update or create a Liability
     * const liability = await prisma.liability.upsert({
     *   create: {
     *     // ... data to create a Liability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Liability we want to update
     *   }
     * })
     */
    upsert<T extends LiabilityUpsertArgs>(args: SelectSubset<T, LiabilityUpsertArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityCountArgs} args - Arguments to filter Liabilities to count.
     * @example
     * // Count the number of Liabilities
     * const count = await prisma.liability.count({
     *   where: {
     *     // ... the filter for the Liabilities we want to count
     *   }
     * })
    **/
    count<T extends LiabilityCountArgs>(
      args?: Subset<T, LiabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Liability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiabilityAggregateArgs>(args: Subset<T, LiabilityAggregateArgs>): Prisma.PrismaPromise<GetLiabilityAggregateType<T>>

    /**
     * Group by Liability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiabilityGroupByArgs['orderBy'] }
        : { orderBy?: LiabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Liability model
   */
  readonly fields: LiabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Liability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Liability model
   */
  interface LiabilityFieldRefs {
    readonly id: FieldRef<"Liability", 'String'>
    readonly liabilityId: FieldRef<"Liability", 'String'>
    readonly createdAt: FieldRef<"Liability", 'DateTime'>
    readonly updatedAt: FieldRef<"Liability", 'DateTime'>
    readonly personalId: FieldRef<"Liability", 'String'>
    readonly loanType: FieldRef<"Liability", 'LoanType'>
    readonly loanBank: FieldRef<"Liability", 'String'>
    readonly loanAmount: FieldRef<"Liability", 'Decimal'>
    readonly loanMonthlyRate: FieldRef<"Liability", 'Decimal'>
    readonly loanInterest: FieldRef<"Liability", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Liability findUnique
   */
  export type LiabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability findUniqueOrThrow
   */
  export type LiabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability findFirst
   */
  export type LiabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liabilities.
     */
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability findFirstOrThrow
   */
  export type LiabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liabilities.
     */
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability findMany
   */
  export type LiabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liabilities to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability create
   */
  export type LiabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Liability.
     */
    data: XOR<LiabilityCreateInput, LiabilityUncheckedCreateInput>
  }

  /**
   * Liability createMany
   */
  export type LiabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Liabilities.
     */
    data: LiabilityCreateManyInput | LiabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Liability createManyAndReturn
   */
  export type LiabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * The data used to create many Liabilities.
     */
    data: LiabilityCreateManyInput | LiabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Liability update
   */
  export type LiabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Liability.
     */
    data: XOR<LiabilityUpdateInput, LiabilityUncheckedUpdateInput>
    /**
     * Choose, which Liability to update.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability updateMany
   */
  export type LiabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Liabilities.
     */
    data: XOR<LiabilityUpdateManyMutationInput, LiabilityUncheckedUpdateManyInput>
    /**
     * Filter which Liabilities to update
     */
    where?: LiabilityWhereInput
    /**
     * Limit how many Liabilities to update.
     */
    limit?: number
  }

  /**
   * Liability updateManyAndReturn
   */
  export type LiabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * The data used to update Liabilities.
     */
    data: XOR<LiabilityUpdateManyMutationInput, LiabilityUncheckedUpdateManyInput>
    /**
     * Filter which Liabilities to update
     */
    where?: LiabilityWhereInput
    /**
     * Limit how many Liabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Liability upsert
   */
  export type LiabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Liability to update in case it exists.
     */
    where: LiabilityWhereUniqueInput
    /**
     * In case the Liability found by the `where` argument doesn't exist, create a new Liability with this data.
     */
    create: XOR<LiabilityCreateInput, LiabilityUncheckedCreateInput>
    /**
     * In case the Liability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiabilityUpdateInput, LiabilityUncheckedUpdateInput>
  }

  /**
   * Liability delete
   */
  export type LiabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter which Liability to delete.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability deleteMany
   */
  export type LiabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liabilities to delete
     */
    where?: LiabilityWhereInput
    /**
     * Limit how many Liabilities to delete.
     */
    limit?: number
  }

  /**
   * Liability without action
   */
  export type LiabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
  }


  /**
   * Model GoalsAndWishes
   */

  export type AggregateGoalsAndWishes = {
    _count: GoalsAndWishesCountAggregateOutputType | null
    _min: GoalsAndWishesMinAggregateOutputType | null
    _max: GoalsAndWishesMaxAggregateOutputType | null
  }

  export type GoalsAndWishesMinAggregateOutputType = {
    id: string | null
    goalsAndWishesId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    retirementPlanning: string | null
    capitalFormation: string | null
    realEstateGoals: string | null
    financing: string | null
    protection: string | null
    healthcareProvision: string | null
    otherGoals: string | null
  }

  export type GoalsAndWishesMaxAggregateOutputType = {
    id: string | null
    goalsAndWishesId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    retirementPlanning: string | null
    capitalFormation: string | null
    realEstateGoals: string | null
    financing: string | null
    protection: string | null
    healthcareProvision: string | null
    otherGoals: string | null
  }

  export type GoalsAndWishesCountAggregateOutputType = {
    id: number
    goalsAndWishesId: number
    createdAt: number
    updatedAt: number
    personalId: number
    retirementPlanning: number
    capitalFormation: number
    realEstateGoals: number
    financing: number
    protection: number
    healthcareProvision: number
    otherGoals: number
    _all: number
  }


  export type GoalsAndWishesMinAggregateInputType = {
    id?: true
    goalsAndWishesId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    retirementPlanning?: true
    capitalFormation?: true
    realEstateGoals?: true
    financing?: true
    protection?: true
    healthcareProvision?: true
    otherGoals?: true
  }

  export type GoalsAndWishesMaxAggregateInputType = {
    id?: true
    goalsAndWishesId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    retirementPlanning?: true
    capitalFormation?: true
    realEstateGoals?: true
    financing?: true
    protection?: true
    healthcareProvision?: true
    otherGoals?: true
  }

  export type GoalsAndWishesCountAggregateInputType = {
    id?: true
    goalsAndWishesId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    retirementPlanning?: true
    capitalFormation?: true
    realEstateGoals?: true
    financing?: true
    protection?: true
    healthcareProvision?: true
    otherGoals?: true
    _all?: true
  }

  export type GoalsAndWishesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalsAndWishes to aggregate.
     */
    where?: GoalsAndWishesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalsAndWishes to fetch.
     */
    orderBy?: GoalsAndWishesOrderByWithRelationInput | GoalsAndWishesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalsAndWishesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalsAndWishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalsAndWishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoalsAndWishes
    **/
    _count?: true | GoalsAndWishesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalsAndWishesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalsAndWishesMaxAggregateInputType
  }

  export type GetGoalsAndWishesAggregateType<T extends GoalsAndWishesAggregateArgs> = {
        [P in keyof T & keyof AggregateGoalsAndWishes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoalsAndWishes[P]>
      : GetScalarType<T[P], AggregateGoalsAndWishes[P]>
  }




  export type GoalsAndWishesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalsAndWishesWhereInput
    orderBy?: GoalsAndWishesOrderByWithAggregationInput | GoalsAndWishesOrderByWithAggregationInput[]
    by: GoalsAndWishesScalarFieldEnum[] | GoalsAndWishesScalarFieldEnum
    having?: GoalsAndWishesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalsAndWishesCountAggregateInputType | true
    _min?: GoalsAndWishesMinAggregateInputType
    _max?: GoalsAndWishesMaxAggregateInputType
  }

  export type GoalsAndWishesGroupByOutputType = {
    id: string
    goalsAndWishesId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    retirementPlanning: string
    capitalFormation: string
    realEstateGoals: string
    financing: string
    protection: string
    healthcareProvision: string
    otherGoals: string
    _count: GoalsAndWishesCountAggregateOutputType | null
    _min: GoalsAndWishesMinAggregateOutputType | null
    _max: GoalsAndWishesMaxAggregateOutputType | null
  }

  type GetGoalsAndWishesGroupByPayload<T extends GoalsAndWishesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalsAndWishesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalsAndWishesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalsAndWishesGroupByOutputType[P]>
            : GetScalarType<T[P], GoalsAndWishesGroupByOutputType[P]>
        }
      >
    >


  export type GoalsAndWishesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalsAndWishesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    retirementPlanning?: boolean
    capitalFormation?: boolean
    realEstateGoals?: boolean
    financing?: boolean
    protection?: boolean
    healthcareProvision?: boolean
    otherGoals?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalsAndWishes"]>

  export type GoalsAndWishesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalsAndWishesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    retirementPlanning?: boolean
    capitalFormation?: boolean
    realEstateGoals?: boolean
    financing?: boolean
    protection?: boolean
    healthcareProvision?: boolean
    otherGoals?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalsAndWishes"]>

  export type GoalsAndWishesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalsAndWishesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    retirementPlanning?: boolean
    capitalFormation?: boolean
    realEstateGoals?: boolean
    financing?: boolean
    protection?: boolean
    healthcareProvision?: boolean
    otherGoals?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalsAndWishes"]>

  export type GoalsAndWishesSelectScalar = {
    id?: boolean
    goalsAndWishesId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    retirementPlanning?: boolean
    capitalFormation?: boolean
    realEstateGoals?: boolean
    financing?: boolean
    protection?: boolean
    healthcareProvision?: boolean
    otherGoals?: boolean
  }

  export type GoalsAndWishesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goalsAndWishesId" | "createdAt" | "updatedAt" | "personalId" | "retirementPlanning" | "capitalFormation" | "realEstateGoals" | "financing" | "protection" | "healthcareProvision" | "otherGoals", ExtArgs["result"]["goalsAndWishes"]>
  export type GoalsAndWishesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type GoalsAndWishesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type GoalsAndWishesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $GoalsAndWishesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoalsAndWishes"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalsAndWishesId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      retirementPlanning: string
      capitalFormation: string
      realEstateGoals: string
      financing: string
      protection: string
      healthcareProvision: string
      otherGoals: string
    }, ExtArgs["result"]["goalsAndWishes"]>
    composites: {}
  }

  type GoalsAndWishesGetPayload<S extends boolean | null | undefined | GoalsAndWishesDefaultArgs> = $Result.GetResult<Prisma.$GoalsAndWishesPayload, S>

  type GoalsAndWishesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoalsAndWishesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoalsAndWishesCountAggregateInputType | true
    }

  export interface GoalsAndWishesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoalsAndWishes'], meta: { name: 'GoalsAndWishes' } }
    /**
     * Find zero or one GoalsAndWishes that matches the filter.
     * @param {GoalsAndWishesFindUniqueArgs} args - Arguments to find a GoalsAndWishes
     * @example
     * // Get one GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalsAndWishesFindUniqueArgs>(args: SelectSubset<T, GoalsAndWishesFindUniqueArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GoalsAndWishes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoalsAndWishesFindUniqueOrThrowArgs} args - Arguments to find a GoalsAndWishes
     * @example
     * // Get one GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalsAndWishesFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalsAndWishesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoalsAndWishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalsAndWishesFindFirstArgs} args - Arguments to find a GoalsAndWishes
     * @example
     * // Get one GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalsAndWishesFindFirstArgs>(args?: SelectSubset<T, GoalsAndWishesFindFirstArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoalsAndWishes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalsAndWishesFindFirstOrThrowArgs} args - Arguments to find a GoalsAndWishes
     * @example
     * // Get one GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalsAndWishesFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalsAndWishesFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GoalsAndWishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalsAndWishesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.findMany()
     * 
     * // Get first 10 GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalsAndWishesWithIdOnly = await prisma.goalsAndWishes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalsAndWishesFindManyArgs>(args?: SelectSubset<T, GoalsAndWishesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GoalsAndWishes.
     * @param {GoalsAndWishesCreateArgs} args - Arguments to create a GoalsAndWishes.
     * @example
     * // Create one GoalsAndWishes
     * const GoalsAndWishes = await prisma.goalsAndWishes.create({
     *   data: {
     *     // ... data to create a GoalsAndWishes
     *   }
     * })
     * 
     */
    create<T extends GoalsAndWishesCreateArgs>(args: SelectSubset<T, GoalsAndWishesCreateArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GoalsAndWishes.
     * @param {GoalsAndWishesCreateManyArgs} args - Arguments to create many GoalsAndWishes.
     * @example
     * // Create many GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalsAndWishesCreateManyArgs>(args?: SelectSubset<T, GoalsAndWishesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoalsAndWishes and returns the data saved in the database.
     * @param {GoalsAndWishesCreateManyAndReturnArgs} args - Arguments to create many GoalsAndWishes.
     * @example
     * // Create many GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoalsAndWishes and only return the `id`
     * const goalsAndWishesWithIdOnly = await prisma.goalsAndWishes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalsAndWishesCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalsAndWishesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GoalsAndWishes.
     * @param {GoalsAndWishesDeleteArgs} args - Arguments to delete one GoalsAndWishes.
     * @example
     * // Delete one GoalsAndWishes
     * const GoalsAndWishes = await prisma.goalsAndWishes.delete({
     *   where: {
     *     // ... filter to delete one GoalsAndWishes
     *   }
     * })
     * 
     */
    delete<T extends GoalsAndWishesDeleteArgs>(args: SelectSubset<T, GoalsAndWishesDeleteArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GoalsAndWishes.
     * @param {GoalsAndWishesUpdateArgs} args - Arguments to update one GoalsAndWishes.
     * @example
     * // Update one GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalsAndWishesUpdateArgs>(args: SelectSubset<T, GoalsAndWishesUpdateArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GoalsAndWishes.
     * @param {GoalsAndWishesDeleteManyArgs} args - Arguments to filter GoalsAndWishes to delete.
     * @example
     * // Delete a few GoalsAndWishes
     * const { count } = await prisma.goalsAndWishes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalsAndWishesDeleteManyArgs>(args?: SelectSubset<T, GoalsAndWishesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoalsAndWishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalsAndWishesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalsAndWishesUpdateManyArgs>(args: SelectSubset<T, GoalsAndWishesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoalsAndWishes and returns the data updated in the database.
     * @param {GoalsAndWishesUpdateManyAndReturnArgs} args - Arguments to update many GoalsAndWishes.
     * @example
     * // Update many GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GoalsAndWishes and only return the `id`
     * const goalsAndWishesWithIdOnly = await prisma.goalsAndWishes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoalsAndWishesUpdateManyAndReturnArgs>(args: SelectSubset<T, GoalsAndWishesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GoalsAndWishes.
     * @param {GoalsAndWishesUpsertArgs} args - Arguments to update or create a GoalsAndWishes.
     * @example
     * // Update or create a GoalsAndWishes
     * const goalsAndWishes = await prisma.goalsAndWishes.upsert({
     *   create: {
     *     // ... data to create a GoalsAndWishes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoalsAndWishes we want to update
     *   }
     * })
     */
    upsert<T extends GoalsAndWishesUpsertArgs>(args: SelectSubset<T, GoalsAndWishesUpsertArgs<ExtArgs>>): Prisma__GoalsAndWishesClient<$Result.GetResult<Prisma.$GoalsAndWishesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GoalsAndWishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalsAndWishesCountArgs} args - Arguments to filter GoalsAndWishes to count.
     * @example
     * // Count the number of GoalsAndWishes
     * const count = await prisma.goalsAndWishes.count({
     *   where: {
     *     // ... the filter for the GoalsAndWishes we want to count
     *   }
     * })
    **/
    count<T extends GoalsAndWishesCountArgs>(
      args?: Subset<T, GoalsAndWishesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalsAndWishesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoalsAndWishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalsAndWishesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalsAndWishesAggregateArgs>(args: Subset<T, GoalsAndWishesAggregateArgs>): Prisma.PrismaPromise<GetGoalsAndWishesAggregateType<T>>

    /**
     * Group by GoalsAndWishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalsAndWishesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalsAndWishesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalsAndWishesGroupByArgs['orderBy'] }
        : { orderBy?: GoalsAndWishesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalsAndWishesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalsAndWishesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoalsAndWishes model
   */
  readonly fields: GoalsAndWishesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoalsAndWishes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalsAndWishesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoalsAndWishes model
   */
  interface GoalsAndWishesFieldRefs {
    readonly id: FieldRef<"GoalsAndWishes", 'String'>
    readonly goalsAndWishesId: FieldRef<"GoalsAndWishes", 'String'>
    readonly createdAt: FieldRef<"GoalsAndWishes", 'DateTime'>
    readonly updatedAt: FieldRef<"GoalsAndWishes", 'DateTime'>
    readonly personalId: FieldRef<"GoalsAndWishes", 'String'>
    readonly retirementPlanning: FieldRef<"GoalsAndWishes", 'String'>
    readonly capitalFormation: FieldRef<"GoalsAndWishes", 'String'>
    readonly realEstateGoals: FieldRef<"GoalsAndWishes", 'String'>
    readonly financing: FieldRef<"GoalsAndWishes", 'String'>
    readonly protection: FieldRef<"GoalsAndWishes", 'String'>
    readonly healthcareProvision: FieldRef<"GoalsAndWishes", 'String'>
    readonly otherGoals: FieldRef<"GoalsAndWishes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GoalsAndWishes findUnique
   */
  export type GoalsAndWishesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * Filter, which GoalsAndWishes to fetch.
     */
    where: GoalsAndWishesWhereUniqueInput
  }

  /**
   * GoalsAndWishes findUniqueOrThrow
   */
  export type GoalsAndWishesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * Filter, which GoalsAndWishes to fetch.
     */
    where: GoalsAndWishesWhereUniqueInput
  }

  /**
   * GoalsAndWishes findFirst
   */
  export type GoalsAndWishesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * Filter, which GoalsAndWishes to fetch.
     */
    where?: GoalsAndWishesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalsAndWishes to fetch.
     */
    orderBy?: GoalsAndWishesOrderByWithRelationInput | GoalsAndWishesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalsAndWishes.
     */
    cursor?: GoalsAndWishesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalsAndWishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalsAndWishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalsAndWishes.
     */
    distinct?: GoalsAndWishesScalarFieldEnum | GoalsAndWishesScalarFieldEnum[]
  }

  /**
   * GoalsAndWishes findFirstOrThrow
   */
  export type GoalsAndWishesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * Filter, which GoalsAndWishes to fetch.
     */
    where?: GoalsAndWishesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalsAndWishes to fetch.
     */
    orderBy?: GoalsAndWishesOrderByWithRelationInput | GoalsAndWishesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalsAndWishes.
     */
    cursor?: GoalsAndWishesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalsAndWishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalsAndWishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalsAndWishes.
     */
    distinct?: GoalsAndWishesScalarFieldEnum | GoalsAndWishesScalarFieldEnum[]
  }

  /**
   * GoalsAndWishes findMany
   */
  export type GoalsAndWishesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * Filter, which GoalsAndWishes to fetch.
     */
    where?: GoalsAndWishesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalsAndWishes to fetch.
     */
    orderBy?: GoalsAndWishesOrderByWithRelationInput | GoalsAndWishesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoalsAndWishes.
     */
    cursor?: GoalsAndWishesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalsAndWishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalsAndWishes.
     */
    skip?: number
    distinct?: GoalsAndWishesScalarFieldEnum | GoalsAndWishesScalarFieldEnum[]
  }

  /**
   * GoalsAndWishes create
   */
  export type GoalsAndWishesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * The data needed to create a GoalsAndWishes.
     */
    data: XOR<GoalsAndWishesCreateInput, GoalsAndWishesUncheckedCreateInput>
  }

  /**
   * GoalsAndWishes createMany
   */
  export type GoalsAndWishesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoalsAndWishes.
     */
    data: GoalsAndWishesCreateManyInput | GoalsAndWishesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoalsAndWishes createManyAndReturn
   */
  export type GoalsAndWishesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * The data used to create many GoalsAndWishes.
     */
    data: GoalsAndWishesCreateManyInput | GoalsAndWishesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoalsAndWishes update
   */
  export type GoalsAndWishesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * The data needed to update a GoalsAndWishes.
     */
    data: XOR<GoalsAndWishesUpdateInput, GoalsAndWishesUncheckedUpdateInput>
    /**
     * Choose, which GoalsAndWishes to update.
     */
    where: GoalsAndWishesWhereUniqueInput
  }

  /**
   * GoalsAndWishes updateMany
   */
  export type GoalsAndWishesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoalsAndWishes.
     */
    data: XOR<GoalsAndWishesUpdateManyMutationInput, GoalsAndWishesUncheckedUpdateManyInput>
    /**
     * Filter which GoalsAndWishes to update
     */
    where?: GoalsAndWishesWhereInput
    /**
     * Limit how many GoalsAndWishes to update.
     */
    limit?: number
  }

  /**
   * GoalsAndWishes updateManyAndReturn
   */
  export type GoalsAndWishesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * The data used to update GoalsAndWishes.
     */
    data: XOR<GoalsAndWishesUpdateManyMutationInput, GoalsAndWishesUncheckedUpdateManyInput>
    /**
     * Filter which GoalsAndWishes to update
     */
    where?: GoalsAndWishesWhereInput
    /**
     * Limit how many GoalsAndWishes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoalsAndWishes upsert
   */
  export type GoalsAndWishesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * The filter to search for the GoalsAndWishes to update in case it exists.
     */
    where: GoalsAndWishesWhereUniqueInput
    /**
     * In case the GoalsAndWishes found by the `where` argument doesn't exist, create a new GoalsAndWishes with this data.
     */
    create: XOR<GoalsAndWishesCreateInput, GoalsAndWishesUncheckedCreateInput>
    /**
     * In case the GoalsAndWishes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalsAndWishesUpdateInput, GoalsAndWishesUncheckedUpdateInput>
  }

  /**
   * GoalsAndWishes delete
   */
  export type GoalsAndWishesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
    /**
     * Filter which GoalsAndWishes to delete.
     */
    where: GoalsAndWishesWhereUniqueInput
  }

  /**
   * GoalsAndWishes deleteMany
   */
  export type GoalsAndWishesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalsAndWishes to delete
     */
    where?: GoalsAndWishesWhereInput
    /**
     * Limit how many GoalsAndWishes to delete.
     */
    limit?: number
  }

  /**
   * GoalsAndWishes without action
   */
  export type GoalsAndWishesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalsAndWishes
     */
    select?: GoalsAndWishesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalsAndWishes
     */
    omit?: GoalsAndWishesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalsAndWishesInclude<ExtArgs> | null
  }


  /**
   * Model RiskAppetite
   */

  export type AggregateRiskAppetite = {
    _count: RiskAppetiteCountAggregateOutputType | null
    _min: RiskAppetiteMinAggregateOutputType | null
    _max: RiskAppetiteMaxAggregateOutputType | null
  }

  export type RiskAppetiteMinAggregateOutputType = {
    id: string | null
    riskAppetiteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    riskAppetite: string | null
    investmentHorizon: string | null
    knowledgeExperience: string | null
    healthInsurance: string | null
    healthInsuranceNumber: string | null
    healthInsuranceProof: string | null
  }

  export type RiskAppetiteMaxAggregateOutputType = {
    id: string | null
    riskAppetiteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    riskAppetite: string | null
    investmentHorizon: string | null
    knowledgeExperience: string | null
    healthInsurance: string | null
    healthInsuranceNumber: string | null
    healthInsuranceProof: string | null
  }

  export type RiskAppetiteCountAggregateOutputType = {
    id: number
    riskAppetiteId: number
    createdAt: number
    updatedAt: number
    personalId: number
    riskAppetite: number
    investmentHorizon: number
    knowledgeExperience: number
    healthInsurance: number
    healthInsuranceNumber: number
    healthInsuranceProof: number
    _all: number
  }


  export type RiskAppetiteMinAggregateInputType = {
    id?: true
    riskAppetiteId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    riskAppetite?: true
    investmentHorizon?: true
    knowledgeExperience?: true
    healthInsurance?: true
    healthInsuranceNumber?: true
    healthInsuranceProof?: true
  }

  export type RiskAppetiteMaxAggregateInputType = {
    id?: true
    riskAppetiteId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    riskAppetite?: true
    investmentHorizon?: true
    knowledgeExperience?: true
    healthInsurance?: true
    healthInsuranceNumber?: true
    healthInsuranceProof?: true
  }

  export type RiskAppetiteCountAggregateInputType = {
    id?: true
    riskAppetiteId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    riskAppetite?: true
    investmentHorizon?: true
    knowledgeExperience?: true
    healthInsurance?: true
    healthInsuranceNumber?: true
    healthInsuranceProof?: true
    _all?: true
  }

  export type RiskAppetiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAppetite to aggregate.
     */
    where?: RiskAppetiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAppetites to fetch.
     */
    orderBy?: RiskAppetiteOrderByWithRelationInput | RiskAppetiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskAppetiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAppetites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAppetites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskAppetites
    **/
    _count?: true | RiskAppetiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskAppetiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskAppetiteMaxAggregateInputType
  }

  export type GetRiskAppetiteAggregateType<T extends RiskAppetiteAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskAppetite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskAppetite[P]>
      : GetScalarType<T[P], AggregateRiskAppetite[P]>
  }




  export type RiskAppetiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAppetiteWhereInput
    orderBy?: RiskAppetiteOrderByWithAggregationInput | RiskAppetiteOrderByWithAggregationInput[]
    by: RiskAppetiteScalarFieldEnum[] | RiskAppetiteScalarFieldEnum
    having?: RiskAppetiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskAppetiteCountAggregateInputType | true
    _min?: RiskAppetiteMinAggregateInputType
    _max?: RiskAppetiteMaxAggregateInputType
  }

  export type RiskAppetiteGroupByOutputType = {
    id: string
    riskAppetiteId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    riskAppetite: string
    investmentHorizon: string
    knowledgeExperience: string
    healthInsurance: string
    healthInsuranceNumber: string
    healthInsuranceProof: string
    _count: RiskAppetiteCountAggregateOutputType | null
    _min: RiskAppetiteMinAggregateOutputType | null
    _max: RiskAppetiteMaxAggregateOutputType | null
  }

  type GetRiskAppetiteGroupByPayload<T extends RiskAppetiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskAppetiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskAppetiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskAppetiteGroupByOutputType[P]>
            : GetScalarType<T[P], RiskAppetiteGroupByOutputType[P]>
        }
      >
    >


  export type RiskAppetiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riskAppetiteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    riskAppetite?: boolean
    investmentHorizon?: boolean
    knowledgeExperience?: boolean
    healthInsurance?: boolean
    healthInsuranceNumber?: boolean
    healthInsuranceProof?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAppetite"]>

  export type RiskAppetiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riskAppetiteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    riskAppetite?: boolean
    investmentHorizon?: boolean
    knowledgeExperience?: boolean
    healthInsurance?: boolean
    healthInsuranceNumber?: boolean
    healthInsuranceProof?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAppetite"]>

  export type RiskAppetiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riskAppetiteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    riskAppetite?: boolean
    investmentHorizon?: boolean
    knowledgeExperience?: boolean
    healthInsurance?: boolean
    healthInsuranceNumber?: boolean
    healthInsuranceProof?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAppetite"]>

  export type RiskAppetiteSelectScalar = {
    id?: boolean
    riskAppetiteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    riskAppetite?: boolean
    investmentHorizon?: boolean
    knowledgeExperience?: boolean
    healthInsurance?: boolean
    healthInsuranceNumber?: boolean
    healthInsuranceProof?: boolean
  }

  export type RiskAppetiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "riskAppetiteId" | "createdAt" | "updatedAt" | "personalId" | "riskAppetite" | "investmentHorizon" | "knowledgeExperience" | "healthInsurance" | "healthInsuranceNumber" | "healthInsuranceProof", ExtArgs["result"]["riskAppetite"]>
  export type RiskAppetiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type RiskAppetiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type RiskAppetiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $RiskAppetitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskAppetite"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      riskAppetiteId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      riskAppetite: string
      investmentHorizon: string
      knowledgeExperience: string
      healthInsurance: string
      healthInsuranceNumber: string
      healthInsuranceProof: string
    }, ExtArgs["result"]["riskAppetite"]>
    composites: {}
  }

  type RiskAppetiteGetPayload<S extends boolean | null | undefined | RiskAppetiteDefaultArgs> = $Result.GetResult<Prisma.$RiskAppetitePayload, S>

  type RiskAppetiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskAppetiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskAppetiteCountAggregateInputType | true
    }

  export interface RiskAppetiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskAppetite'], meta: { name: 'RiskAppetite' } }
    /**
     * Find zero or one RiskAppetite that matches the filter.
     * @param {RiskAppetiteFindUniqueArgs} args - Arguments to find a RiskAppetite
     * @example
     * // Get one RiskAppetite
     * const riskAppetite = await prisma.riskAppetite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskAppetiteFindUniqueArgs>(args: SelectSubset<T, RiskAppetiteFindUniqueArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RiskAppetite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskAppetiteFindUniqueOrThrowArgs} args - Arguments to find a RiskAppetite
     * @example
     * // Get one RiskAppetite
     * const riskAppetite = await prisma.riskAppetite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskAppetiteFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskAppetiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskAppetite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAppetiteFindFirstArgs} args - Arguments to find a RiskAppetite
     * @example
     * // Get one RiskAppetite
     * const riskAppetite = await prisma.riskAppetite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskAppetiteFindFirstArgs>(args?: SelectSubset<T, RiskAppetiteFindFirstArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskAppetite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAppetiteFindFirstOrThrowArgs} args - Arguments to find a RiskAppetite
     * @example
     * // Get one RiskAppetite
     * const riskAppetite = await prisma.riskAppetite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskAppetiteFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskAppetiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RiskAppetites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAppetiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskAppetites
     * const riskAppetites = await prisma.riskAppetite.findMany()
     * 
     * // Get first 10 RiskAppetites
     * const riskAppetites = await prisma.riskAppetite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskAppetiteWithIdOnly = await prisma.riskAppetite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskAppetiteFindManyArgs>(args?: SelectSubset<T, RiskAppetiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RiskAppetite.
     * @param {RiskAppetiteCreateArgs} args - Arguments to create a RiskAppetite.
     * @example
     * // Create one RiskAppetite
     * const RiskAppetite = await prisma.riskAppetite.create({
     *   data: {
     *     // ... data to create a RiskAppetite
     *   }
     * })
     * 
     */
    create<T extends RiskAppetiteCreateArgs>(args: SelectSubset<T, RiskAppetiteCreateArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RiskAppetites.
     * @param {RiskAppetiteCreateManyArgs} args - Arguments to create many RiskAppetites.
     * @example
     * // Create many RiskAppetites
     * const riskAppetite = await prisma.riskAppetite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskAppetiteCreateManyArgs>(args?: SelectSubset<T, RiskAppetiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskAppetites and returns the data saved in the database.
     * @param {RiskAppetiteCreateManyAndReturnArgs} args - Arguments to create many RiskAppetites.
     * @example
     * // Create many RiskAppetites
     * const riskAppetite = await prisma.riskAppetite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskAppetites and only return the `id`
     * const riskAppetiteWithIdOnly = await prisma.riskAppetite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskAppetiteCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskAppetiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RiskAppetite.
     * @param {RiskAppetiteDeleteArgs} args - Arguments to delete one RiskAppetite.
     * @example
     * // Delete one RiskAppetite
     * const RiskAppetite = await prisma.riskAppetite.delete({
     *   where: {
     *     // ... filter to delete one RiskAppetite
     *   }
     * })
     * 
     */
    delete<T extends RiskAppetiteDeleteArgs>(args: SelectSubset<T, RiskAppetiteDeleteArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RiskAppetite.
     * @param {RiskAppetiteUpdateArgs} args - Arguments to update one RiskAppetite.
     * @example
     * // Update one RiskAppetite
     * const riskAppetite = await prisma.riskAppetite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskAppetiteUpdateArgs>(args: SelectSubset<T, RiskAppetiteUpdateArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RiskAppetites.
     * @param {RiskAppetiteDeleteManyArgs} args - Arguments to filter RiskAppetites to delete.
     * @example
     * // Delete a few RiskAppetites
     * const { count } = await prisma.riskAppetite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskAppetiteDeleteManyArgs>(args?: SelectSubset<T, RiskAppetiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAppetites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAppetiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskAppetites
     * const riskAppetite = await prisma.riskAppetite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskAppetiteUpdateManyArgs>(args: SelectSubset<T, RiskAppetiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAppetites and returns the data updated in the database.
     * @param {RiskAppetiteUpdateManyAndReturnArgs} args - Arguments to update many RiskAppetites.
     * @example
     * // Update many RiskAppetites
     * const riskAppetite = await prisma.riskAppetite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RiskAppetites and only return the `id`
     * const riskAppetiteWithIdOnly = await prisma.riskAppetite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskAppetiteUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskAppetiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RiskAppetite.
     * @param {RiskAppetiteUpsertArgs} args - Arguments to update or create a RiskAppetite.
     * @example
     * // Update or create a RiskAppetite
     * const riskAppetite = await prisma.riskAppetite.upsert({
     *   create: {
     *     // ... data to create a RiskAppetite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskAppetite we want to update
     *   }
     * })
     */
    upsert<T extends RiskAppetiteUpsertArgs>(args: SelectSubset<T, RiskAppetiteUpsertArgs<ExtArgs>>): Prisma__RiskAppetiteClient<$Result.GetResult<Prisma.$RiskAppetitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RiskAppetites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAppetiteCountArgs} args - Arguments to filter RiskAppetites to count.
     * @example
     * // Count the number of RiskAppetites
     * const count = await prisma.riskAppetite.count({
     *   where: {
     *     // ... the filter for the RiskAppetites we want to count
     *   }
     * })
    **/
    count<T extends RiskAppetiteCountArgs>(
      args?: Subset<T, RiskAppetiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskAppetiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskAppetite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAppetiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAppetiteAggregateArgs>(args: Subset<T, RiskAppetiteAggregateArgs>): Prisma.PrismaPromise<GetRiskAppetiteAggregateType<T>>

    /**
     * Group by RiskAppetite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAppetiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskAppetiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskAppetiteGroupByArgs['orderBy'] }
        : { orderBy?: RiskAppetiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskAppetiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskAppetiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskAppetite model
   */
  readonly fields: RiskAppetiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskAppetite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskAppetiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskAppetite model
   */
  interface RiskAppetiteFieldRefs {
    readonly id: FieldRef<"RiskAppetite", 'String'>
    readonly riskAppetiteId: FieldRef<"RiskAppetite", 'String'>
    readonly createdAt: FieldRef<"RiskAppetite", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskAppetite", 'DateTime'>
    readonly personalId: FieldRef<"RiskAppetite", 'String'>
    readonly riskAppetite: FieldRef<"RiskAppetite", 'String'>
    readonly investmentHorizon: FieldRef<"RiskAppetite", 'String'>
    readonly knowledgeExperience: FieldRef<"RiskAppetite", 'String'>
    readonly healthInsurance: FieldRef<"RiskAppetite", 'String'>
    readonly healthInsuranceNumber: FieldRef<"RiskAppetite", 'String'>
    readonly healthInsuranceProof: FieldRef<"RiskAppetite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RiskAppetite findUnique
   */
  export type RiskAppetiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * Filter, which RiskAppetite to fetch.
     */
    where: RiskAppetiteWhereUniqueInput
  }

  /**
   * RiskAppetite findUniqueOrThrow
   */
  export type RiskAppetiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * Filter, which RiskAppetite to fetch.
     */
    where: RiskAppetiteWhereUniqueInput
  }

  /**
   * RiskAppetite findFirst
   */
  export type RiskAppetiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * Filter, which RiskAppetite to fetch.
     */
    where?: RiskAppetiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAppetites to fetch.
     */
    orderBy?: RiskAppetiteOrderByWithRelationInput | RiskAppetiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAppetites.
     */
    cursor?: RiskAppetiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAppetites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAppetites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAppetites.
     */
    distinct?: RiskAppetiteScalarFieldEnum | RiskAppetiteScalarFieldEnum[]
  }

  /**
   * RiskAppetite findFirstOrThrow
   */
  export type RiskAppetiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * Filter, which RiskAppetite to fetch.
     */
    where?: RiskAppetiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAppetites to fetch.
     */
    orderBy?: RiskAppetiteOrderByWithRelationInput | RiskAppetiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAppetites.
     */
    cursor?: RiskAppetiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAppetites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAppetites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAppetites.
     */
    distinct?: RiskAppetiteScalarFieldEnum | RiskAppetiteScalarFieldEnum[]
  }

  /**
   * RiskAppetite findMany
   */
  export type RiskAppetiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * Filter, which RiskAppetites to fetch.
     */
    where?: RiskAppetiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAppetites to fetch.
     */
    orderBy?: RiskAppetiteOrderByWithRelationInput | RiskAppetiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskAppetites.
     */
    cursor?: RiskAppetiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAppetites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAppetites.
     */
    skip?: number
    distinct?: RiskAppetiteScalarFieldEnum | RiskAppetiteScalarFieldEnum[]
  }

  /**
   * RiskAppetite create
   */
  export type RiskAppetiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskAppetite.
     */
    data: XOR<RiskAppetiteCreateInput, RiskAppetiteUncheckedCreateInput>
  }

  /**
   * RiskAppetite createMany
   */
  export type RiskAppetiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskAppetites.
     */
    data: RiskAppetiteCreateManyInput | RiskAppetiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAppetite createManyAndReturn
   */
  export type RiskAppetiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * The data used to create many RiskAppetites.
     */
    data: RiskAppetiteCreateManyInput | RiskAppetiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskAppetite update
   */
  export type RiskAppetiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskAppetite.
     */
    data: XOR<RiskAppetiteUpdateInput, RiskAppetiteUncheckedUpdateInput>
    /**
     * Choose, which RiskAppetite to update.
     */
    where: RiskAppetiteWhereUniqueInput
  }

  /**
   * RiskAppetite updateMany
   */
  export type RiskAppetiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskAppetites.
     */
    data: XOR<RiskAppetiteUpdateManyMutationInput, RiskAppetiteUncheckedUpdateManyInput>
    /**
     * Filter which RiskAppetites to update
     */
    where?: RiskAppetiteWhereInput
    /**
     * Limit how many RiskAppetites to update.
     */
    limit?: number
  }

  /**
   * RiskAppetite updateManyAndReturn
   */
  export type RiskAppetiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * The data used to update RiskAppetites.
     */
    data: XOR<RiskAppetiteUpdateManyMutationInput, RiskAppetiteUncheckedUpdateManyInput>
    /**
     * Filter which RiskAppetites to update
     */
    where?: RiskAppetiteWhereInput
    /**
     * Limit how many RiskAppetites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskAppetite upsert
   */
  export type RiskAppetiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskAppetite to update in case it exists.
     */
    where: RiskAppetiteWhereUniqueInput
    /**
     * In case the RiskAppetite found by the `where` argument doesn't exist, create a new RiskAppetite with this data.
     */
    create: XOR<RiskAppetiteCreateInput, RiskAppetiteUncheckedCreateInput>
    /**
     * In case the RiskAppetite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskAppetiteUpdateInput, RiskAppetiteUncheckedUpdateInput>
  }

  /**
   * RiskAppetite delete
   */
  export type RiskAppetiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
    /**
     * Filter which RiskAppetite to delete.
     */
    where: RiskAppetiteWhereUniqueInput
  }

  /**
   * RiskAppetite deleteMany
   */
  export type RiskAppetiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAppetites to delete
     */
    where?: RiskAppetiteWhereInput
    /**
     * Limit how many RiskAppetites to delete.
     */
    limit?: number
  }

  /**
   * RiskAppetite without action
   */
  export type RiskAppetiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAppetite
     */
    select?: RiskAppetiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskAppetite
     */
    omit?: RiskAppetiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAppetiteInclude<ExtArgs> | null
  }


  /**
   * Model Consent
   */

  export type AggregateConsent = {
    _count: ConsentCountAggregateOutputType | null
    _min: ConsentMinAggregateOutputType | null
    _max: ConsentMaxAggregateOutputType | null
  }

  export type ConsentMinAggregateOutputType = {
    id: string | null
    consentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    consentType: $Enums.ConsentType | null
    consent: boolean | null
    consentText: string | null
    consentSignature: string | null
    consentDate: Date | null
    location: string | null
  }

  export type ConsentMaxAggregateOutputType = {
    id: string | null
    consentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    consentType: $Enums.ConsentType | null
    consent: boolean | null
    consentText: string | null
    consentSignature: string | null
    consentDate: Date | null
    location: string | null
  }

  export type ConsentCountAggregateOutputType = {
    id: number
    consentId: number
    createdAt: number
    updatedAt: number
    personalId: number
    consentType: number
    consent: number
    consentText: number
    consentSignature: number
    consentDate: number
    location: number
    _all: number
  }


  export type ConsentMinAggregateInputType = {
    id?: true
    consentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    consentType?: true
    consent?: true
    consentText?: true
    consentSignature?: true
    consentDate?: true
    location?: true
  }

  export type ConsentMaxAggregateInputType = {
    id?: true
    consentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    consentType?: true
    consent?: true
    consentText?: true
    consentSignature?: true
    consentDate?: true
    location?: true
  }

  export type ConsentCountAggregateInputType = {
    id?: true
    consentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    consentType?: true
    consent?: true
    consentText?: true
    consentSignature?: true
    consentDate?: true
    location?: true
    _all?: true
  }

  export type ConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consent to aggregate.
     */
    where?: ConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consents to fetch.
     */
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consents
    **/
    _count?: true | ConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentMaxAggregateInputType
  }

  export type GetConsentAggregateType<T extends ConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsent[P]>
      : GetScalarType<T[P], AggregateConsent[P]>
  }




  export type ConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentWhereInput
    orderBy?: ConsentOrderByWithAggregationInput | ConsentOrderByWithAggregationInput[]
    by: ConsentScalarFieldEnum[] | ConsentScalarFieldEnum
    having?: ConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentCountAggregateInputType | true
    _min?: ConsentMinAggregateInputType
    _max?: ConsentMaxAggregateInputType
  }

  export type ConsentGroupByOutputType = {
    id: string
    consentId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    consentType: $Enums.ConsentType
    consent: boolean
    consentText: string
    consentSignature: string
    consentDate: Date
    location: string
    _count: ConsentCountAggregateOutputType | null
    _min: ConsentMinAggregateOutputType | null
    _max: ConsentMaxAggregateOutputType | null
  }

  type GetConsentGroupByPayload<T extends ConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentGroupByOutputType[P]>
        }
      >
    >


  export type ConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    consentType?: boolean
    consent?: boolean
    consentText?: boolean
    consentSignature?: boolean
    consentDate?: boolean
    location?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consent"]>

  export type ConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    consentType?: boolean
    consent?: boolean
    consentText?: boolean
    consentSignature?: boolean
    consentDate?: boolean
    location?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consent"]>

  export type ConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    consentType?: boolean
    consent?: boolean
    consentText?: boolean
    consentSignature?: boolean
    consentDate?: boolean
    location?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consent"]>

  export type ConsentSelectScalar = {
    id?: boolean
    consentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    consentType?: boolean
    consent?: boolean
    consentText?: boolean
    consentSignature?: boolean
    consentDate?: boolean
    location?: boolean
  }

  export type ConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "consentId" | "createdAt" | "updatedAt" | "personalId" | "consentType" | "consent" | "consentText" | "consentSignature" | "consentDate" | "location", ExtArgs["result"]["consent"]>
  export type ConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type ConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type ConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $ConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consent"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consentId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      consentType: $Enums.ConsentType
      consent: boolean
      consentText: string
      consentSignature: string
      consentDate: Date
      location: string
    }, ExtArgs["result"]["consent"]>
    composites: {}
  }

  type ConsentGetPayload<S extends boolean | null | undefined | ConsentDefaultArgs> = $Result.GetResult<Prisma.$ConsentPayload, S>

  type ConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsentCountAggregateInputType | true
    }

  export interface ConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consent'], meta: { name: 'Consent' } }
    /**
     * Find zero or one Consent that matches the filter.
     * @param {ConsentFindUniqueArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsentFindUniqueArgs>(args: SelectSubset<T, ConsentFindUniqueArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsentFindUniqueOrThrowArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentFindFirstArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsentFindFirstArgs>(args?: SelectSubset<T, ConsentFindFirstArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentFindFirstOrThrowArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consents
     * const consents = await prisma.consent.findMany()
     * 
     * // Get first 10 Consents
     * const consents = await prisma.consent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentWithIdOnly = await prisma.consent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsentFindManyArgs>(args?: SelectSubset<T, ConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consent.
     * @param {ConsentCreateArgs} args - Arguments to create a Consent.
     * @example
     * // Create one Consent
     * const Consent = await prisma.consent.create({
     *   data: {
     *     // ... data to create a Consent
     *   }
     * })
     * 
     */
    create<T extends ConsentCreateArgs>(args: SelectSubset<T, ConsentCreateArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consents.
     * @param {ConsentCreateManyArgs} args - Arguments to create many Consents.
     * @example
     * // Create many Consents
     * const consent = await prisma.consent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsentCreateManyArgs>(args?: SelectSubset<T, ConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consents and returns the data saved in the database.
     * @param {ConsentCreateManyAndReturnArgs} args - Arguments to create many Consents.
     * @example
     * // Create many Consents
     * const consent = await prisma.consent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consents and only return the `id`
     * const consentWithIdOnly = await prisma.consent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consent.
     * @param {ConsentDeleteArgs} args - Arguments to delete one Consent.
     * @example
     * // Delete one Consent
     * const Consent = await prisma.consent.delete({
     *   where: {
     *     // ... filter to delete one Consent
     *   }
     * })
     * 
     */
    delete<T extends ConsentDeleteArgs>(args: SelectSubset<T, ConsentDeleteArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consent.
     * @param {ConsentUpdateArgs} args - Arguments to update one Consent.
     * @example
     * // Update one Consent
     * const consent = await prisma.consent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsentUpdateArgs>(args: SelectSubset<T, ConsentUpdateArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consents.
     * @param {ConsentDeleteManyArgs} args - Arguments to filter Consents to delete.
     * @example
     * // Delete a few Consents
     * const { count } = await prisma.consent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsentDeleteManyArgs>(args?: SelectSubset<T, ConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consents
     * const consent = await prisma.consent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsentUpdateManyArgs>(args: SelectSubset<T, ConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consents and returns the data updated in the database.
     * @param {ConsentUpdateManyAndReturnArgs} args - Arguments to update many Consents.
     * @example
     * // Update many Consents
     * const consent = await prisma.consent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consents and only return the `id`
     * const consentWithIdOnly = await prisma.consent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, ConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consent.
     * @param {ConsentUpsertArgs} args - Arguments to update or create a Consent.
     * @example
     * // Update or create a Consent
     * const consent = await prisma.consent.upsert({
     *   create: {
     *     // ... data to create a Consent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consent we want to update
     *   }
     * })
     */
    upsert<T extends ConsentUpsertArgs>(args: SelectSubset<T, ConsentUpsertArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentCountArgs} args - Arguments to filter Consents to count.
     * @example
     * // Count the number of Consents
     * const count = await prisma.consent.count({
     *   where: {
     *     // ... the filter for the Consents we want to count
     *   }
     * })
    **/
    count<T extends ConsentCountArgs>(
      args?: Subset<T, ConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentAggregateArgs>(args: Subset<T, ConsentAggregateArgs>): Prisma.PrismaPromise<GetConsentAggregateType<T>>

    /**
     * Group by Consent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsentGroupByArgs['orderBy'] }
        : { orderBy?: ConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consent model
   */
  readonly fields: ConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Consent model
   */
  interface ConsentFieldRefs {
    readonly id: FieldRef<"Consent", 'String'>
    readonly consentId: FieldRef<"Consent", 'String'>
    readonly createdAt: FieldRef<"Consent", 'DateTime'>
    readonly updatedAt: FieldRef<"Consent", 'DateTime'>
    readonly personalId: FieldRef<"Consent", 'String'>
    readonly consentType: FieldRef<"Consent", 'ConsentType'>
    readonly consent: FieldRef<"Consent", 'Boolean'>
    readonly consentText: FieldRef<"Consent", 'String'>
    readonly consentSignature: FieldRef<"Consent", 'String'>
    readonly consentDate: FieldRef<"Consent", 'DateTime'>
    readonly location: FieldRef<"Consent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Consent findUnique
   */
  export type ConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consent to fetch.
     */
    where: ConsentWhereUniqueInput
  }

  /**
   * Consent findUniqueOrThrow
   */
  export type ConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consent to fetch.
     */
    where: ConsentWhereUniqueInput
  }

  /**
   * Consent findFirst
   */
  export type ConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consent to fetch.
     */
    where?: ConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consents to fetch.
     */
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consents.
     */
    cursor?: ConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consents.
     */
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * Consent findFirstOrThrow
   */
  export type ConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consent to fetch.
     */
    where?: ConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consents to fetch.
     */
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consents.
     */
    cursor?: ConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consents.
     */
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * Consent findMany
   */
  export type ConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consents to fetch.
     */
    where?: ConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consents to fetch.
     */
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consents.
     */
    cursor?: ConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consents.
     */
    skip?: number
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * Consent create
   */
  export type ConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a Consent.
     */
    data: XOR<ConsentCreateInput, ConsentUncheckedCreateInput>
  }

  /**
   * Consent createMany
   */
  export type ConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consents.
     */
    data: ConsentCreateManyInput | ConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Consent createManyAndReturn
   */
  export type ConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * The data used to create many Consents.
     */
    data: ConsentCreateManyInput | ConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consent update
   */
  export type ConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a Consent.
     */
    data: XOR<ConsentUpdateInput, ConsentUncheckedUpdateInput>
    /**
     * Choose, which Consent to update.
     */
    where: ConsentWhereUniqueInput
  }

  /**
   * Consent updateMany
   */
  export type ConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consents.
     */
    data: XOR<ConsentUpdateManyMutationInput, ConsentUncheckedUpdateManyInput>
    /**
     * Filter which Consents to update
     */
    where?: ConsentWhereInput
    /**
     * Limit how many Consents to update.
     */
    limit?: number
  }

  /**
   * Consent updateManyAndReturn
   */
  export type ConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * The data used to update Consents.
     */
    data: XOR<ConsentUpdateManyMutationInput, ConsentUncheckedUpdateManyInput>
    /**
     * Filter which Consents to update
     */
    where?: ConsentWhereInput
    /**
     * Limit how many Consents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consent upsert
   */
  export type ConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the Consent to update in case it exists.
     */
    where: ConsentWhereUniqueInput
    /**
     * In case the Consent found by the `where` argument doesn't exist, create a new Consent with this data.
     */
    create: XOR<ConsentCreateInput, ConsentUncheckedCreateInput>
    /**
     * In case the Consent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsentUpdateInput, ConsentUncheckedUpdateInput>
  }

  /**
   * Consent delete
   */
  export type ConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter which Consent to delete.
     */
    where: ConsentWhereUniqueInput
  }

  /**
   * Consent deleteMany
   */
  export type ConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consents to delete
     */
    where?: ConsentWhereInput
    /**
     * Limit how many Consents to delete.
     */
    limit?: number
  }

  /**
   * Consent without action
   */
  export type ConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    documentName: string | null
    documentLocation: string | null
    documentDate: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    documentName: string | null
    documentLocation: string | null
    documentDate: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    documentId: number
    createdAt: number
    updatedAt: number
    personalId: number
    documentName: number
    documentLocation: number
    documentDate: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    documentName?: true
    documentLocation?: true
    documentDate?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    documentName?: true
    documentLocation?: true
    documentDate?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    documentId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    documentName?: true
    documentLocation?: true
    documentDate?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    documentId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    documentName: string
    documentLocation: string
    documentDate: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    documentName?: boolean
    documentLocation?: boolean
    documentDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    documentName?: boolean
    documentLocation?: boolean
    documentDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    documentName?: boolean
    documentLocation?: boolean
    documentDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    documentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    documentName?: boolean
    documentLocation?: boolean
    documentDate?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "createdAt" | "updatedAt" | "personalId" | "documentName" | "documentLocation" | "documentDate", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      documentName: string
      documentLocation: string
      documentDate: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly documentId: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly personalId: FieldRef<"Document", 'String'>
    readonly documentName: FieldRef<"Document", 'String'>
    readonly documentLocation: FieldRef<"Document", 'String'>
    readonly documentDate: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Form
   */

  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormMinAggregateOutputType = {
    id: string | null
    formId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    formType: $Enums.FormType | null
    formName: string | null
    formLink: string | null
    createdDate: Date | null
    updatedDate: Date | null
  }

  export type FormMaxAggregateOutputType = {
    id: string | null
    formId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    formType: $Enums.FormType | null
    formName: string | null
    formLink: string | null
    createdDate: Date | null
    updatedDate: Date | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    formId: number
    createdAt: number
    updatedAt: number
    personalId: number
    formType: number
    formName: number
    formLink: number
    createdDate: number
    updatedDate: number
    _all: number
  }


  export type FormMinAggregateInputType = {
    id?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    formType?: true
    formName?: true
    formLink?: true
    createdDate?: true
    updatedDate?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    formType?: true
    formName?: true
    formLink?: true
    createdDate?: true
    updatedDate?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    formType?: true
    formName?: true
    formLink?: true
    createdDate?: true
    updatedDate?: true
    _all?: true
  }

  export type FormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form to aggregate.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
    orderBy?: FormOrderByWithAggregationInput | FormOrderByWithAggregationInput[]
    by: FormScalarFieldEnum[] | FormScalarFieldEnum
    having?: FormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }

  export type FormGroupByOutputType = {
    id: string
    formId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    formType: $Enums.FormType
    formName: string
    formLink: string
    createdDate: Date
    updatedDate: Date
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type FormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    formType?: boolean
    formName?: boolean
    formLink?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    formType?: boolean
    formName?: boolean
    formLink?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    formType?: boolean
    formName?: boolean
    formLink?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectScalar = {
    id?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    formType?: boolean
    formName?: boolean
    formLink?: boolean
    createdDate?: boolean
    updatedDate?: boolean
  }

  export type FormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "formId" | "createdAt" | "updatedAt" | "personalId" | "formType" | "formName" | "formLink" | "createdDate" | "updatedDate", ExtArgs["result"]["form"]>
  export type FormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type FormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type FormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $FormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Form"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      formType: $Enums.FormType
      formName: string
      formLink: string
      createdDate: Date
      updatedDate: Date
    }, ExtArgs["result"]["form"]>
    composites: {}
  }

  type FormGetPayload<S extends boolean | null | undefined | FormDefaultArgs> = $Result.GetResult<Prisma.$FormPayload, S>

  type FormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormCountAggregateInputType | true
    }

  export interface FormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Form'], meta: { name: 'Form' } }
    /**
     * Find zero or one Form that matches the filter.
     * @param {FormFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFindUniqueArgs>(args: SelectSubset<T, FormFindUniqueArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Form that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFindFirstArgs>(args?: SelectSubset<T, FormFindFirstArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFindManyArgs>(args?: SelectSubset<T, FormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Form.
     * @param {FormCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
     */
    create<T extends FormCreateArgs>(args: SelectSubset<T, FormCreateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Forms.
     * @param {FormCreateManyArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormCreateManyArgs>(args?: SelectSubset<T, FormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Forms and returns the data saved in the database.
     * @param {FormCreateManyAndReturnArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Forms and only return the `id`
     * const formWithIdOnly = await prisma.form.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormCreateManyAndReturnArgs>(args?: SelectSubset<T, FormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Form.
     * @param {FormDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
     */
    delete<T extends FormDeleteArgs>(args: SelectSubset<T, FormDeleteArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Form.
     * @param {FormUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormUpdateArgs>(args: SelectSubset<T, FormUpdateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Forms.
     * @param {FormDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormDeleteManyArgs>(args?: SelectSubset<T, FormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormUpdateManyArgs>(args: SelectSubset<T, FormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms and returns the data updated in the database.
     * @param {FormUpdateManyAndReturnArgs} args - Arguments to update many Forms.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Forms and only return the `id`
     * const formWithIdOnly = await prisma.form.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormUpdateManyAndReturnArgs>(args: SelectSubset<T, FormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Form.
     * @param {FormUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
     */
    upsert<T extends FormUpsertArgs>(args: SelectSubset<T, FormUpsertArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormCountArgs>(
      args?: Subset<T, FormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): Prisma.PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Form model
   */
  readonly fields: FormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Form model
   */
  interface FormFieldRefs {
    readonly id: FieldRef<"Form", 'String'>
    readonly formId: FieldRef<"Form", 'String'>
    readonly createdAt: FieldRef<"Form", 'DateTime'>
    readonly updatedAt: FieldRef<"Form", 'DateTime'>
    readonly personalId: FieldRef<"Form", 'String'>
    readonly formType: FieldRef<"Form", 'FormType'>
    readonly formName: FieldRef<"Form", 'String'>
    readonly formLink: FieldRef<"Form", 'String'>
    readonly createdDate: FieldRef<"Form", 'DateTime'>
    readonly updatedDate: FieldRef<"Form", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Form findUnique
   */
  export type FormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findUniqueOrThrow
   */
  export type FormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findFirst
   */
  export type FormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findFirstOrThrow
   */
  export type FormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findMany
   */
  export type FormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form create
   */
  export type FormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to create a Form.
     */
    data: XOR<FormCreateInput, FormUncheckedCreateInput>
  }

  /**
   * Form createMany
   */
  export type FormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Form createManyAndReturn
   */
  export type FormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Form update
   */
  export type FormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to update a Form.
     */
    data: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    /**
     * Choose, which Form to update.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form updateMany
   */
  export type FormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to update.
     */
    limit?: number
  }

  /**
   * Form updateManyAndReturn
   */
  export type FormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Form upsert
   */
  export type FormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The filter to search for the Form to update in case it exists.
     */
    where: FormWhereUniqueInput
    /**
     * In case the Form found by the `where` argument doesn't exist, create a new Form with this data.
     */
    create: XOR<FormCreateInput, FormUncheckedCreateInput>
    /**
     * In case the Form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormUpdateInput, FormUncheckedUpdateInput>
  }

  /**
   * Form delete
   */
  export type FormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter which Form to delete.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form deleteMany
   */
  export type FormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to delete
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to delete.
     */
    limit?: number
  }

  /**
   * Form without action
   */
  export type FormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
  }


  /**
   * Model CustomForm
   */

  export type AggregateCustomForm = {
    _count: CustomFormCountAggregateOutputType | null
    _min: CustomFormMinAggregateOutputType | null
    _max: CustomFormMaxAggregateOutputType | null
  }

  export type CustomFormMinAggregateOutputType = {
    id: string | null
    customFormId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    formTemplate: string | null
    formName: string | null
    createdDate: Date | null
    updatedDate: Date | null
  }

  export type CustomFormMaxAggregateOutputType = {
    id: string | null
    customFormId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    personalId: string | null
    formTemplate: string | null
    formName: string | null
    createdDate: Date | null
    updatedDate: Date | null
  }

  export type CustomFormCountAggregateOutputType = {
    id: number
    customFormId: number
    createdAt: number
    updatedAt: number
    personalId: number
    formTemplate: number
    formName: number
    createdDate: number
    updatedDate: number
    _all: number
  }


  export type CustomFormMinAggregateInputType = {
    id?: true
    customFormId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    formTemplate?: true
    formName?: true
    createdDate?: true
    updatedDate?: true
  }

  export type CustomFormMaxAggregateInputType = {
    id?: true
    customFormId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    formTemplate?: true
    formName?: true
    createdDate?: true
    updatedDate?: true
  }

  export type CustomFormCountAggregateInputType = {
    id?: true
    customFormId?: true
    createdAt?: true
    updatedAt?: true
    personalId?: true
    formTemplate?: true
    formName?: true
    createdDate?: true
    updatedDate?: true
    _all?: true
  }

  export type CustomFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomForm to aggregate.
     */
    where?: CustomFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomForms to fetch.
     */
    orderBy?: CustomFormOrderByWithRelationInput | CustomFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomForms
    **/
    _count?: true | CustomFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFormMaxAggregateInputType
  }

  export type GetCustomFormAggregateType<T extends CustomFormAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomForm[P]>
      : GetScalarType<T[P], AggregateCustomForm[P]>
  }




  export type CustomFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFormWhereInput
    orderBy?: CustomFormOrderByWithAggregationInput | CustomFormOrderByWithAggregationInput[]
    by: CustomFormScalarFieldEnum[] | CustomFormScalarFieldEnum
    having?: CustomFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFormCountAggregateInputType | true
    _min?: CustomFormMinAggregateInputType
    _max?: CustomFormMaxAggregateInputType
  }

  export type CustomFormGroupByOutputType = {
    id: string
    customFormId: string
    createdAt: Date
    updatedAt: Date
    personalId: string
    formTemplate: string
    formName: string
    createdDate: Date
    updatedDate: Date
    _count: CustomFormCountAggregateOutputType | null
    _min: CustomFormMinAggregateOutputType | null
    _max: CustomFormMaxAggregateOutputType | null
  }

  type GetCustomFormGroupByPayload<T extends CustomFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFormGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFormGroupByOutputType[P]>
        }
      >
    >


  export type CustomFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customFormId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    formTemplate?: boolean
    formName?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customForm"]>

  export type CustomFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customFormId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    formTemplate?: boolean
    formName?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customForm"]>

  export type CustomFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customFormId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    formTemplate?: boolean
    formName?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customForm"]>

  export type CustomFormSelectScalar = {
    id?: boolean
    customFormId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalId?: boolean
    formTemplate?: boolean
    formName?: boolean
    createdDate?: boolean
    updatedDate?: boolean
  }

  export type CustomFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customFormId" | "createdAt" | "updatedAt" | "personalId" | "formTemplate" | "formName" | "createdDate" | "updatedDate", ExtArgs["result"]["customForm"]>
  export type CustomFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type CustomFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }
  export type CustomFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | PersonalDetailsDefaultArgs<ExtArgs>
  }

  export type $CustomFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomForm"
    objects: {
      personalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customFormId: string
      createdAt: Date
      updatedAt: Date
      personalId: string
      formTemplate: string
      formName: string
      createdDate: Date
      updatedDate: Date
    }, ExtArgs["result"]["customForm"]>
    composites: {}
  }

  type CustomFormGetPayload<S extends boolean | null | undefined | CustomFormDefaultArgs> = $Result.GetResult<Prisma.$CustomFormPayload, S>

  type CustomFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomFormCountAggregateInputType | true
    }

  export interface CustomFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomForm'], meta: { name: 'CustomForm' } }
    /**
     * Find zero or one CustomForm that matches the filter.
     * @param {CustomFormFindUniqueArgs} args - Arguments to find a CustomForm
     * @example
     * // Get one CustomForm
     * const customForm = await prisma.customForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomFormFindUniqueArgs>(args: SelectSubset<T, CustomFormFindUniqueArgs<ExtArgs>>): Prisma__CustomFormClient<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomFormFindUniqueOrThrowArgs} args - Arguments to find a CustomForm
     * @example
     * // Get one CustomForm
     * const customForm = await prisma.customForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomFormFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomFormClient<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFormFindFirstArgs} args - Arguments to find a CustomForm
     * @example
     * // Get one CustomForm
     * const customForm = await prisma.customForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomFormFindFirstArgs>(args?: SelectSubset<T, CustomFormFindFirstArgs<ExtArgs>>): Prisma__CustomFormClient<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFormFindFirstOrThrowArgs} args - Arguments to find a CustomForm
     * @example
     * // Get one CustomForm
     * const customForm = await prisma.customForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomFormFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomFormClient<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomForms
     * const customForms = await prisma.customForm.findMany()
     * 
     * // Get first 10 CustomForms
     * const customForms = await prisma.customForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFormWithIdOnly = await prisma.customForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomFormFindManyArgs>(args?: SelectSubset<T, CustomFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomForm.
     * @param {CustomFormCreateArgs} args - Arguments to create a CustomForm.
     * @example
     * // Create one CustomForm
     * const CustomForm = await prisma.customForm.create({
     *   data: {
     *     // ... data to create a CustomForm
     *   }
     * })
     * 
     */
    create<T extends CustomFormCreateArgs>(args: SelectSubset<T, CustomFormCreateArgs<ExtArgs>>): Prisma__CustomFormClient<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomForms.
     * @param {CustomFormCreateManyArgs} args - Arguments to create many CustomForms.
     * @example
     * // Create many CustomForms
     * const customForm = await prisma.customForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomFormCreateManyArgs>(args?: SelectSubset<T, CustomFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomForms and returns the data saved in the database.
     * @param {CustomFormCreateManyAndReturnArgs} args - Arguments to create many CustomForms.
     * @example
     * // Create many CustomForms
     * const customForm = await prisma.customForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomForms and only return the `id`
     * const customFormWithIdOnly = await prisma.customForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomFormCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomForm.
     * @param {CustomFormDeleteArgs} args - Arguments to delete one CustomForm.
     * @example
     * // Delete one CustomForm
     * const CustomForm = await prisma.customForm.delete({
     *   where: {
     *     // ... filter to delete one CustomForm
     *   }
     * })
     * 
     */
    delete<T extends CustomFormDeleteArgs>(args: SelectSubset<T, CustomFormDeleteArgs<ExtArgs>>): Prisma__CustomFormClient<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomForm.
     * @param {CustomFormUpdateArgs} args - Arguments to update one CustomForm.
     * @example
     * // Update one CustomForm
     * const customForm = await prisma.customForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomFormUpdateArgs>(args: SelectSubset<T, CustomFormUpdateArgs<ExtArgs>>): Prisma__CustomFormClient<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomForms.
     * @param {CustomFormDeleteManyArgs} args - Arguments to filter CustomForms to delete.
     * @example
     * // Delete a few CustomForms
     * const { count } = await prisma.customForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomFormDeleteManyArgs>(args?: SelectSubset<T, CustomFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomForms
     * const customForm = await prisma.customForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomFormUpdateManyArgs>(args: SelectSubset<T, CustomFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomForms and returns the data updated in the database.
     * @param {CustomFormUpdateManyAndReturnArgs} args - Arguments to update many CustomForms.
     * @example
     * // Update many CustomForms
     * const customForm = await prisma.customForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomForms and only return the `id`
     * const customFormWithIdOnly = await prisma.customForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomFormUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomForm.
     * @param {CustomFormUpsertArgs} args - Arguments to update or create a CustomForm.
     * @example
     * // Update or create a CustomForm
     * const customForm = await prisma.customForm.upsert({
     *   create: {
     *     // ... data to create a CustomForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomForm we want to update
     *   }
     * })
     */
    upsert<T extends CustomFormUpsertArgs>(args: SelectSubset<T, CustomFormUpsertArgs<ExtArgs>>): Prisma__CustomFormClient<$Result.GetResult<Prisma.$CustomFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFormCountArgs} args - Arguments to filter CustomForms to count.
     * @example
     * // Count the number of CustomForms
     * const count = await prisma.customForm.count({
     *   where: {
     *     // ... the filter for the CustomForms we want to count
     *   }
     * })
    **/
    count<T extends CustomFormCountArgs>(
      args?: Subset<T, CustomFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFormAggregateArgs>(args: Subset<T, CustomFormAggregateArgs>): Prisma.PrismaPromise<GetCustomFormAggregateType<T>>

    /**
     * Group by CustomForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFormGroupByArgs['orderBy'] }
        : { orderBy?: CustomFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomForm model
   */
  readonly fields: CustomFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends PersonalDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalDetailsDefaultArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomForm model
   */
  interface CustomFormFieldRefs {
    readonly id: FieldRef<"CustomForm", 'String'>
    readonly customFormId: FieldRef<"CustomForm", 'String'>
    readonly createdAt: FieldRef<"CustomForm", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomForm", 'DateTime'>
    readonly personalId: FieldRef<"CustomForm", 'String'>
    readonly formTemplate: FieldRef<"CustomForm", 'String'>
    readonly formName: FieldRef<"CustomForm", 'String'>
    readonly createdDate: FieldRef<"CustomForm", 'DateTime'>
    readonly updatedDate: FieldRef<"CustomForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomForm findUnique
   */
  export type CustomFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * Filter, which CustomForm to fetch.
     */
    where: CustomFormWhereUniqueInput
  }

  /**
   * CustomForm findUniqueOrThrow
   */
  export type CustomFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * Filter, which CustomForm to fetch.
     */
    where: CustomFormWhereUniqueInput
  }

  /**
   * CustomForm findFirst
   */
  export type CustomFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * Filter, which CustomForm to fetch.
     */
    where?: CustomFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomForms to fetch.
     */
    orderBy?: CustomFormOrderByWithRelationInput | CustomFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomForms.
     */
    cursor?: CustomFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomForms.
     */
    distinct?: CustomFormScalarFieldEnum | CustomFormScalarFieldEnum[]
  }

  /**
   * CustomForm findFirstOrThrow
   */
  export type CustomFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * Filter, which CustomForm to fetch.
     */
    where?: CustomFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomForms to fetch.
     */
    orderBy?: CustomFormOrderByWithRelationInput | CustomFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomForms.
     */
    cursor?: CustomFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomForms.
     */
    distinct?: CustomFormScalarFieldEnum | CustomFormScalarFieldEnum[]
  }

  /**
   * CustomForm findMany
   */
  export type CustomFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * Filter, which CustomForms to fetch.
     */
    where?: CustomFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomForms to fetch.
     */
    orderBy?: CustomFormOrderByWithRelationInput | CustomFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomForms.
     */
    cursor?: CustomFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomForms.
     */
    skip?: number
    distinct?: CustomFormScalarFieldEnum | CustomFormScalarFieldEnum[]
  }

  /**
   * CustomForm create
   */
  export type CustomFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomForm.
     */
    data: XOR<CustomFormCreateInput, CustomFormUncheckedCreateInput>
  }

  /**
   * CustomForm createMany
   */
  export type CustomFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomForms.
     */
    data: CustomFormCreateManyInput | CustomFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomForm createManyAndReturn
   */
  export type CustomFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * The data used to create many CustomForms.
     */
    data: CustomFormCreateManyInput | CustomFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomForm update
   */
  export type CustomFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomForm.
     */
    data: XOR<CustomFormUpdateInput, CustomFormUncheckedUpdateInput>
    /**
     * Choose, which CustomForm to update.
     */
    where: CustomFormWhereUniqueInput
  }

  /**
   * CustomForm updateMany
   */
  export type CustomFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomForms.
     */
    data: XOR<CustomFormUpdateManyMutationInput, CustomFormUncheckedUpdateManyInput>
    /**
     * Filter which CustomForms to update
     */
    where?: CustomFormWhereInput
    /**
     * Limit how many CustomForms to update.
     */
    limit?: number
  }

  /**
   * CustomForm updateManyAndReturn
   */
  export type CustomFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * The data used to update CustomForms.
     */
    data: XOR<CustomFormUpdateManyMutationInput, CustomFormUncheckedUpdateManyInput>
    /**
     * Filter which CustomForms to update
     */
    where?: CustomFormWhereInput
    /**
     * Limit how many CustomForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomForm upsert
   */
  export type CustomFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomForm to update in case it exists.
     */
    where: CustomFormWhereUniqueInput
    /**
     * In case the CustomForm found by the `where` argument doesn't exist, create a new CustomForm with this data.
     */
    create: XOR<CustomFormCreateInput, CustomFormUncheckedCreateInput>
    /**
     * In case the CustomForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFormUpdateInput, CustomFormUncheckedUpdateInput>
  }

  /**
   * CustomForm delete
   */
  export type CustomFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
    /**
     * Filter which CustomForm to delete.
     */
    where: CustomFormWhereUniqueInput
  }

  /**
   * CustomForm deleteMany
   */
  export type CustomFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomForms to delete
     */
    where?: CustomFormWhereInput
    /**
     * Limit how many CustomForms to delete.
     */
    limit?: number
  }

  /**
   * CustomForm without action
   */
  export type CustomFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomForm
     */
    select?: CustomFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomForm
     */
    omit?: CustomFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFormInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    displayName: 'displayName',
    emailVerified: 'emailVerified',
    profileImage: 'profileImage',
    phoneNumber: 'phoneNumber',
    firebaseUid: 'firebaseUid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    roleId: 'roleId',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const ChildScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    birthDate: 'birthDate',
    birthPlace: 'birthPlace',
    nationality: 'nationality',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    analysisFormId: 'analysisFormId'
  };

  export type ChildScalarFieldEnum = (typeof ChildScalarFieldEnum)[keyof typeof ChildScalarFieldEnum]


  export const ApplicantScalarFieldEnum: {
    id: 'id',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    salutation: 'salutation',
    title: 'title',
    firstName: 'firstName',
    lastName: 'lastName',
    maidenName: 'maidenName',
    birthDate: 'birthDate',
    birthPlace: 'birthPlace',
    birthCountry: 'birthCountry',
    nationality: 'nationality',
    isEUCitizen: 'isEUCitizen',
    residencePermit: 'residencePermit',
    inGermanySince: 'inGermanySince',
    street: 'street',
    houseNumber: 'houseNumber',
    postalCode: 'postalCode',
    city: 'city',
    residentSince: 'residentSince',
    previousAddress: 'previousAddress',
    phoneLandline: 'phoneLandline',
    phoneMobile: 'phoneMobile',
    email: 'email',
    taxId: 'taxId',
    maritalStatus: 'maritalStatus',
    separationOfGoods: 'separationOfGoods',
    numberOfChildren: 'numberOfChildren',
    childrenBirthDates: 'childrenBirthDates',
    profession: 'profession',
    employmentType: 'employmentType',
    employedSince: 'employedSince',
    contractType: 'contractType',
    contractUntil: 'contractUntil',
    employerName: 'employerName',
    employerInGermany: 'employerInGermany',
    netIncome: 'netIncome',
    grossIncome: 'grossIncome',
    numberOfSalaries: 'numberOfSalaries',
    childBenefit: 'childBenefit',
    otherIncome: 'otherIncome',
    iban: 'iban',
    bic: 'bic',
    analysisFormId: 'analysisFormId',
    immobillionFormId: 'immobillionFormId'
  };

  export type ApplicantScalarFieldEnum = (typeof ApplicantScalarFieldEnum)[keyof typeof ApplicantScalarFieldEnum]


  export const ImmobillionApplicantDetailsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    applicantId: 'applicantId',
    salaryCurrency: 'salaryCurrency',
    salaryCurrencyOther: 'salaryCurrencyOther',
    hasPartTimeJob: 'hasPartTimeJob',
    partTimeSince: 'partTimeSince',
    isFreelancer: 'isFreelancer',
    isSelfEmployed: 'isSelfEmployed',
    selfEmployedAs: 'selfEmployedAs',
    selfEmployedSince: 'selfEmployedSince',
    selfEmployedCompany: 'selfEmployedCompany',
    vehiclesInHousehold: 'vehiclesInHousehold',
    retirementStart: 'retirementStart',
    statutoryPension: 'statutoryPension',
    privatePension: 'privatePension',
    interpreterRequired: 'interpreterRequired',
    monthlyIncome: 'monthlyIncome',
    monthlyExpenses: 'monthlyExpenses',
    assets: 'assets',
    liabilities: 'liabilities'
  };

  export type ImmobillionApplicantDetailsScalarFieldEnum = (typeof ImmobillionApplicantDetailsScalarFieldEnum)[keyof typeof ImmobillionApplicantDetailsScalarFieldEnum]


  export const ImmobillionFormScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    formType: 'formType',
    formVersion: 'formVersion'
  };

  export type ImmobillionFormScalarFieldEnum = (typeof ImmobillionFormScalarFieldEnum)[keyof typeof ImmobillionFormScalarFieldEnum]


  export const AnalysisFormScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    consultantName: 'consultantName',
    officeLocation: 'officeLocation',
    analysisDate: 'analysisDate',
    coldRent: 'coldRent',
    gas: 'gas',
    electricity: 'electricity',
    telecommunication: 'telecommunication',
    subscriptions: 'subscriptions',
    accountMaintenanceFee: 'accountMaintenanceFee',
    livingExpenses: 'livingExpenses',
    alimony: 'alimony',
    otherExpenses: 'otherExpenses',
    addLoanOrLeasing: 'addLoanOrLeasing',
    loanBank: 'loanBank',
    loanAmount: 'loanAmount',
    loanMonthlyRate: 'loanMonthlyRate',
    loanInterest: 'loanInterest',
    analysisConsent: 'analysisConsent',
    analysisConsentText: 'analysisConsentText',
    analysisConsentSignature: 'analysisConsentSignature',
    analysisLocation: 'analysisLocation',
    analysisConsentDate: 'analysisConsentDate'
  };

  export type AnalysisFormScalarFieldEnum = (typeof AnalysisFormScalarFieldEnum)[keyof typeof AnalysisFormScalarFieldEnum]


  export const PersonalDetailsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    coachId: 'coachId',
    applicantType: 'applicantType',
    firstName: 'firstName',
    lastName: 'lastName',
    streetAddress: 'streetAddress',
    postalCode: 'postalCode',
    city: 'city',
    phone: 'phone',
    email: 'email',
    birthDate: 'birthDate',
    birthPlace: 'birthPlace',
    maritalStatus: 'maritalStatus',
    nationality: 'nationality',
    housing: 'housing'
  };

  export type PersonalDetailsScalarFieldEnum = (typeof PersonalDetailsScalarFieldEnum)[keyof typeof PersonalDetailsScalarFieldEnum]


  export const EmploymentDetailsScalarFieldEnum: {
    id: 'id',
    employmentId: 'employmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    employmentType: 'employmentType',
    occupation: 'occupation',
    contractType: 'contractType',
    contractDuration: 'contractDuration',
    employerName: 'employerName',
    employedSince: 'employedSince'
  };

  export type EmploymentDetailsScalarFieldEnum = (typeof EmploymentDetailsScalarFieldEnum)[keyof typeof EmploymentDetailsScalarFieldEnum]


  export const IncomeDetailsScalarFieldEnum: {
    id: 'id',
    incomeId: 'incomeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    grossIncome: 'grossIncome',
    netIncome: 'netIncome',
    taxClass: 'taxClass',
    taxId: 'taxId',
    numberOfSalaries: 'numberOfSalaries',
    childBenefit: 'childBenefit',
    otherIncome: 'otherIncome',
    incomeTradeBusiness: 'incomeTradeBusiness',
    incomeSelfEmployedWork: 'incomeSelfEmployedWork',
    incomeSideJob: 'incomeSideJob'
  };

  export type IncomeDetailsScalarFieldEnum = (typeof IncomeDetailsScalarFieldEnum)[keyof typeof IncomeDetailsScalarFieldEnum]


  export const ExpensesDetailsScalarFieldEnum: {
    id: 'id',
    expensesId: 'expensesId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    coldRent: 'coldRent',
    electricity: 'electricity',
    livingExpenses: 'livingExpenses',
    gas: 'gas',
    telecommunication: 'telecommunication',
    accountMaintenanceFee: 'accountMaintenanceFee',
    alimony: 'alimony',
    subscriptions: 'subscriptions',
    otherExpenses: 'otherExpenses'
  };

  export type ExpensesDetailsScalarFieldEnum = (typeof ExpensesDetailsScalarFieldEnum)[keyof typeof ExpensesDetailsScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    realEstate: 'realEstate',
    securities: 'securities',
    bankDeposits: 'bankDeposits',
    buildingSavings: 'buildingSavings',
    insuranceValues: 'insuranceValues',
    otherAssets: 'otherAssets'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const LiabilityScalarFieldEnum: {
    id: 'id',
    liabilityId: 'liabilityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    loanType: 'loanType',
    loanBank: 'loanBank',
    loanAmount: 'loanAmount',
    loanMonthlyRate: 'loanMonthlyRate',
    loanInterest: 'loanInterest'
  };

  export type LiabilityScalarFieldEnum = (typeof LiabilityScalarFieldEnum)[keyof typeof LiabilityScalarFieldEnum]


  export const GoalsAndWishesScalarFieldEnum: {
    id: 'id',
    goalsAndWishesId: 'goalsAndWishesId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    retirementPlanning: 'retirementPlanning',
    capitalFormation: 'capitalFormation',
    realEstateGoals: 'realEstateGoals',
    financing: 'financing',
    protection: 'protection',
    healthcareProvision: 'healthcareProvision',
    otherGoals: 'otherGoals'
  };

  export type GoalsAndWishesScalarFieldEnum = (typeof GoalsAndWishesScalarFieldEnum)[keyof typeof GoalsAndWishesScalarFieldEnum]


  export const RiskAppetiteScalarFieldEnum: {
    id: 'id',
    riskAppetiteId: 'riskAppetiteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    riskAppetite: 'riskAppetite',
    investmentHorizon: 'investmentHorizon',
    knowledgeExperience: 'knowledgeExperience',
    healthInsurance: 'healthInsurance',
    healthInsuranceNumber: 'healthInsuranceNumber',
    healthInsuranceProof: 'healthInsuranceProof'
  };

  export type RiskAppetiteScalarFieldEnum = (typeof RiskAppetiteScalarFieldEnum)[keyof typeof RiskAppetiteScalarFieldEnum]


  export const ConsentScalarFieldEnum: {
    id: 'id',
    consentId: 'consentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    consentType: 'consentType',
    consent: 'consent',
    consentText: 'consentText',
    consentSignature: 'consentSignature',
    consentDate: 'consentDate',
    location: 'location'
  };

  export type ConsentScalarFieldEnum = (typeof ConsentScalarFieldEnum)[keyof typeof ConsentScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    documentName: 'documentName',
    documentLocation: 'documentLocation',
    documentDate: 'documentDate'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    formType: 'formType',
    formName: 'formName',
    formLink: 'formLink',
    createdDate: 'createdDate',
    updatedDate: 'updatedDate'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const CustomFormScalarFieldEnum: {
    id: 'id',
    customFormId: 'customFormId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalId: 'personalId',
    formTemplate: 'formTemplate',
    formName: 'formName',
    createdDate: 'createdDate',
    updatedDate: 'updatedDate'
  };

  export type CustomFormScalarFieldEnum = (typeof CustomFormScalarFieldEnum)[keyof typeof CustomFormScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ApplicantType'
   */
  export type EnumApplicantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicantType'>
    


  /**
   * Reference to a field of type 'ApplicantType[]'
   */
  export type ListEnumApplicantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicantType[]'>
    


  /**
   * Reference to a field of type 'EmploymentType'
   */
  export type EnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType'>
    


  /**
   * Reference to a field of type 'EmploymentType[]'
   */
  export type ListEnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType[]'>
    


  /**
   * Reference to a field of type 'LoanType'
   */
  export type EnumLoanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanType'>
    


  /**
   * Reference to a field of type 'LoanType[]'
   */
  export type ListEnumLoanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoanType[]'>
    


  /**
   * Reference to a field of type 'ConsentType'
   */
  export type EnumConsentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentType'>
    


  /**
   * Reference to a field of type 'ConsentType[]'
   */
  export type ListEnumConsentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentType[]'>
    


  /**
   * Reference to a field of type 'FormType'
   */
  export type EnumFormTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormType'>
    


  /**
   * Reference to a field of type 'FormType[]'
   */
  export type ListEnumFormTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    profileImage?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    firebaseUid?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: StringFilter<"User"> | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    analysisForms?: AnalysisFormListRelationFilter
    immobillionForms?: ImmobillionFormListRelationFilter
    personalDetails?: XOR<PersonalDetailsNullableScalarRelationFilter, PersonalDetailsWhereInput> | null
    clientsAsCoach?: PersonalDetailsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    firebaseUid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    role?: RoleOrderByWithRelationInput
    analysisForms?: AnalysisFormOrderByRelationAggregateInput
    immobillionForms?: ImmobillionFormOrderByRelationAggregateInput
    personalDetails?: PersonalDetailsOrderByWithRelationInput
    clientsAsCoach?: PersonalDetailsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    profileImage?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    firebaseUid?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: StringFilter<"User"> | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    analysisForms?: AnalysisFormListRelationFilter
    immobillionForms?: ImmobillionFormListRelationFilter
    personalDetails?: XOR<PersonalDetailsNullableScalarRelationFilter, PersonalDetailsWhereInput> | null
    clientsAsCoach?: PersonalDetailsListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    firebaseUid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    firebaseUid?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    roleId?: StringWithAggregatesFilter<"User"> | string
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: StringNullableListFilter<"Role">
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: StringNullableListFilter<"Role">
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    permissions?: StringNullableListFilter<"Role">
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type ChildWhereInput = {
    AND?: ChildWhereInput | ChildWhereInput[]
    OR?: ChildWhereInput[]
    NOT?: ChildWhereInput | ChildWhereInput[]
    id?: StringFilter<"Child"> | string
    firstName?: StringFilter<"Child"> | string
    lastName?: StringFilter<"Child"> | string
    birthDate?: DateTimeFilter<"Child"> | Date | string
    birthPlace?: StringFilter<"Child"> | string
    nationality?: StringFilter<"Child"> | string
    createdAt?: DateTimeFilter<"Child"> | Date | string
    updatedAt?: DateTimeFilter<"Child"> | Date | string
    analysisFormId?: StringFilter<"Child"> | string
    analysisForm?: XOR<AnalysisFormScalarRelationFilter, AnalysisFormWhereInput>
  }

  export type ChildOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    nationality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analysisFormId?: SortOrder
    analysisForm?: AnalysisFormOrderByWithRelationInput
  }

  export type ChildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChildWhereInput | ChildWhereInput[]
    OR?: ChildWhereInput[]
    NOT?: ChildWhereInput | ChildWhereInput[]
    firstName?: StringFilter<"Child"> | string
    lastName?: StringFilter<"Child"> | string
    birthDate?: DateTimeFilter<"Child"> | Date | string
    birthPlace?: StringFilter<"Child"> | string
    nationality?: StringFilter<"Child"> | string
    createdAt?: DateTimeFilter<"Child"> | Date | string
    updatedAt?: DateTimeFilter<"Child"> | Date | string
    analysisFormId?: StringFilter<"Child"> | string
    analysisForm?: XOR<AnalysisFormScalarRelationFilter, AnalysisFormWhereInput>
  }, "id">

  export type ChildOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    nationality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analysisFormId?: SortOrder
    _count?: ChildCountOrderByAggregateInput
    _max?: ChildMaxOrderByAggregateInput
    _min?: ChildMinOrderByAggregateInput
  }

  export type ChildScalarWhereWithAggregatesInput = {
    AND?: ChildScalarWhereWithAggregatesInput | ChildScalarWhereWithAggregatesInput[]
    OR?: ChildScalarWhereWithAggregatesInput[]
    NOT?: ChildScalarWhereWithAggregatesInput | ChildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Child"> | string
    firstName?: StringWithAggregatesFilter<"Child"> | string
    lastName?: StringWithAggregatesFilter<"Child"> | string
    birthDate?: DateTimeWithAggregatesFilter<"Child"> | Date | string
    birthPlace?: StringWithAggregatesFilter<"Child"> | string
    nationality?: StringWithAggregatesFilter<"Child"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Child"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Child"> | Date | string
    analysisFormId?: StringWithAggregatesFilter<"Child"> | string
  }

  export type ApplicantWhereInput = {
    AND?: ApplicantWhereInput | ApplicantWhereInput[]
    OR?: ApplicantWhereInput[]
    NOT?: ApplicantWhereInput | ApplicantWhereInput[]
    id?: StringFilter<"Applicant"> | string
    type?: StringFilter<"Applicant"> | string
    createdAt?: DateTimeFilter<"Applicant"> | Date | string
    updatedAt?: DateTimeFilter<"Applicant"> | Date | string
    salutation?: StringNullableFilter<"Applicant"> | string | null
    title?: StringNullableFilter<"Applicant"> | string | null
    firstName?: StringFilter<"Applicant"> | string
    lastName?: StringFilter<"Applicant"> | string
    maidenName?: StringNullableFilter<"Applicant"> | string | null
    birthDate?: DateTimeFilter<"Applicant"> | Date | string
    birthPlace?: StringFilter<"Applicant"> | string
    birthCountry?: StringNullableFilter<"Applicant"> | string | null
    nationality?: StringFilter<"Applicant"> | string
    isEUCitizen?: BoolNullableFilter<"Applicant"> | boolean | null
    residencePermit?: StringNullableFilter<"Applicant"> | string | null
    inGermanySince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    street?: StringFilter<"Applicant"> | string
    houseNumber?: StringNullableFilter<"Applicant"> | string | null
    postalCode?: StringFilter<"Applicant"> | string
    city?: StringFilter<"Applicant"> | string
    residentSince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    previousAddress?: JsonNullableFilter<"Applicant">
    phoneLandline?: StringNullableFilter<"Applicant"> | string | null
    phoneMobile?: StringFilter<"Applicant"> | string
    email?: StringFilter<"Applicant"> | string
    taxId?: StringNullableFilter<"Applicant"> | string | null
    maritalStatus?: StringFilter<"Applicant"> | string
    separationOfGoods?: BoolNullableFilter<"Applicant"> | boolean | null
    numberOfChildren?: IntFilter<"Applicant"> | number
    childrenBirthDates?: DateTimeNullableListFilter<"Applicant">
    profession?: StringFilter<"Applicant"> | string
    employmentType?: StringNullableFilter<"Applicant"> | string | null
    employedSince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    contractType?: StringFilter<"Applicant"> | string
    contractUntil?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    employerName?: StringNullableFilter<"Applicant"> | string | null
    employerInGermany?: BoolNullableFilter<"Applicant"> | boolean | null
    netIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFilter<"Applicant"> | number
    childBenefit?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    iban?: StringNullableFilter<"Applicant"> | string | null
    bic?: StringNullableFilter<"Applicant"> | string | null
    analysisFormId?: StringNullableFilter<"Applicant"> | string | null
    immobillionFormId?: StringNullableFilter<"Applicant"> | string | null
    analysisForm?: XOR<AnalysisFormNullableScalarRelationFilter, AnalysisFormWhereInput> | null
    immobillionForm?: XOR<ImmobillionFormNullableScalarRelationFilter, ImmobillionFormWhereInput> | null
    immobillionDetails?: XOR<ImmobillionApplicantDetailsNullableScalarRelationFilter, ImmobillionApplicantDetailsWhereInput> | null
  }

  export type ApplicantOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salutation?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    maidenName?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    birthCountry?: SortOrderInput | SortOrder
    nationality?: SortOrder
    isEUCitizen?: SortOrderInput | SortOrder
    residencePermit?: SortOrderInput | SortOrder
    inGermanySince?: SortOrderInput | SortOrder
    street?: SortOrder
    houseNumber?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    residentSince?: SortOrderInput | SortOrder
    previousAddress?: SortOrderInput | SortOrder
    phoneLandline?: SortOrderInput | SortOrder
    phoneMobile?: SortOrder
    email?: SortOrder
    taxId?: SortOrderInput | SortOrder
    maritalStatus?: SortOrder
    separationOfGoods?: SortOrderInput | SortOrder
    numberOfChildren?: SortOrder
    childrenBirthDates?: SortOrder
    profession?: SortOrder
    employmentType?: SortOrderInput | SortOrder
    employedSince?: SortOrderInput | SortOrder
    contractType?: SortOrder
    contractUntil?: SortOrderInput | SortOrder
    employerName?: SortOrderInput | SortOrder
    employerInGermany?: SortOrderInput | SortOrder
    netIncome?: SortOrder
    grossIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    iban?: SortOrderInput | SortOrder
    bic?: SortOrderInput | SortOrder
    analysisFormId?: SortOrderInput | SortOrder
    immobillionFormId?: SortOrderInput | SortOrder
    analysisForm?: AnalysisFormOrderByWithRelationInput
    immobillionForm?: ImmobillionFormOrderByWithRelationInput
    immobillionDetails?: ImmobillionApplicantDetailsOrderByWithRelationInput
  }

  export type ApplicantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApplicantWhereInput | ApplicantWhereInput[]
    OR?: ApplicantWhereInput[]
    NOT?: ApplicantWhereInput | ApplicantWhereInput[]
    type?: StringFilter<"Applicant"> | string
    createdAt?: DateTimeFilter<"Applicant"> | Date | string
    updatedAt?: DateTimeFilter<"Applicant"> | Date | string
    salutation?: StringNullableFilter<"Applicant"> | string | null
    title?: StringNullableFilter<"Applicant"> | string | null
    firstName?: StringFilter<"Applicant"> | string
    lastName?: StringFilter<"Applicant"> | string
    maidenName?: StringNullableFilter<"Applicant"> | string | null
    birthDate?: DateTimeFilter<"Applicant"> | Date | string
    birthPlace?: StringFilter<"Applicant"> | string
    birthCountry?: StringNullableFilter<"Applicant"> | string | null
    nationality?: StringFilter<"Applicant"> | string
    isEUCitizen?: BoolNullableFilter<"Applicant"> | boolean | null
    residencePermit?: StringNullableFilter<"Applicant"> | string | null
    inGermanySince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    street?: StringFilter<"Applicant"> | string
    houseNumber?: StringNullableFilter<"Applicant"> | string | null
    postalCode?: StringFilter<"Applicant"> | string
    city?: StringFilter<"Applicant"> | string
    residentSince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    previousAddress?: JsonNullableFilter<"Applicant">
    phoneLandline?: StringNullableFilter<"Applicant"> | string | null
    phoneMobile?: StringFilter<"Applicant"> | string
    email?: StringFilter<"Applicant"> | string
    taxId?: StringNullableFilter<"Applicant"> | string | null
    maritalStatus?: StringFilter<"Applicant"> | string
    separationOfGoods?: BoolNullableFilter<"Applicant"> | boolean | null
    numberOfChildren?: IntFilter<"Applicant"> | number
    childrenBirthDates?: DateTimeNullableListFilter<"Applicant">
    profession?: StringFilter<"Applicant"> | string
    employmentType?: StringNullableFilter<"Applicant"> | string | null
    employedSince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    contractType?: StringFilter<"Applicant"> | string
    contractUntil?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    employerName?: StringNullableFilter<"Applicant"> | string | null
    employerInGermany?: BoolNullableFilter<"Applicant"> | boolean | null
    netIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFilter<"Applicant"> | number
    childBenefit?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    iban?: StringNullableFilter<"Applicant"> | string | null
    bic?: StringNullableFilter<"Applicant"> | string | null
    analysisFormId?: StringNullableFilter<"Applicant"> | string | null
    immobillionFormId?: StringNullableFilter<"Applicant"> | string | null
    analysisForm?: XOR<AnalysisFormNullableScalarRelationFilter, AnalysisFormWhereInput> | null
    immobillionForm?: XOR<ImmobillionFormNullableScalarRelationFilter, ImmobillionFormWhereInput> | null
    immobillionDetails?: XOR<ImmobillionApplicantDetailsNullableScalarRelationFilter, ImmobillionApplicantDetailsWhereInput> | null
  }, "id">

  export type ApplicantOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salutation?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    maidenName?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    birthCountry?: SortOrderInput | SortOrder
    nationality?: SortOrder
    isEUCitizen?: SortOrderInput | SortOrder
    residencePermit?: SortOrderInput | SortOrder
    inGermanySince?: SortOrderInput | SortOrder
    street?: SortOrder
    houseNumber?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    residentSince?: SortOrderInput | SortOrder
    previousAddress?: SortOrderInput | SortOrder
    phoneLandline?: SortOrderInput | SortOrder
    phoneMobile?: SortOrder
    email?: SortOrder
    taxId?: SortOrderInput | SortOrder
    maritalStatus?: SortOrder
    separationOfGoods?: SortOrderInput | SortOrder
    numberOfChildren?: SortOrder
    childrenBirthDates?: SortOrder
    profession?: SortOrder
    employmentType?: SortOrderInput | SortOrder
    employedSince?: SortOrderInput | SortOrder
    contractType?: SortOrder
    contractUntil?: SortOrderInput | SortOrder
    employerName?: SortOrderInput | SortOrder
    employerInGermany?: SortOrderInput | SortOrder
    netIncome?: SortOrder
    grossIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    iban?: SortOrderInput | SortOrder
    bic?: SortOrderInput | SortOrder
    analysisFormId?: SortOrderInput | SortOrder
    immobillionFormId?: SortOrderInput | SortOrder
    _count?: ApplicantCountOrderByAggregateInput
    _avg?: ApplicantAvgOrderByAggregateInput
    _max?: ApplicantMaxOrderByAggregateInput
    _min?: ApplicantMinOrderByAggregateInput
    _sum?: ApplicantSumOrderByAggregateInput
  }

  export type ApplicantScalarWhereWithAggregatesInput = {
    AND?: ApplicantScalarWhereWithAggregatesInput | ApplicantScalarWhereWithAggregatesInput[]
    OR?: ApplicantScalarWhereWithAggregatesInput[]
    NOT?: ApplicantScalarWhereWithAggregatesInput | ApplicantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Applicant"> | string
    type?: StringWithAggregatesFilter<"Applicant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Applicant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Applicant"> | Date | string
    salutation?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    title?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    firstName?: StringWithAggregatesFilter<"Applicant"> | string
    lastName?: StringWithAggregatesFilter<"Applicant"> | string
    maidenName?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    birthDate?: DateTimeWithAggregatesFilter<"Applicant"> | Date | string
    birthPlace?: StringWithAggregatesFilter<"Applicant"> | string
    birthCountry?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    nationality?: StringWithAggregatesFilter<"Applicant"> | string
    isEUCitizen?: BoolNullableWithAggregatesFilter<"Applicant"> | boolean | null
    residencePermit?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    inGermanySince?: DateTimeNullableWithAggregatesFilter<"Applicant"> | Date | string | null
    street?: StringWithAggregatesFilter<"Applicant"> | string
    houseNumber?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    postalCode?: StringWithAggregatesFilter<"Applicant"> | string
    city?: StringWithAggregatesFilter<"Applicant"> | string
    residentSince?: DateTimeNullableWithAggregatesFilter<"Applicant"> | Date | string | null
    previousAddress?: JsonNullableWithAggregatesFilter<"Applicant">
    phoneLandline?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    phoneMobile?: StringWithAggregatesFilter<"Applicant"> | string
    email?: StringWithAggregatesFilter<"Applicant"> | string
    taxId?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    maritalStatus?: StringWithAggregatesFilter<"Applicant"> | string
    separationOfGoods?: BoolNullableWithAggregatesFilter<"Applicant"> | boolean | null
    numberOfChildren?: IntWithAggregatesFilter<"Applicant"> | number
    childrenBirthDates?: DateTimeNullableListFilter<"Applicant">
    profession?: StringWithAggregatesFilter<"Applicant"> | string
    employmentType?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    employedSince?: DateTimeNullableWithAggregatesFilter<"Applicant"> | Date | string | null
    contractType?: StringWithAggregatesFilter<"Applicant"> | string
    contractUntil?: DateTimeNullableWithAggregatesFilter<"Applicant"> | Date | string | null
    employerName?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    employerInGermany?: BoolNullableWithAggregatesFilter<"Applicant"> | boolean | null
    netIncome?: DecimalWithAggregatesFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalWithAggregatesFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntWithAggregatesFilter<"Applicant"> | number
    childBenefit?: DecimalWithAggregatesFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalWithAggregatesFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    iban?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    bic?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    analysisFormId?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    immobillionFormId?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
  }

  export type ImmobillionApplicantDetailsWhereInput = {
    AND?: ImmobillionApplicantDetailsWhereInput | ImmobillionApplicantDetailsWhereInput[]
    OR?: ImmobillionApplicantDetailsWhereInput[]
    NOT?: ImmobillionApplicantDetailsWhereInput | ImmobillionApplicantDetailsWhereInput[]
    id?: StringFilter<"ImmobillionApplicantDetails"> | string
    createdAt?: DateTimeFilter<"ImmobillionApplicantDetails"> | Date | string
    updatedAt?: DateTimeFilter<"ImmobillionApplicantDetails"> | Date | string
    applicantId?: StringFilter<"ImmobillionApplicantDetails"> | string
    salaryCurrency?: StringNullableFilter<"ImmobillionApplicantDetails"> | string | null
    salaryCurrencyOther?: StringNullableFilter<"ImmobillionApplicantDetails"> | string | null
    hasPartTimeJob?: BoolFilter<"ImmobillionApplicantDetails"> | boolean
    partTimeSince?: DateTimeNullableFilter<"ImmobillionApplicantDetails"> | Date | string | null
    isFreelancer?: BoolFilter<"ImmobillionApplicantDetails"> | boolean
    isSelfEmployed?: BoolFilter<"ImmobillionApplicantDetails"> | boolean
    selfEmployedAs?: StringNullableFilter<"ImmobillionApplicantDetails"> | string | null
    selfEmployedSince?: DateTimeNullableFilter<"ImmobillionApplicantDetails"> | Date | string | null
    selfEmployedCompany?: StringNullableFilter<"ImmobillionApplicantDetails"> | string | null
    vehiclesInHousehold?: IntFilter<"ImmobillionApplicantDetails"> | number
    retirementStart?: DateTimeNullableFilter<"ImmobillionApplicantDetails"> | Date | string | null
    statutoryPension?: DecimalNullableFilter<"ImmobillionApplicantDetails"> | Decimal | DecimalJsLike | number | string | null
    privatePension?: DecimalNullableFilter<"ImmobillionApplicantDetails"> | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolFilter<"ImmobillionApplicantDetails"> | boolean
    monthlyIncome?: JsonFilter<"ImmobillionApplicantDetails">
    monthlyExpenses?: JsonFilter<"ImmobillionApplicantDetails">
    assets?: JsonFilter<"ImmobillionApplicantDetails">
    liabilities?: JsonFilter<"ImmobillionApplicantDetails">
    applicant?: XOR<ApplicantScalarRelationFilter, ApplicantWhereInput>
  }

  export type ImmobillionApplicantDetailsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    salaryCurrency?: SortOrderInput | SortOrder
    salaryCurrencyOther?: SortOrderInput | SortOrder
    hasPartTimeJob?: SortOrder
    partTimeSince?: SortOrderInput | SortOrder
    isFreelancer?: SortOrder
    isSelfEmployed?: SortOrder
    selfEmployedAs?: SortOrderInput | SortOrder
    selfEmployedSince?: SortOrderInput | SortOrder
    selfEmployedCompany?: SortOrderInput | SortOrder
    vehiclesInHousehold?: SortOrder
    retirementStart?: SortOrderInput | SortOrder
    statutoryPension?: SortOrderInput | SortOrder
    privatePension?: SortOrderInput | SortOrder
    interpreterRequired?: SortOrder
    monthlyIncome?: SortOrder
    monthlyExpenses?: SortOrder
    assets?: SortOrder
    liabilities?: SortOrder
    applicant?: ApplicantOrderByWithRelationInput
  }

  export type ImmobillionApplicantDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicantId?: string
    AND?: ImmobillionApplicantDetailsWhereInput | ImmobillionApplicantDetailsWhereInput[]
    OR?: ImmobillionApplicantDetailsWhereInput[]
    NOT?: ImmobillionApplicantDetailsWhereInput | ImmobillionApplicantDetailsWhereInput[]
    createdAt?: DateTimeFilter<"ImmobillionApplicantDetails"> | Date | string
    updatedAt?: DateTimeFilter<"ImmobillionApplicantDetails"> | Date | string
    salaryCurrency?: StringNullableFilter<"ImmobillionApplicantDetails"> | string | null
    salaryCurrencyOther?: StringNullableFilter<"ImmobillionApplicantDetails"> | string | null
    hasPartTimeJob?: BoolFilter<"ImmobillionApplicantDetails"> | boolean
    partTimeSince?: DateTimeNullableFilter<"ImmobillionApplicantDetails"> | Date | string | null
    isFreelancer?: BoolFilter<"ImmobillionApplicantDetails"> | boolean
    isSelfEmployed?: BoolFilter<"ImmobillionApplicantDetails"> | boolean
    selfEmployedAs?: StringNullableFilter<"ImmobillionApplicantDetails"> | string | null
    selfEmployedSince?: DateTimeNullableFilter<"ImmobillionApplicantDetails"> | Date | string | null
    selfEmployedCompany?: StringNullableFilter<"ImmobillionApplicantDetails"> | string | null
    vehiclesInHousehold?: IntFilter<"ImmobillionApplicantDetails"> | number
    retirementStart?: DateTimeNullableFilter<"ImmobillionApplicantDetails"> | Date | string | null
    statutoryPension?: DecimalNullableFilter<"ImmobillionApplicantDetails"> | Decimal | DecimalJsLike | number | string | null
    privatePension?: DecimalNullableFilter<"ImmobillionApplicantDetails"> | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolFilter<"ImmobillionApplicantDetails"> | boolean
    monthlyIncome?: JsonFilter<"ImmobillionApplicantDetails">
    monthlyExpenses?: JsonFilter<"ImmobillionApplicantDetails">
    assets?: JsonFilter<"ImmobillionApplicantDetails">
    liabilities?: JsonFilter<"ImmobillionApplicantDetails">
    applicant?: XOR<ApplicantScalarRelationFilter, ApplicantWhereInput>
  }, "id" | "applicantId">

  export type ImmobillionApplicantDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    salaryCurrency?: SortOrderInput | SortOrder
    salaryCurrencyOther?: SortOrderInput | SortOrder
    hasPartTimeJob?: SortOrder
    partTimeSince?: SortOrderInput | SortOrder
    isFreelancer?: SortOrder
    isSelfEmployed?: SortOrder
    selfEmployedAs?: SortOrderInput | SortOrder
    selfEmployedSince?: SortOrderInput | SortOrder
    selfEmployedCompany?: SortOrderInput | SortOrder
    vehiclesInHousehold?: SortOrder
    retirementStart?: SortOrderInput | SortOrder
    statutoryPension?: SortOrderInput | SortOrder
    privatePension?: SortOrderInput | SortOrder
    interpreterRequired?: SortOrder
    monthlyIncome?: SortOrder
    monthlyExpenses?: SortOrder
    assets?: SortOrder
    liabilities?: SortOrder
    _count?: ImmobillionApplicantDetailsCountOrderByAggregateInput
    _avg?: ImmobillionApplicantDetailsAvgOrderByAggregateInput
    _max?: ImmobillionApplicantDetailsMaxOrderByAggregateInput
    _min?: ImmobillionApplicantDetailsMinOrderByAggregateInput
    _sum?: ImmobillionApplicantDetailsSumOrderByAggregateInput
  }

  export type ImmobillionApplicantDetailsScalarWhereWithAggregatesInput = {
    AND?: ImmobillionApplicantDetailsScalarWhereWithAggregatesInput | ImmobillionApplicantDetailsScalarWhereWithAggregatesInput[]
    OR?: ImmobillionApplicantDetailsScalarWhereWithAggregatesInput[]
    NOT?: ImmobillionApplicantDetailsScalarWhereWithAggregatesInput | ImmobillionApplicantDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImmobillionApplicantDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ImmobillionApplicantDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImmobillionApplicantDetails"> | Date | string
    applicantId?: StringWithAggregatesFilter<"ImmobillionApplicantDetails"> | string
    salaryCurrency?: StringNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | string | null
    salaryCurrencyOther?: StringNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | string | null
    hasPartTimeJob?: BoolWithAggregatesFilter<"ImmobillionApplicantDetails"> | boolean
    partTimeSince?: DateTimeNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | Date | string | null
    isFreelancer?: BoolWithAggregatesFilter<"ImmobillionApplicantDetails"> | boolean
    isSelfEmployed?: BoolWithAggregatesFilter<"ImmobillionApplicantDetails"> | boolean
    selfEmployedAs?: StringNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | string | null
    selfEmployedSince?: DateTimeNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | Date | string | null
    selfEmployedCompany?: StringNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | string | null
    vehiclesInHousehold?: IntWithAggregatesFilter<"ImmobillionApplicantDetails"> | number
    retirementStart?: DateTimeNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | Date | string | null
    statutoryPension?: DecimalNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | Decimal | DecimalJsLike | number | string | null
    privatePension?: DecimalNullableWithAggregatesFilter<"ImmobillionApplicantDetails"> | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolWithAggregatesFilter<"ImmobillionApplicantDetails"> | boolean
    monthlyIncome?: JsonWithAggregatesFilter<"ImmobillionApplicantDetails">
    monthlyExpenses?: JsonWithAggregatesFilter<"ImmobillionApplicantDetails">
    assets?: JsonWithAggregatesFilter<"ImmobillionApplicantDetails">
    liabilities?: JsonWithAggregatesFilter<"ImmobillionApplicantDetails">
  }

  export type ImmobillionFormWhereInput = {
    AND?: ImmobillionFormWhereInput | ImmobillionFormWhereInput[]
    OR?: ImmobillionFormWhereInput[]
    NOT?: ImmobillionFormWhereInput | ImmobillionFormWhereInput[]
    id?: StringFilter<"ImmobillionForm"> | string
    status?: StringFilter<"ImmobillionForm"> | string
    createdAt?: DateTimeFilter<"ImmobillionForm"> | Date | string
    updatedAt?: DateTimeFilter<"ImmobillionForm"> | Date | string
    userId?: StringFilter<"ImmobillionForm"> | string
    formType?: StringFilter<"ImmobillionForm"> | string
    formVersion?: StringFilter<"ImmobillionForm"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    applicants?: ApplicantListRelationFilter
  }

  export type ImmobillionFormOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    formType?: SortOrder
    formVersion?: SortOrder
    user?: UserOrderByWithRelationInput
    applicants?: ApplicantOrderByRelationAggregateInput
  }

  export type ImmobillionFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImmobillionFormWhereInput | ImmobillionFormWhereInput[]
    OR?: ImmobillionFormWhereInput[]
    NOT?: ImmobillionFormWhereInput | ImmobillionFormWhereInput[]
    status?: StringFilter<"ImmobillionForm"> | string
    createdAt?: DateTimeFilter<"ImmobillionForm"> | Date | string
    updatedAt?: DateTimeFilter<"ImmobillionForm"> | Date | string
    userId?: StringFilter<"ImmobillionForm"> | string
    formType?: StringFilter<"ImmobillionForm"> | string
    formVersion?: StringFilter<"ImmobillionForm"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    applicants?: ApplicantListRelationFilter
  }, "id">

  export type ImmobillionFormOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    formType?: SortOrder
    formVersion?: SortOrder
    _count?: ImmobillionFormCountOrderByAggregateInput
    _max?: ImmobillionFormMaxOrderByAggregateInput
    _min?: ImmobillionFormMinOrderByAggregateInput
  }

  export type ImmobillionFormScalarWhereWithAggregatesInput = {
    AND?: ImmobillionFormScalarWhereWithAggregatesInput | ImmobillionFormScalarWhereWithAggregatesInput[]
    OR?: ImmobillionFormScalarWhereWithAggregatesInput[]
    NOT?: ImmobillionFormScalarWhereWithAggregatesInput | ImmobillionFormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImmobillionForm"> | string
    status?: StringWithAggregatesFilter<"ImmobillionForm"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ImmobillionForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImmobillionForm"> | Date | string
    userId?: StringWithAggregatesFilter<"ImmobillionForm"> | string
    formType?: StringWithAggregatesFilter<"ImmobillionForm"> | string
    formVersion?: StringWithAggregatesFilter<"ImmobillionForm"> | string
  }

  export type AnalysisFormWhereInput = {
    AND?: AnalysisFormWhereInput | AnalysisFormWhereInput[]
    OR?: AnalysisFormWhereInput[]
    NOT?: AnalysisFormWhereInput | AnalysisFormWhereInput[]
    id?: StringFilter<"AnalysisForm"> | string
    status?: StringFilter<"AnalysisForm"> | string
    createdAt?: DateTimeFilter<"AnalysisForm"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisForm"> | Date | string
    userId?: StringFilter<"AnalysisForm"> | string
    consultantName?: StringFilter<"AnalysisForm"> | string
    officeLocation?: StringFilter<"AnalysisForm"> | string
    analysisDate?: DateTimeFilter<"AnalysisForm"> | Date | string
    coldRent?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    gas?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFilter<"AnalysisForm"> | boolean
    loanBank?: StringNullableFilter<"AnalysisForm"> | string | null
    loanAmount?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    loanInterest?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFilter<"AnalysisForm"> | boolean
    analysisConsentText?: StringFilter<"AnalysisForm"> | string
    analysisConsentSignature?: StringFilter<"AnalysisForm"> | string
    analysisLocation?: StringFilter<"AnalysisForm"> | string
    analysisConsentDate?: DateTimeFilter<"AnalysisForm"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    children?: ChildListRelationFilter
    applicants?: ApplicantListRelationFilter
  }

  export type AnalysisFormOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    consultantName?: SortOrder
    officeLocation?: SortOrder
    analysisDate?: SortOrder
    coldRent?: SortOrder
    gas?: SortOrder
    electricity?: SortOrder
    telecommunication?: SortOrder
    subscriptions?: SortOrder
    accountMaintenanceFee?: SortOrder
    livingExpenses?: SortOrder
    alimony?: SortOrder
    otherExpenses?: SortOrder
    addLoanOrLeasing?: SortOrder
    loanBank?: SortOrderInput | SortOrder
    loanAmount?: SortOrderInput | SortOrder
    loanMonthlyRate?: SortOrderInput | SortOrder
    loanInterest?: SortOrderInput | SortOrder
    analysisConsent?: SortOrder
    analysisConsentText?: SortOrder
    analysisConsentSignature?: SortOrder
    analysisLocation?: SortOrder
    analysisConsentDate?: SortOrder
    user?: UserOrderByWithRelationInput
    children?: ChildOrderByRelationAggregateInput
    applicants?: ApplicantOrderByRelationAggregateInput
  }

  export type AnalysisFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalysisFormWhereInput | AnalysisFormWhereInput[]
    OR?: AnalysisFormWhereInput[]
    NOT?: AnalysisFormWhereInput | AnalysisFormWhereInput[]
    status?: StringFilter<"AnalysisForm"> | string
    createdAt?: DateTimeFilter<"AnalysisForm"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisForm"> | Date | string
    userId?: StringFilter<"AnalysisForm"> | string
    consultantName?: StringFilter<"AnalysisForm"> | string
    officeLocation?: StringFilter<"AnalysisForm"> | string
    analysisDate?: DateTimeFilter<"AnalysisForm"> | Date | string
    coldRent?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    gas?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFilter<"AnalysisForm"> | boolean
    loanBank?: StringNullableFilter<"AnalysisForm"> | string | null
    loanAmount?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    loanInterest?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFilter<"AnalysisForm"> | boolean
    analysisConsentText?: StringFilter<"AnalysisForm"> | string
    analysisConsentSignature?: StringFilter<"AnalysisForm"> | string
    analysisLocation?: StringFilter<"AnalysisForm"> | string
    analysisConsentDate?: DateTimeFilter<"AnalysisForm"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    children?: ChildListRelationFilter
    applicants?: ApplicantListRelationFilter
  }, "id">

  export type AnalysisFormOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    consultantName?: SortOrder
    officeLocation?: SortOrder
    analysisDate?: SortOrder
    coldRent?: SortOrder
    gas?: SortOrder
    electricity?: SortOrder
    telecommunication?: SortOrder
    subscriptions?: SortOrder
    accountMaintenanceFee?: SortOrder
    livingExpenses?: SortOrder
    alimony?: SortOrder
    otherExpenses?: SortOrder
    addLoanOrLeasing?: SortOrder
    loanBank?: SortOrderInput | SortOrder
    loanAmount?: SortOrderInput | SortOrder
    loanMonthlyRate?: SortOrderInput | SortOrder
    loanInterest?: SortOrderInput | SortOrder
    analysisConsent?: SortOrder
    analysisConsentText?: SortOrder
    analysisConsentSignature?: SortOrder
    analysisLocation?: SortOrder
    analysisConsentDate?: SortOrder
    _count?: AnalysisFormCountOrderByAggregateInput
    _avg?: AnalysisFormAvgOrderByAggregateInput
    _max?: AnalysisFormMaxOrderByAggregateInput
    _min?: AnalysisFormMinOrderByAggregateInput
    _sum?: AnalysisFormSumOrderByAggregateInput
  }

  export type AnalysisFormScalarWhereWithAggregatesInput = {
    AND?: AnalysisFormScalarWhereWithAggregatesInput | AnalysisFormScalarWhereWithAggregatesInput[]
    OR?: AnalysisFormScalarWhereWithAggregatesInput[]
    NOT?: AnalysisFormScalarWhereWithAggregatesInput | AnalysisFormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalysisForm"> | string
    status?: StringWithAggregatesFilter<"AnalysisForm"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AnalysisForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalysisForm"> | Date | string
    userId?: StringWithAggregatesFilter<"AnalysisForm"> | string
    consultantName?: StringWithAggregatesFilter<"AnalysisForm"> | string
    officeLocation?: StringWithAggregatesFilter<"AnalysisForm"> | string
    analysisDate?: DateTimeWithAggregatesFilter<"AnalysisForm"> | Date | string
    coldRent?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    gas?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    electricity?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    alimony?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolWithAggregatesFilter<"AnalysisForm"> | boolean
    loanBank?: StringNullableWithAggregatesFilter<"AnalysisForm"> | string | null
    loanAmount?: DecimalNullableWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: DecimalNullableWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    loanInterest?: DecimalNullableWithAggregatesFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolWithAggregatesFilter<"AnalysisForm"> | boolean
    analysisConsentText?: StringWithAggregatesFilter<"AnalysisForm"> | string
    analysisConsentSignature?: StringWithAggregatesFilter<"AnalysisForm"> | string
    analysisLocation?: StringWithAggregatesFilter<"AnalysisForm"> | string
    analysisConsentDate?: DateTimeWithAggregatesFilter<"AnalysisForm"> | Date | string
  }

  export type PersonalDetailsWhereInput = {
    AND?: PersonalDetailsWhereInput | PersonalDetailsWhereInput[]
    OR?: PersonalDetailsWhereInput[]
    NOT?: PersonalDetailsWhereInput | PersonalDetailsWhereInput[]
    id?: StringFilter<"PersonalDetails"> | string
    userId?: StringFilter<"PersonalDetails"> | string
    createdAt?: DateTimeFilter<"PersonalDetails"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalDetails"> | Date | string
    coachId?: StringFilter<"PersonalDetails"> | string
    applicantType?: EnumApplicantTypeFilter<"PersonalDetails"> | $Enums.ApplicantType
    firstName?: StringFilter<"PersonalDetails"> | string
    lastName?: StringFilter<"PersonalDetails"> | string
    streetAddress?: StringFilter<"PersonalDetails"> | string
    postalCode?: StringFilter<"PersonalDetails"> | string
    city?: StringFilter<"PersonalDetails"> | string
    phone?: StringFilter<"PersonalDetails"> | string
    email?: StringFilter<"PersonalDetails"> | string
    birthDate?: DateTimeFilter<"PersonalDetails"> | Date | string
    birthPlace?: StringFilter<"PersonalDetails"> | string
    maritalStatus?: StringFilter<"PersonalDetails"> | string
    nationality?: StringFilter<"PersonalDetails"> | string
    housing?: StringFilter<"PersonalDetails"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coach?: XOR<UserScalarRelationFilter, UserWhereInput>
    employmentDetails?: EmploymentDetailsListRelationFilter
    incomeDetails?: IncomeDetailsListRelationFilter
    expensesDetails?: ExpensesDetailsListRelationFilter
    assets?: AssetListRelationFilter
    liabilities?: LiabilityListRelationFilter
    goalsAndWishes?: XOR<GoalsAndWishesNullableScalarRelationFilter, GoalsAndWishesWhereInput> | null
    riskAppetite?: XOR<RiskAppetiteNullableScalarRelationFilter, RiskAppetiteWhereInput> | null
    consents?: ConsentListRelationFilter
    documents?: DocumentListRelationFilter
    forms?: FormListRelationFilter
    customForms?: CustomFormListRelationFilter
  }

  export type PersonalDetailsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coachId?: SortOrder
    applicantType?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    streetAddress?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    housing?: SortOrder
    user?: UserOrderByWithRelationInput
    coach?: UserOrderByWithRelationInput
    employmentDetails?: EmploymentDetailsOrderByRelationAggregateInput
    incomeDetails?: IncomeDetailsOrderByRelationAggregateInput
    expensesDetails?: ExpensesDetailsOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    liabilities?: LiabilityOrderByRelationAggregateInput
    goalsAndWishes?: GoalsAndWishesOrderByWithRelationInput
    riskAppetite?: RiskAppetiteOrderByWithRelationInput
    consents?: ConsentOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    forms?: FormOrderByRelationAggregateInput
    customForms?: CustomFormOrderByRelationAggregateInput
  }

  export type PersonalDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PersonalDetailsWhereInput | PersonalDetailsWhereInput[]
    OR?: PersonalDetailsWhereInput[]
    NOT?: PersonalDetailsWhereInput | PersonalDetailsWhereInput[]
    createdAt?: DateTimeFilter<"PersonalDetails"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalDetails"> | Date | string
    coachId?: StringFilter<"PersonalDetails"> | string
    applicantType?: EnumApplicantTypeFilter<"PersonalDetails"> | $Enums.ApplicantType
    firstName?: StringFilter<"PersonalDetails"> | string
    lastName?: StringFilter<"PersonalDetails"> | string
    streetAddress?: StringFilter<"PersonalDetails"> | string
    postalCode?: StringFilter<"PersonalDetails"> | string
    city?: StringFilter<"PersonalDetails"> | string
    phone?: StringFilter<"PersonalDetails"> | string
    email?: StringFilter<"PersonalDetails"> | string
    birthDate?: DateTimeFilter<"PersonalDetails"> | Date | string
    birthPlace?: StringFilter<"PersonalDetails"> | string
    maritalStatus?: StringFilter<"PersonalDetails"> | string
    nationality?: StringFilter<"PersonalDetails"> | string
    housing?: StringFilter<"PersonalDetails"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coach?: XOR<UserScalarRelationFilter, UserWhereInput>
    employmentDetails?: EmploymentDetailsListRelationFilter
    incomeDetails?: IncomeDetailsListRelationFilter
    expensesDetails?: ExpensesDetailsListRelationFilter
    assets?: AssetListRelationFilter
    liabilities?: LiabilityListRelationFilter
    goalsAndWishes?: XOR<GoalsAndWishesNullableScalarRelationFilter, GoalsAndWishesWhereInput> | null
    riskAppetite?: XOR<RiskAppetiteNullableScalarRelationFilter, RiskAppetiteWhereInput> | null
    consents?: ConsentListRelationFilter
    documents?: DocumentListRelationFilter
    forms?: FormListRelationFilter
    customForms?: CustomFormListRelationFilter
  }, "id" | "userId">

  export type PersonalDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coachId?: SortOrder
    applicantType?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    streetAddress?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    housing?: SortOrder
    _count?: PersonalDetailsCountOrderByAggregateInput
    _max?: PersonalDetailsMaxOrderByAggregateInput
    _min?: PersonalDetailsMinOrderByAggregateInput
  }

  export type PersonalDetailsScalarWhereWithAggregatesInput = {
    AND?: PersonalDetailsScalarWhereWithAggregatesInput | PersonalDetailsScalarWhereWithAggregatesInput[]
    OR?: PersonalDetailsScalarWhereWithAggregatesInput[]
    NOT?: PersonalDetailsScalarWhereWithAggregatesInput | PersonalDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalDetails"> | string
    userId?: StringWithAggregatesFilter<"PersonalDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PersonalDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonalDetails"> | Date | string
    coachId?: StringWithAggregatesFilter<"PersonalDetails"> | string
    applicantType?: EnumApplicantTypeWithAggregatesFilter<"PersonalDetails"> | $Enums.ApplicantType
    firstName?: StringWithAggregatesFilter<"PersonalDetails"> | string
    lastName?: StringWithAggregatesFilter<"PersonalDetails"> | string
    streetAddress?: StringWithAggregatesFilter<"PersonalDetails"> | string
    postalCode?: StringWithAggregatesFilter<"PersonalDetails"> | string
    city?: StringWithAggregatesFilter<"PersonalDetails"> | string
    phone?: StringWithAggregatesFilter<"PersonalDetails"> | string
    email?: StringWithAggregatesFilter<"PersonalDetails"> | string
    birthDate?: DateTimeWithAggregatesFilter<"PersonalDetails"> | Date | string
    birthPlace?: StringWithAggregatesFilter<"PersonalDetails"> | string
    maritalStatus?: StringWithAggregatesFilter<"PersonalDetails"> | string
    nationality?: StringWithAggregatesFilter<"PersonalDetails"> | string
    housing?: StringWithAggregatesFilter<"PersonalDetails"> | string
  }

  export type EmploymentDetailsWhereInput = {
    AND?: EmploymentDetailsWhereInput | EmploymentDetailsWhereInput[]
    OR?: EmploymentDetailsWhereInput[]
    NOT?: EmploymentDetailsWhereInput | EmploymentDetailsWhereInput[]
    id?: StringFilter<"EmploymentDetails"> | string
    employmentId?: StringFilter<"EmploymentDetails"> | string
    createdAt?: DateTimeFilter<"EmploymentDetails"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentDetails"> | Date | string
    personalId?: StringFilter<"EmploymentDetails"> | string
    employmentType?: EnumEmploymentTypeFilter<"EmploymentDetails"> | $Enums.EmploymentType
    occupation?: StringFilter<"EmploymentDetails"> | string
    contractType?: StringFilter<"EmploymentDetails"> | string
    contractDuration?: StringFilter<"EmploymentDetails"> | string
    employerName?: StringFilter<"EmploymentDetails"> | string
    employedSince?: DateTimeFilter<"EmploymentDetails"> | Date | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type EmploymentDetailsOrderByWithRelationInput = {
    id?: SortOrder
    employmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    employmentType?: SortOrder
    occupation?: SortOrder
    contractType?: SortOrder
    contractDuration?: SortOrder
    employerName?: SortOrder
    employedSince?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type EmploymentDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employmentId?: string
    AND?: EmploymentDetailsWhereInput | EmploymentDetailsWhereInput[]
    OR?: EmploymentDetailsWhereInput[]
    NOT?: EmploymentDetailsWhereInput | EmploymentDetailsWhereInput[]
    createdAt?: DateTimeFilter<"EmploymentDetails"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentDetails"> | Date | string
    personalId?: StringFilter<"EmploymentDetails"> | string
    employmentType?: EnumEmploymentTypeFilter<"EmploymentDetails"> | $Enums.EmploymentType
    occupation?: StringFilter<"EmploymentDetails"> | string
    contractType?: StringFilter<"EmploymentDetails"> | string
    contractDuration?: StringFilter<"EmploymentDetails"> | string
    employerName?: StringFilter<"EmploymentDetails"> | string
    employedSince?: DateTimeFilter<"EmploymentDetails"> | Date | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "employmentId">

  export type EmploymentDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    employmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    employmentType?: SortOrder
    occupation?: SortOrder
    contractType?: SortOrder
    contractDuration?: SortOrder
    employerName?: SortOrder
    employedSince?: SortOrder
    _count?: EmploymentDetailsCountOrderByAggregateInput
    _max?: EmploymentDetailsMaxOrderByAggregateInput
    _min?: EmploymentDetailsMinOrderByAggregateInput
  }

  export type EmploymentDetailsScalarWhereWithAggregatesInput = {
    AND?: EmploymentDetailsScalarWhereWithAggregatesInput | EmploymentDetailsScalarWhereWithAggregatesInput[]
    OR?: EmploymentDetailsScalarWhereWithAggregatesInput[]
    NOT?: EmploymentDetailsScalarWhereWithAggregatesInput | EmploymentDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmploymentDetails"> | string
    employmentId?: StringWithAggregatesFilter<"EmploymentDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmploymentDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmploymentDetails"> | Date | string
    personalId?: StringWithAggregatesFilter<"EmploymentDetails"> | string
    employmentType?: EnumEmploymentTypeWithAggregatesFilter<"EmploymentDetails"> | $Enums.EmploymentType
    occupation?: StringWithAggregatesFilter<"EmploymentDetails"> | string
    contractType?: StringWithAggregatesFilter<"EmploymentDetails"> | string
    contractDuration?: StringWithAggregatesFilter<"EmploymentDetails"> | string
    employerName?: StringWithAggregatesFilter<"EmploymentDetails"> | string
    employedSince?: DateTimeWithAggregatesFilter<"EmploymentDetails"> | Date | string
  }

  export type IncomeDetailsWhereInput = {
    AND?: IncomeDetailsWhereInput | IncomeDetailsWhereInput[]
    OR?: IncomeDetailsWhereInput[]
    NOT?: IncomeDetailsWhereInput | IncomeDetailsWhereInput[]
    id?: StringFilter<"IncomeDetails"> | string
    incomeId?: StringFilter<"IncomeDetails"> | string
    createdAt?: DateTimeFilter<"IncomeDetails"> | Date | string
    updatedAt?: DateTimeFilter<"IncomeDetails"> | Date | string
    personalId?: StringFilter<"IncomeDetails"> | string
    grossIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    taxClass?: StringFilter<"IncomeDetails"> | string
    taxId?: StringFilter<"IncomeDetails"> | string
    numberOfSalaries?: IntFilter<"IncomeDetails"> | number
    childBenefit?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type IncomeDetailsOrderByWithRelationInput = {
    id?: SortOrder
    incomeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    grossIncome?: SortOrder
    netIncome?: SortOrder
    taxClass?: SortOrder
    taxId?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    incomeTradeBusiness?: SortOrder
    incomeSelfEmployedWork?: SortOrder
    incomeSideJob?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type IncomeDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    incomeId?: string
    AND?: IncomeDetailsWhereInput | IncomeDetailsWhereInput[]
    OR?: IncomeDetailsWhereInput[]
    NOT?: IncomeDetailsWhereInput | IncomeDetailsWhereInput[]
    createdAt?: DateTimeFilter<"IncomeDetails"> | Date | string
    updatedAt?: DateTimeFilter<"IncomeDetails"> | Date | string
    personalId?: StringFilter<"IncomeDetails"> | string
    grossIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    taxClass?: StringFilter<"IncomeDetails"> | string
    taxId?: StringFilter<"IncomeDetails"> | string
    numberOfSalaries?: IntFilter<"IncomeDetails"> | number
    childBenefit?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "incomeId">

  export type IncomeDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    incomeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    grossIncome?: SortOrder
    netIncome?: SortOrder
    taxClass?: SortOrder
    taxId?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    incomeTradeBusiness?: SortOrder
    incomeSelfEmployedWork?: SortOrder
    incomeSideJob?: SortOrder
    _count?: IncomeDetailsCountOrderByAggregateInput
    _avg?: IncomeDetailsAvgOrderByAggregateInput
    _max?: IncomeDetailsMaxOrderByAggregateInput
    _min?: IncomeDetailsMinOrderByAggregateInput
    _sum?: IncomeDetailsSumOrderByAggregateInput
  }

  export type IncomeDetailsScalarWhereWithAggregatesInput = {
    AND?: IncomeDetailsScalarWhereWithAggregatesInput | IncomeDetailsScalarWhereWithAggregatesInput[]
    OR?: IncomeDetailsScalarWhereWithAggregatesInput[]
    NOT?: IncomeDetailsScalarWhereWithAggregatesInput | IncomeDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncomeDetails"> | string
    incomeId?: StringWithAggregatesFilter<"IncomeDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IncomeDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IncomeDetails"> | Date | string
    personalId?: StringWithAggregatesFilter<"IncomeDetails"> | string
    grossIncome?: DecimalWithAggregatesFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalWithAggregatesFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    taxClass?: StringWithAggregatesFilter<"IncomeDetails"> | string
    taxId?: StringWithAggregatesFilter<"IncomeDetails"> | string
    numberOfSalaries?: IntWithAggregatesFilter<"IncomeDetails"> | number
    childBenefit?: DecimalWithAggregatesFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalWithAggregatesFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalWithAggregatesFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalWithAggregatesFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalWithAggregatesFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsWhereInput = {
    AND?: ExpensesDetailsWhereInput | ExpensesDetailsWhereInput[]
    OR?: ExpensesDetailsWhereInput[]
    NOT?: ExpensesDetailsWhereInput | ExpensesDetailsWhereInput[]
    id?: StringFilter<"ExpensesDetails"> | string
    expensesId?: StringFilter<"ExpensesDetails"> | string
    createdAt?: DateTimeFilter<"ExpensesDetails"> | Date | string
    updatedAt?: DateTimeFilter<"ExpensesDetails"> | Date | string
    personalId?: StringFilter<"ExpensesDetails"> | string
    coldRent?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    gas?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type ExpensesDetailsOrderByWithRelationInput = {
    id?: SortOrder
    expensesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    coldRent?: SortOrder
    electricity?: SortOrder
    livingExpenses?: SortOrder
    gas?: SortOrder
    telecommunication?: SortOrder
    accountMaintenanceFee?: SortOrder
    alimony?: SortOrder
    subscriptions?: SortOrder
    otherExpenses?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type ExpensesDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    expensesId?: string
    AND?: ExpensesDetailsWhereInput | ExpensesDetailsWhereInput[]
    OR?: ExpensesDetailsWhereInput[]
    NOT?: ExpensesDetailsWhereInput | ExpensesDetailsWhereInput[]
    createdAt?: DateTimeFilter<"ExpensesDetails"> | Date | string
    updatedAt?: DateTimeFilter<"ExpensesDetails"> | Date | string
    personalId?: StringFilter<"ExpensesDetails"> | string
    coldRent?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    gas?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "expensesId">

  export type ExpensesDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    expensesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    coldRent?: SortOrder
    electricity?: SortOrder
    livingExpenses?: SortOrder
    gas?: SortOrder
    telecommunication?: SortOrder
    accountMaintenanceFee?: SortOrder
    alimony?: SortOrder
    subscriptions?: SortOrder
    otherExpenses?: SortOrder
    _count?: ExpensesDetailsCountOrderByAggregateInput
    _avg?: ExpensesDetailsAvgOrderByAggregateInput
    _max?: ExpensesDetailsMaxOrderByAggregateInput
    _min?: ExpensesDetailsMinOrderByAggregateInput
    _sum?: ExpensesDetailsSumOrderByAggregateInput
  }

  export type ExpensesDetailsScalarWhereWithAggregatesInput = {
    AND?: ExpensesDetailsScalarWhereWithAggregatesInput | ExpensesDetailsScalarWhereWithAggregatesInput[]
    OR?: ExpensesDetailsScalarWhereWithAggregatesInput[]
    NOT?: ExpensesDetailsScalarWhereWithAggregatesInput | ExpensesDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpensesDetails"> | string
    expensesId?: StringWithAggregatesFilter<"ExpensesDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExpensesDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpensesDetails"> | Date | string
    personalId?: StringWithAggregatesFilter<"ExpensesDetails"> | string
    coldRent?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    electricity?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    gas?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    alimony?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalWithAggregatesFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    assetId?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    personalId?: StringFilter<"Asset"> | string
    realEstate?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    securities?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    realEstate?: SortOrder
    securities?: SortOrder
    bankDeposits?: SortOrder
    buildingSavings?: SortOrder
    insuranceValues?: SortOrder
    otherAssets?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    assetId?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    personalId?: StringFilter<"Asset"> | string
    realEstate?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    securities?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "assetId">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    realEstate?: SortOrder
    securities?: SortOrder
    bankDeposits?: SortOrder
    buildingSavings?: SortOrder
    insuranceValues?: SortOrder
    otherAssets?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    assetId?: StringWithAggregatesFilter<"Asset"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    personalId?: StringWithAggregatesFilter<"Asset"> | string
    realEstate?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    securities?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
  }

  export type LiabilityWhereInput = {
    AND?: LiabilityWhereInput | LiabilityWhereInput[]
    OR?: LiabilityWhereInput[]
    NOT?: LiabilityWhereInput | LiabilityWhereInput[]
    id?: StringFilter<"Liability"> | string
    liabilityId?: StringFilter<"Liability"> | string
    createdAt?: DateTimeFilter<"Liability"> | Date | string
    updatedAt?: DateTimeFilter<"Liability"> | Date | string
    personalId?: StringFilter<"Liability"> | string
    loanType?: EnumLoanTypeFilter<"Liability"> | $Enums.LoanType
    loanBank?: StringNullableFilter<"Liability"> | string | null
    loanAmount?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    loanInterest?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type LiabilityOrderByWithRelationInput = {
    id?: SortOrder
    liabilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    loanType?: SortOrder
    loanBank?: SortOrderInput | SortOrder
    loanAmount?: SortOrderInput | SortOrder
    loanMonthlyRate?: SortOrderInput | SortOrder
    loanInterest?: SortOrderInput | SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type LiabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    liabilityId?: string
    AND?: LiabilityWhereInput | LiabilityWhereInput[]
    OR?: LiabilityWhereInput[]
    NOT?: LiabilityWhereInput | LiabilityWhereInput[]
    createdAt?: DateTimeFilter<"Liability"> | Date | string
    updatedAt?: DateTimeFilter<"Liability"> | Date | string
    personalId?: StringFilter<"Liability"> | string
    loanType?: EnumLoanTypeFilter<"Liability"> | $Enums.LoanType
    loanBank?: StringNullableFilter<"Liability"> | string | null
    loanAmount?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    loanInterest?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "liabilityId">

  export type LiabilityOrderByWithAggregationInput = {
    id?: SortOrder
    liabilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    loanType?: SortOrder
    loanBank?: SortOrderInput | SortOrder
    loanAmount?: SortOrderInput | SortOrder
    loanMonthlyRate?: SortOrderInput | SortOrder
    loanInterest?: SortOrderInput | SortOrder
    _count?: LiabilityCountOrderByAggregateInput
    _avg?: LiabilityAvgOrderByAggregateInput
    _max?: LiabilityMaxOrderByAggregateInput
    _min?: LiabilityMinOrderByAggregateInput
    _sum?: LiabilitySumOrderByAggregateInput
  }

  export type LiabilityScalarWhereWithAggregatesInput = {
    AND?: LiabilityScalarWhereWithAggregatesInput | LiabilityScalarWhereWithAggregatesInput[]
    OR?: LiabilityScalarWhereWithAggregatesInput[]
    NOT?: LiabilityScalarWhereWithAggregatesInput | LiabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Liability"> | string
    liabilityId?: StringWithAggregatesFilter<"Liability"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Liability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Liability"> | Date | string
    personalId?: StringWithAggregatesFilter<"Liability"> | string
    loanType?: EnumLoanTypeWithAggregatesFilter<"Liability"> | $Enums.LoanType
    loanBank?: StringNullableWithAggregatesFilter<"Liability"> | string | null
    loanAmount?: DecimalNullableWithAggregatesFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: DecimalNullableWithAggregatesFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    loanInterest?: DecimalNullableWithAggregatesFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
  }

  export type GoalsAndWishesWhereInput = {
    AND?: GoalsAndWishesWhereInput | GoalsAndWishesWhereInput[]
    OR?: GoalsAndWishesWhereInput[]
    NOT?: GoalsAndWishesWhereInput | GoalsAndWishesWhereInput[]
    id?: StringFilter<"GoalsAndWishes"> | string
    goalsAndWishesId?: StringFilter<"GoalsAndWishes"> | string
    createdAt?: DateTimeFilter<"GoalsAndWishes"> | Date | string
    updatedAt?: DateTimeFilter<"GoalsAndWishes"> | Date | string
    personalId?: StringFilter<"GoalsAndWishes"> | string
    retirementPlanning?: StringFilter<"GoalsAndWishes"> | string
    capitalFormation?: StringFilter<"GoalsAndWishes"> | string
    realEstateGoals?: StringFilter<"GoalsAndWishes"> | string
    financing?: StringFilter<"GoalsAndWishes"> | string
    protection?: StringFilter<"GoalsAndWishes"> | string
    healthcareProvision?: StringFilter<"GoalsAndWishes"> | string
    otherGoals?: StringFilter<"GoalsAndWishes"> | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type GoalsAndWishesOrderByWithRelationInput = {
    id?: SortOrder
    goalsAndWishesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    retirementPlanning?: SortOrder
    capitalFormation?: SortOrder
    realEstateGoals?: SortOrder
    financing?: SortOrder
    protection?: SortOrder
    healthcareProvision?: SortOrder
    otherGoals?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type GoalsAndWishesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    goalsAndWishesId?: string
    personalId?: string
    AND?: GoalsAndWishesWhereInput | GoalsAndWishesWhereInput[]
    OR?: GoalsAndWishesWhereInput[]
    NOT?: GoalsAndWishesWhereInput | GoalsAndWishesWhereInput[]
    createdAt?: DateTimeFilter<"GoalsAndWishes"> | Date | string
    updatedAt?: DateTimeFilter<"GoalsAndWishes"> | Date | string
    retirementPlanning?: StringFilter<"GoalsAndWishes"> | string
    capitalFormation?: StringFilter<"GoalsAndWishes"> | string
    realEstateGoals?: StringFilter<"GoalsAndWishes"> | string
    financing?: StringFilter<"GoalsAndWishes"> | string
    protection?: StringFilter<"GoalsAndWishes"> | string
    healthcareProvision?: StringFilter<"GoalsAndWishes"> | string
    otherGoals?: StringFilter<"GoalsAndWishes"> | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "goalsAndWishesId" | "personalId">

  export type GoalsAndWishesOrderByWithAggregationInput = {
    id?: SortOrder
    goalsAndWishesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    retirementPlanning?: SortOrder
    capitalFormation?: SortOrder
    realEstateGoals?: SortOrder
    financing?: SortOrder
    protection?: SortOrder
    healthcareProvision?: SortOrder
    otherGoals?: SortOrder
    _count?: GoalsAndWishesCountOrderByAggregateInput
    _max?: GoalsAndWishesMaxOrderByAggregateInput
    _min?: GoalsAndWishesMinOrderByAggregateInput
  }

  export type GoalsAndWishesScalarWhereWithAggregatesInput = {
    AND?: GoalsAndWishesScalarWhereWithAggregatesInput | GoalsAndWishesScalarWhereWithAggregatesInput[]
    OR?: GoalsAndWishesScalarWhereWithAggregatesInput[]
    NOT?: GoalsAndWishesScalarWhereWithAggregatesInput | GoalsAndWishesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    goalsAndWishesId?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GoalsAndWishes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GoalsAndWishes"> | Date | string
    personalId?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    retirementPlanning?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    capitalFormation?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    realEstateGoals?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    financing?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    protection?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    healthcareProvision?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
    otherGoals?: StringWithAggregatesFilter<"GoalsAndWishes"> | string
  }

  export type RiskAppetiteWhereInput = {
    AND?: RiskAppetiteWhereInput | RiskAppetiteWhereInput[]
    OR?: RiskAppetiteWhereInput[]
    NOT?: RiskAppetiteWhereInput | RiskAppetiteWhereInput[]
    id?: StringFilter<"RiskAppetite"> | string
    riskAppetiteId?: StringFilter<"RiskAppetite"> | string
    createdAt?: DateTimeFilter<"RiskAppetite"> | Date | string
    updatedAt?: DateTimeFilter<"RiskAppetite"> | Date | string
    personalId?: StringFilter<"RiskAppetite"> | string
    riskAppetite?: StringFilter<"RiskAppetite"> | string
    investmentHorizon?: StringFilter<"RiskAppetite"> | string
    knowledgeExperience?: StringFilter<"RiskAppetite"> | string
    healthInsurance?: StringFilter<"RiskAppetite"> | string
    healthInsuranceNumber?: StringFilter<"RiskAppetite"> | string
    healthInsuranceProof?: StringFilter<"RiskAppetite"> | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type RiskAppetiteOrderByWithRelationInput = {
    id?: SortOrder
    riskAppetiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    riskAppetite?: SortOrder
    investmentHorizon?: SortOrder
    knowledgeExperience?: SortOrder
    healthInsurance?: SortOrder
    healthInsuranceNumber?: SortOrder
    healthInsuranceProof?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type RiskAppetiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    riskAppetiteId?: string
    personalId?: string
    AND?: RiskAppetiteWhereInput | RiskAppetiteWhereInput[]
    OR?: RiskAppetiteWhereInput[]
    NOT?: RiskAppetiteWhereInput | RiskAppetiteWhereInput[]
    createdAt?: DateTimeFilter<"RiskAppetite"> | Date | string
    updatedAt?: DateTimeFilter<"RiskAppetite"> | Date | string
    riskAppetite?: StringFilter<"RiskAppetite"> | string
    investmentHorizon?: StringFilter<"RiskAppetite"> | string
    knowledgeExperience?: StringFilter<"RiskAppetite"> | string
    healthInsurance?: StringFilter<"RiskAppetite"> | string
    healthInsuranceNumber?: StringFilter<"RiskAppetite"> | string
    healthInsuranceProof?: StringFilter<"RiskAppetite"> | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "riskAppetiteId" | "personalId">

  export type RiskAppetiteOrderByWithAggregationInput = {
    id?: SortOrder
    riskAppetiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    riskAppetite?: SortOrder
    investmentHorizon?: SortOrder
    knowledgeExperience?: SortOrder
    healthInsurance?: SortOrder
    healthInsuranceNumber?: SortOrder
    healthInsuranceProof?: SortOrder
    _count?: RiskAppetiteCountOrderByAggregateInput
    _max?: RiskAppetiteMaxOrderByAggregateInput
    _min?: RiskAppetiteMinOrderByAggregateInput
  }

  export type RiskAppetiteScalarWhereWithAggregatesInput = {
    AND?: RiskAppetiteScalarWhereWithAggregatesInput | RiskAppetiteScalarWhereWithAggregatesInput[]
    OR?: RiskAppetiteScalarWhereWithAggregatesInput[]
    NOT?: RiskAppetiteScalarWhereWithAggregatesInput | RiskAppetiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskAppetite"> | string
    riskAppetiteId?: StringWithAggregatesFilter<"RiskAppetite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RiskAppetite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskAppetite"> | Date | string
    personalId?: StringWithAggregatesFilter<"RiskAppetite"> | string
    riskAppetite?: StringWithAggregatesFilter<"RiskAppetite"> | string
    investmentHorizon?: StringWithAggregatesFilter<"RiskAppetite"> | string
    knowledgeExperience?: StringWithAggregatesFilter<"RiskAppetite"> | string
    healthInsurance?: StringWithAggregatesFilter<"RiskAppetite"> | string
    healthInsuranceNumber?: StringWithAggregatesFilter<"RiskAppetite"> | string
    healthInsuranceProof?: StringWithAggregatesFilter<"RiskAppetite"> | string
  }

  export type ConsentWhereInput = {
    AND?: ConsentWhereInput | ConsentWhereInput[]
    OR?: ConsentWhereInput[]
    NOT?: ConsentWhereInput | ConsentWhereInput[]
    id?: StringFilter<"Consent"> | string
    consentId?: StringFilter<"Consent"> | string
    createdAt?: DateTimeFilter<"Consent"> | Date | string
    updatedAt?: DateTimeFilter<"Consent"> | Date | string
    personalId?: StringFilter<"Consent"> | string
    consentType?: EnumConsentTypeFilter<"Consent"> | $Enums.ConsentType
    consent?: BoolFilter<"Consent"> | boolean
    consentText?: StringFilter<"Consent"> | string
    consentSignature?: StringFilter<"Consent"> | string
    consentDate?: DateTimeFilter<"Consent"> | Date | string
    location?: StringFilter<"Consent"> | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type ConsentOrderByWithRelationInput = {
    id?: SortOrder
    consentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    consentType?: SortOrder
    consent?: SortOrder
    consentText?: SortOrder
    consentSignature?: SortOrder
    consentDate?: SortOrder
    location?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type ConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    consentId?: string
    AND?: ConsentWhereInput | ConsentWhereInput[]
    OR?: ConsentWhereInput[]
    NOT?: ConsentWhereInput | ConsentWhereInput[]
    createdAt?: DateTimeFilter<"Consent"> | Date | string
    updatedAt?: DateTimeFilter<"Consent"> | Date | string
    personalId?: StringFilter<"Consent"> | string
    consentType?: EnumConsentTypeFilter<"Consent"> | $Enums.ConsentType
    consent?: BoolFilter<"Consent"> | boolean
    consentText?: StringFilter<"Consent"> | string
    consentSignature?: StringFilter<"Consent"> | string
    consentDate?: DateTimeFilter<"Consent"> | Date | string
    location?: StringFilter<"Consent"> | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "consentId">

  export type ConsentOrderByWithAggregationInput = {
    id?: SortOrder
    consentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    consentType?: SortOrder
    consent?: SortOrder
    consentText?: SortOrder
    consentSignature?: SortOrder
    consentDate?: SortOrder
    location?: SortOrder
    _count?: ConsentCountOrderByAggregateInput
    _max?: ConsentMaxOrderByAggregateInput
    _min?: ConsentMinOrderByAggregateInput
  }

  export type ConsentScalarWhereWithAggregatesInput = {
    AND?: ConsentScalarWhereWithAggregatesInput | ConsentScalarWhereWithAggregatesInput[]
    OR?: ConsentScalarWhereWithAggregatesInput[]
    NOT?: ConsentScalarWhereWithAggregatesInput | ConsentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Consent"> | string
    consentId?: StringWithAggregatesFilter<"Consent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Consent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Consent"> | Date | string
    personalId?: StringWithAggregatesFilter<"Consent"> | string
    consentType?: EnumConsentTypeWithAggregatesFilter<"Consent"> | $Enums.ConsentType
    consent?: BoolWithAggregatesFilter<"Consent"> | boolean
    consentText?: StringWithAggregatesFilter<"Consent"> | string
    consentSignature?: StringWithAggregatesFilter<"Consent"> | string
    consentDate?: DateTimeWithAggregatesFilter<"Consent"> | Date | string
    location?: StringWithAggregatesFilter<"Consent"> | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    documentId?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    personalId?: StringFilter<"Document"> | string
    documentName?: StringFilter<"Document"> | string
    documentLocation?: StringFilter<"Document"> | string
    documentDate?: DateTimeFilter<"Document"> | Date | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    documentName?: SortOrder
    documentLocation?: SortOrder
    documentDate?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    personalId?: StringFilter<"Document"> | string
    documentName?: StringFilter<"Document"> | string
    documentLocation?: StringFilter<"Document"> | string
    documentDate?: DateTimeFilter<"Document"> | Date | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "documentId">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    documentName?: SortOrder
    documentLocation?: SortOrder
    documentDate?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    documentId?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    personalId?: StringWithAggregatesFilter<"Document"> | string
    documentName?: StringWithAggregatesFilter<"Document"> | string
    documentLocation?: StringWithAggregatesFilter<"Document"> | string
    documentDate?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type FormWhereInput = {
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    id?: StringFilter<"Form"> | string
    formId?: StringFilter<"Form"> | string
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    personalId?: StringFilter<"Form"> | string
    formType?: EnumFormTypeFilter<"Form"> | $Enums.FormType
    formName?: StringFilter<"Form"> | string
    formLink?: StringFilter<"Form"> | string
    createdDate?: DateTimeFilter<"Form"> | Date | string
    updatedDate?: DateTimeFilter<"Form"> | Date | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type FormOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formType?: SortOrder
    formName?: SortOrder
    formLink?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type FormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    formId?: string
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    personalId?: StringFilter<"Form"> | string
    formType?: EnumFormTypeFilter<"Form"> | $Enums.FormType
    formName?: StringFilter<"Form"> | string
    formLink?: StringFilter<"Form"> | string
    createdDate?: DateTimeFilter<"Form"> | Date | string
    updatedDate?: DateTimeFilter<"Form"> | Date | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "formId">

  export type FormOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formType?: SortOrder
    formName?: SortOrder
    formLink?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    _count?: FormCountOrderByAggregateInput
    _max?: FormMaxOrderByAggregateInput
    _min?: FormMinOrderByAggregateInput
  }

  export type FormScalarWhereWithAggregatesInput = {
    AND?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    OR?: FormScalarWhereWithAggregatesInput[]
    NOT?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Form"> | string
    formId?: StringWithAggregatesFilter<"Form"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    personalId?: StringWithAggregatesFilter<"Form"> | string
    formType?: EnumFormTypeWithAggregatesFilter<"Form"> | $Enums.FormType
    formName?: StringWithAggregatesFilter<"Form"> | string
    formLink?: StringWithAggregatesFilter<"Form"> | string
    createdDate?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    updatedDate?: DateTimeWithAggregatesFilter<"Form"> | Date | string
  }

  export type CustomFormWhereInput = {
    AND?: CustomFormWhereInput | CustomFormWhereInput[]
    OR?: CustomFormWhereInput[]
    NOT?: CustomFormWhereInput | CustomFormWhereInput[]
    id?: StringFilter<"CustomForm"> | string
    customFormId?: StringFilter<"CustomForm"> | string
    createdAt?: DateTimeFilter<"CustomForm"> | Date | string
    updatedAt?: DateTimeFilter<"CustomForm"> | Date | string
    personalId?: StringFilter<"CustomForm"> | string
    formTemplate?: StringFilter<"CustomForm"> | string
    formName?: StringFilter<"CustomForm"> | string
    createdDate?: DateTimeFilter<"CustomForm"> | Date | string
    updatedDate?: DateTimeFilter<"CustomForm"> | Date | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }

  export type CustomFormOrderByWithRelationInput = {
    id?: SortOrder
    customFormId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formTemplate?: SortOrder
    formName?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    personalDetails?: PersonalDetailsOrderByWithRelationInput
  }

  export type CustomFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customFormId?: string
    AND?: CustomFormWhereInput | CustomFormWhereInput[]
    OR?: CustomFormWhereInput[]
    NOT?: CustomFormWhereInput | CustomFormWhereInput[]
    createdAt?: DateTimeFilter<"CustomForm"> | Date | string
    updatedAt?: DateTimeFilter<"CustomForm"> | Date | string
    personalId?: StringFilter<"CustomForm"> | string
    formTemplate?: StringFilter<"CustomForm"> | string
    formName?: StringFilter<"CustomForm"> | string
    createdDate?: DateTimeFilter<"CustomForm"> | Date | string
    updatedDate?: DateTimeFilter<"CustomForm"> | Date | string
    personalDetails?: XOR<PersonalDetailsScalarRelationFilter, PersonalDetailsWhereInput>
  }, "id" | "customFormId">

  export type CustomFormOrderByWithAggregationInput = {
    id?: SortOrder
    customFormId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formTemplate?: SortOrder
    formName?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    _count?: CustomFormCountOrderByAggregateInput
    _max?: CustomFormMaxOrderByAggregateInput
    _min?: CustomFormMinOrderByAggregateInput
  }

  export type CustomFormScalarWhereWithAggregatesInput = {
    AND?: CustomFormScalarWhereWithAggregatesInput | CustomFormScalarWhereWithAggregatesInput[]
    OR?: CustomFormScalarWhereWithAggregatesInput[]
    NOT?: CustomFormScalarWhereWithAggregatesInput | CustomFormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomForm"> | string
    customFormId?: StringWithAggregatesFilter<"CustomForm"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomForm"> | Date | string
    personalId?: StringWithAggregatesFilter<"CustomForm"> | string
    formTemplate?: StringWithAggregatesFilter<"CustomForm"> | string
    formName?: StringWithAggregatesFilter<"CustomForm"> | string
    createdDate?: DateTimeWithAggregatesFilter<"CustomForm"> | Date | string
    updatedDate?: DateTimeWithAggregatesFilter<"CustomForm"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    analysisForms?: AnalysisFormCreateNestedManyWithoutUserInput
    immobillionForms?: ImmobillionFormCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsCreateNestedOneWithoutUserInput
    clientsAsCoach?: PersonalDetailsCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    analysisForms?: AnalysisFormUncheckedCreateNestedManyWithoutUserInput
    immobillionForms?: ImmobillionFormUncheckedCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsUncheckedCreateNestedOneWithoutUserInput
    clientsAsCoach?: PersonalDetailsUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    analysisForms?: AnalysisFormUpdateManyWithoutUserNestedInput
    immobillionForms?: ImmobillionFormUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUpdateOneWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisForms?: AnalysisFormUncheckedUpdateManyWithoutUserNestedInput
    immobillionForms?: ImmobillionFormUncheckedUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUncheckedUpdateOneWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildCreateInput = {
    id?: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace: string
    nationality: string
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisForm: AnalysisFormCreateNestedOneWithoutChildrenInput
  }

  export type ChildUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace: string
    nationality: string
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisFormId: string
  }

  export type ChildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisForm?: AnalysisFormUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisFormId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace: string
    nationality: string
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisFormId: string
  }

  export type ChildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisFormId?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicantCreateInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    analysisForm?: AnalysisFormCreateNestedOneWithoutApplicantsInput
    immobillionForm?: ImmobillionFormCreateNestedOneWithoutApplicantsInput
    immobillionDetails?: ImmobillionApplicantDetailsCreateNestedOneWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    analysisFormId?: string | null
    immobillionFormId?: string | null
    immobillionDetails?: ImmobillionApplicantDetailsUncheckedCreateNestedOneWithoutApplicantInput
  }

  export type ApplicantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    analysisForm?: AnalysisFormUpdateOneWithoutApplicantsNestedInput
    immobillionForm?: ImmobillionFormUpdateOneWithoutApplicantsNestedInput
    immobillionDetails?: ImmobillionApplicantDetailsUpdateOneWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    analysisFormId?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionFormId?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionDetails?: ImmobillionApplicantDetailsUncheckedUpdateOneWithoutApplicantNestedInput
  }

  export type ApplicantCreateManyInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    analysisFormId?: string | null
    immobillionFormId?: string | null
  }

  export type ApplicantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    analysisFormId?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionFormId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImmobillionApplicantDetailsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryCurrency?: string | null
    salaryCurrencyOther?: string | null
    hasPartTimeJob: boolean
    partTimeSince?: Date | string | null
    isFreelancer: boolean
    isSelfEmployed: boolean
    selfEmployedAs?: string | null
    selfEmployedSince?: Date | string | null
    selfEmployedCompany?: string | null
    vehiclesInHousehold: number
    retirementStart?: Date | string | null
    statutoryPension?: Decimal | DecimalJsLike | number | string | null
    privatePension?: Decimal | DecimalJsLike | number | string | null
    interpreterRequired: boolean
    monthlyIncome: JsonNullValueInput | InputJsonValue
    monthlyExpenses: JsonNullValueInput | InputJsonValue
    assets: JsonNullValueInput | InputJsonValue
    liabilities: JsonNullValueInput | InputJsonValue
    applicant: ApplicantCreateNestedOneWithoutImmobillionDetailsInput
  }

  export type ImmobillionApplicantDetailsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
    salaryCurrency?: string | null
    salaryCurrencyOther?: string | null
    hasPartTimeJob: boolean
    partTimeSince?: Date | string | null
    isFreelancer: boolean
    isSelfEmployed: boolean
    selfEmployedAs?: string | null
    selfEmployedSince?: Date | string | null
    selfEmployedCompany?: string | null
    vehiclesInHousehold: number
    retirementStart?: Date | string | null
    statutoryPension?: Decimal | DecimalJsLike | number | string | null
    privatePension?: Decimal | DecimalJsLike | number | string | null
    interpreterRequired: boolean
    monthlyIncome: JsonNullValueInput | InputJsonValue
    monthlyExpenses: JsonNullValueInput | InputJsonValue
    assets: JsonNullValueInput | InputJsonValue
    liabilities: JsonNullValueInput | InputJsonValue
  }

  export type ImmobillionApplicantDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryCurrencyOther?: NullableStringFieldUpdateOperationsInput | string | null
    hasPartTimeJob?: BoolFieldUpdateOperationsInput | boolean
    partTimeSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFreelancer?: BoolFieldUpdateOperationsInput | boolean
    isSelfEmployed?: BoolFieldUpdateOperationsInput | boolean
    selfEmployedAs?: NullableStringFieldUpdateOperationsInput | string | null
    selfEmployedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    selfEmployedCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesInHousehold?: IntFieldUpdateOperationsInput | number
    retirementStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutoryPension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    privatePension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolFieldUpdateOperationsInput | boolean
    monthlyIncome?: JsonNullValueInput | InputJsonValue
    monthlyExpenses?: JsonNullValueInput | InputJsonValue
    assets?: JsonNullValueInput | InputJsonValue
    liabilities?: JsonNullValueInput | InputJsonValue
    applicant?: ApplicantUpdateOneRequiredWithoutImmobillionDetailsNestedInput
  }

  export type ImmobillionApplicantDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryCurrencyOther?: NullableStringFieldUpdateOperationsInput | string | null
    hasPartTimeJob?: BoolFieldUpdateOperationsInput | boolean
    partTimeSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFreelancer?: BoolFieldUpdateOperationsInput | boolean
    isSelfEmployed?: BoolFieldUpdateOperationsInput | boolean
    selfEmployedAs?: NullableStringFieldUpdateOperationsInput | string | null
    selfEmployedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    selfEmployedCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesInHousehold?: IntFieldUpdateOperationsInput | number
    retirementStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutoryPension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    privatePension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolFieldUpdateOperationsInput | boolean
    monthlyIncome?: JsonNullValueInput | InputJsonValue
    monthlyExpenses?: JsonNullValueInput | InputJsonValue
    assets?: JsonNullValueInput | InputJsonValue
    liabilities?: JsonNullValueInput | InputJsonValue
  }

  export type ImmobillionApplicantDetailsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
    salaryCurrency?: string | null
    salaryCurrencyOther?: string | null
    hasPartTimeJob: boolean
    partTimeSince?: Date | string | null
    isFreelancer: boolean
    isSelfEmployed: boolean
    selfEmployedAs?: string | null
    selfEmployedSince?: Date | string | null
    selfEmployedCompany?: string | null
    vehiclesInHousehold: number
    retirementStart?: Date | string | null
    statutoryPension?: Decimal | DecimalJsLike | number | string | null
    privatePension?: Decimal | DecimalJsLike | number | string | null
    interpreterRequired: boolean
    monthlyIncome: JsonNullValueInput | InputJsonValue
    monthlyExpenses: JsonNullValueInput | InputJsonValue
    assets: JsonNullValueInput | InputJsonValue
    liabilities: JsonNullValueInput | InputJsonValue
  }

  export type ImmobillionApplicantDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryCurrencyOther?: NullableStringFieldUpdateOperationsInput | string | null
    hasPartTimeJob?: BoolFieldUpdateOperationsInput | boolean
    partTimeSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFreelancer?: BoolFieldUpdateOperationsInput | boolean
    isSelfEmployed?: BoolFieldUpdateOperationsInput | boolean
    selfEmployedAs?: NullableStringFieldUpdateOperationsInput | string | null
    selfEmployedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    selfEmployedCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesInHousehold?: IntFieldUpdateOperationsInput | number
    retirementStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutoryPension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    privatePension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolFieldUpdateOperationsInput | boolean
    monthlyIncome?: JsonNullValueInput | InputJsonValue
    monthlyExpenses?: JsonNullValueInput | InputJsonValue
    assets?: JsonNullValueInput | InputJsonValue
    liabilities?: JsonNullValueInput | InputJsonValue
  }

  export type ImmobillionApplicantDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryCurrencyOther?: NullableStringFieldUpdateOperationsInput | string | null
    hasPartTimeJob?: BoolFieldUpdateOperationsInput | boolean
    partTimeSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFreelancer?: BoolFieldUpdateOperationsInput | boolean
    isSelfEmployed?: BoolFieldUpdateOperationsInput | boolean
    selfEmployedAs?: NullableStringFieldUpdateOperationsInput | string | null
    selfEmployedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    selfEmployedCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesInHousehold?: IntFieldUpdateOperationsInput | number
    retirementStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutoryPension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    privatePension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolFieldUpdateOperationsInput | boolean
    monthlyIncome?: JsonNullValueInput | InputJsonValue
    monthlyExpenses?: JsonNullValueInput | InputJsonValue
    assets?: JsonNullValueInput | InputJsonValue
    liabilities?: JsonNullValueInput | InputJsonValue
  }

  export type ImmobillionFormCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType?: string
    formVersion?: string
    user: UserCreateNestedOneWithoutImmobillionFormsInput
    applicants?: ApplicantCreateNestedManyWithoutImmobillionFormInput
  }

  export type ImmobillionFormUncheckedCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    formType?: string
    formVersion?: string
    applicants?: ApplicantUncheckedCreateNestedManyWithoutImmobillionFormInput
  }

  export type ImmobillionFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutImmobillionFormsNestedInput
    applicants?: ApplicantUpdateManyWithoutImmobillionFormNestedInput
  }

  export type ImmobillionFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
    applicants?: ApplicantUncheckedUpdateManyWithoutImmobillionFormNestedInput
  }

  export type ImmobillionFormCreateManyInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    formType?: string
    formVersion?: string
  }

  export type ImmobillionFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
  }

  export type ImmobillionFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
  }

  export type AnalysisFormCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
    user: UserCreateNestedOneWithoutAnalysisFormsInput
    children?: ChildCreateNestedManyWithoutAnalysisFormInput
    applicants?: ApplicantCreateNestedManyWithoutAnalysisFormInput
  }

  export type AnalysisFormUncheckedCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutAnalysisFormInput
    applicants?: ApplicantUncheckedCreateNestedManyWithoutAnalysisFormInput
  }

  export type AnalysisFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalysisFormsNestedInput
    children?: ChildUpdateManyWithoutAnalysisFormNestedInput
    applicants?: ApplicantUpdateManyWithoutAnalysisFormNestedInput
  }

  export type AnalysisFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutAnalysisFormNestedInput
    applicants?: ApplicantUncheckedUpdateManyWithoutAnalysisFormNestedInput
  }

  export type AnalysisFormCreateManyInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
  }

  export type AnalysisFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalDetailsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
  }

  export type PersonalDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
  }

  export type EmploymentDetailsCreateInput = {
    id?: string
    employmentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employmentType: $Enums.EmploymentType
    occupation: string
    contractType: string
    contractDuration: string
    employerName: string
    employedSince: Date | string
    personalDetails: PersonalDetailsCreateNestedOneWithoutEmploymentDetailsInput
  }

  export type EmploymentDetailsUncheckedCreateInput = {
    id?: string
    employmentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    employmentType: $Enums.EmploymentType
    occupation: string
    contractType: string
    contractDuration: string
    employerName: string
    employedSince: Date | string
  }

  export type EmploymentDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    occupation?: StringFieldUpdateOperationsInput | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractDuration?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    employedSince?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutEmploymentDetailsNestedInput
  }

  export type EmploymentDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    occupation?: StringFieldUpdateOperationsInput | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractDuration?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    employedSince?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailsCreateManyInput = {
    id?: string
    employmentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    employmentType: $Enums.EmploymentType
    occupation: string
    contractType: string
    contractDuration: string
    employerName: string
    employedSince: Date | string
  }

  export type EmploymentDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    occupation?: StringFieldUpdateOperationsInput | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractDuration?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    employedSince?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    occupation?: StringFieldUpdateOperationsInput | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractDuration?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    employedSince?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeDetailsCreateInput = {
    id?: string
    incomeId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grossIncome: Decimal | DecimalJsLike | number | string
    netIncome: Decimal | DecimalJsLike | number | string
    taxClass: string
    taxId: string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    incomeTradeBusiness: Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork: Decimal | DecimalJsLike | number | string
    incomeSideJob: Decimal | DecimalJsLike | number | string
    personalDetails: PersonalDetailsCreateNestedOneWithoutIncomeDetailsInput
  }

  export type IncomeDetailsUncheckedCreateInput = {
    id?: string
    incomeId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    grossIncome: Decimal | DecimalJsLike | number | string
    netIncome: Decimal | DecimalJsLike | number | string
    taxClass: string
    taxId: string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    incomeTradeBusiness: Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork: Decimal | DecimalJsLike | number | string
    incomeSideJob: Decimal | DecimalJsLike | number | string
  }

  export type IncomeDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxClass?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutIncomeDetailsNestedInput
  }

  export type IncomeDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxClass?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type IncomeDetailsCreateManyInput = {
    id?: string
    incomeId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    grossIncome: Decimal | DecimalJsLike | number | string
    netIncome: Decimal | DecimalJsLike | number | string
    taxClass: string
    taxId: string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    incomeTradeBusiness: Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork: Decimal | DecimalJsLike | number | string
    incomeSideJob: Decimal | DecimalJsLike | number | string
  }

  export type IncomeDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxClass?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type IncomeDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxClass?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsCreateInput = {
    id?: string
    expensesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    personalDetails: PersonalDetailsCreateNestedOneWithoutExpensesDetailsInput
  }

  export type ExpensesDetailsUncheckedCreateInput = {
    id?: string
    expensesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    coldRent: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expensesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutExpensesDetailsNestedInput
  }

  export type ExpensesDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expensesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsCreateManyInput = {
    id?: string
    expensesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    coldRent: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expensesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expensesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AssetCreateInput = {
    id?: string
    assetId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstate: Decimal | DecimalJsLike | number | string
    securities: Decimal | DecimalJsLike | number | string
    bankDeposits: Decimal | DecimalJsLike | number | string
    buildingSavings: Decimal | DecimalJsLike | number | string
    insuranceValues: Decimal | DecimalJsLike | number | string
    otherAssets: Decimal | DecimalJsLike | number | string
    personalDetails: PersonalDetailsCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    assetId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    realEstate: Decimal | DecimalJsLike | number | string
    securities: Decimal | DecimalJsLike | number | string
    bankDeposits: Decimal | DecimalJsLike | number | string
    buildingSavings: Decimal | DecimalJsLike | number | string
    insuranceValues: Decimal | DecimalJsLike | number | string
    otherAssets: Decimal | DecimalJsLike | number | string
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    realEstate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AssetCreateManyInput = {
    id?: string
    assetId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    realEstate: Decimal | DecimalJsLike | number | string
    securities: Decimal | DecimalJsLike | number | string
    bankDeposits: Decimal | DecimalJsLike | number | string
    buildingSavings: Decimal | DecimalJsLike | number | string
    insuranceValues: Decimal | DecimalJsLike | number | string
    otherAssets: Decimal | DecimalJsLike | number | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    realEstate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LiabilityCreateInput = {
    id?: string
    liabilityId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loanType: $Enums.LoanType
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    personalDetails: PersonalDetailsCreateNestedOneWithoutLiabilitiesInput
  }

  export type LiabilityUncheckedCreateInput = {
    id?: string
    liabilityId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    loanType: $Enums.LoanType
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
  }

  export type LiabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    liabilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | $Enums.LoanType
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutLiabilitiesNestedInput
  }

  export type LiabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    liabilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | $Enums.LoanType
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LiabilityCreateManyInput = {
    id?: string
    liabilityId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    loanType: $Enums.LoanType
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
  }

  export type LiabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    liabilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | $Enums.LoanType
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LiabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    liabilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | $Enums.LoanType
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type GoalsAndWishesCreateInput = {
    id?: string
    goalsAndWishesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    retirementPlanning: string
    capitalFormation: string
    realEstateGoals: string
    financing: string
    protection: string
    healthcareProvision: string
    otherGoals: string
    personalDetails: PersonalDetailsCreateNestedOneWithoutGoalsAndWishesInput
  }

  export type GoalsAndWishesUncheckedCreateInput = {
    id?: string
    goalsAndWishesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    retirementPlanning: string
    capitalFormation: string
    realEstateGoals: string
    financing: string
    protection: string
    healthcareProvision: string
    otherGoals: string
  }

  export type GoalsAndWishesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalsAndWishesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retirementPlanning?: StringFieldUpdateOperationsInput | string
    capitalFormation?: StringFieldUpdateOperationsInput | string
    realEstateGoals?: StringFieldUpdateOperationsInput | string
    financing?: StringFieldUpdateOperationsInput | string
    protection?: StringFieldUpdateOperationsInput | string
    healthcareProvision?: StringFieldUpdateOperationsInput | string
    otherGoals?: StringFieldUpdateOperationsInput | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutGoalsAndWishesNestedInput
  }

  export type GoalsAndWishesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalsAndWishesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    retirementPlanning?: StringFieldUpdateOperationsInput | string
    capitalFormation?: StringFieldUpdateOperationsInput | string
    realEstateGoals?: StringFieldUpdateOperationsInput | string
    financing?: StringFieldUpdateOperationsInput | string
    protection?: StringFieldUpdateOperationsInput | string
    healthcareProvision?: StringFieldUpdateOperationsInput | string
    otherGoals?: StringFieldUpdateOperationsInput | string
  }

  export type GoalsAndWishesCreateManyInput = {
    id?: string
    goalsAndWishesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    retirementPlanning: string
    capitalFormation: string
    realEstateGoals: string
    financing: string
    protection: string
    healthcareProvision: string
    otherGoals: string
  }

  export type GoalsAndWishesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalsAndWishesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retirementPlanning?: StringFieldUpdateOperationsInput | string
    capitalFormation?: StringFieldUpdateOperationsInput | string
    realEstateGoals?: StringFieldUpdateOperationsInput | string
    financing?: StringFieldUpdateOperationsInput | string
    protection?: StringFieldUpdateOperationsInput | string
    healthcareProvision?: StringFieldUpdateOperationsInput | string
    otherGoals?: StringFieldUpdateOperationsInput | string
  }

  export type GoalsAndWishesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalsAndWishesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    retirementPlanning?: StringFieldUpdateOperationsInput | string
    capitalFormation?: StringFieldUpdateOperationsInput | string
    realEstateGoals?: StringFieldUpdateOperationsInput | string
    financing?: StringFieldUpdateOperationsInput | string
    protection?: StringFieldUpdateOperationsInput | string
    healthcareProvision?: StringFieldUpdateOperationsInput | string
    otherGoals?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAppetiteCreateInput = {
    id?: string
    riskAppetiteId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    riskAppetite: string
    investmentHorizon: string
    knowledgeExperience: string
    healthInsurance: string
    healthInsuranceNumber: string
    healthInsuranceProof: string
    personalDetails: PersonalDetailsCreateNestedOneWithoutRiskAppetiteInput
  }

  export type RiskAppetiteUncheckedCreateInput = {
    id?: string
    riskAppetiteId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    riskAppetite: string
    investmentHorizon: string
    knowledgeExperience: string
    healthInsurance: string
    healthInsuranceNumber: string
    healthInsuranceProof: string
  }

  export type RiskAppetiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskAppetiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskAppetite?: StringFieldUpdateOperationsInput | string
    investmentHorizon?: StringFieldUpdateOperationsInput | string
    knowledgeExperience?: StringFieldUpdateOperationsInput | string
    healthInsurance?: StringFieldUpdateOperationsInput | string
    healthInsuranceNumber?: StringFieldUpdateOperationsInput | string
    healthInsuranceProof?: StringFieldUpdateOperationsInput | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutRiskAppetiteNestedInput
  }

  export type RiskAppetiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskAppetiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    riskAppetite?: StringFieldUpdateOperationsInput | string
    investmentHorizon?: StringFieldUpdateOperationsInput | string
    knowledgeExperience?: StringFieldUpdateOperationsInput | string
    healthInsurance?: StringFieldUpdateOperationsInput | string
    healthInsuranceNumber?: StringFieldUpdateOperationsInput | string
    healthInsuranceProof?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAppetiteCreateManyInput = {
    id?: string
    riskAppetiteId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    riskAppetite: string
    investmentHorizon: string
    knowledgeExperience: string
    healthInsurance: string
    healthInsuranceNumber: string
    healthInsuranceProof: string
  }

  export type RiskAppetiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskAppetiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskAppetite?: StringFieldUpdateOperationsInput | string
    investmentHorizon?: StringFieldUpdateOperationsInput | string
    knowledgeExperience?: StringFieldUpdateOperationsInput | string
    healthInsurance?: StringFieldUpdateOperationsInput | string
    healthInsuranceNumber?: StringFieldUpdateOperationsInput | string
    healthInsuranceProof?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAppetiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskAppetiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    riskAppetite?: StringFieldUpdateOperationsInput | string
    investmentHorizon?: StringFieldUpdateOperationsInput | string
    knowledgeExperience?: StringFieldUpdateOperationsInput | string
    healthInsurance?: StringFieldUpdateOperationsInput | string
    healthInsuranceNumber?: StringFieldUpdateOperationsInput | string
    healthInsuranceProof?: StringFieldUpdateOperationsInput | string
  }

  export type ConsentCreateInput = {
    id?: string
    consentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consentType: $Enums.ConsentType
    consent: boolean
    consentText: string
    consentSignature: string
    consentDate: Date | string
    location: string
    personalDetails: PersonalDetailsCreateNestedOneWithoutConsentsInput
  }

  export type ConsentUncheckedCreateInput = {
    id?: string
    consentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    consentType: $Enums.ConsentType
    consent: boolean
    consentText: string
    consentSignature: string
    consentDate: Date | string
    location: string
  }

  export type ConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consent?: BoolFieldUpdateOperationsInput | boolean
    consentText?: StringFieldUpdateOperationsInput | string
    consentSignature?: StringFieldUpdateOperationsInput | string
    consentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutConsentsNestedInput
  }

  export type ConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consent?: BoolFieldUpdateOperationsInput | boolean
    consentText?: StringFieldUpdateOperationsInput | string
    consentSignature?: StringFieldUpdateOperationsInput | string
    consentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type ConsentCreateManyInput = {
    id?: string
    consentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    consentType: $Enums.ConsentType
    consent: boolean
    consentText: string
    consentSignature: string
    consentDate: Date | string
    location: string
  }

  export type ConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consent?: BoolFieldUpdateOperationsInput | boolean
    consentText?: StringFieldUpdateOperationsInput | string
    consentSignature?: StringFieldUpdateOperationsInput | string
    consentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type ConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consent?: BoolFieldUpdateOperationsInput | boolean
    consentText?: StringFieldUpdateOperationsInput | string
    consentSignature?: StringFieldUpdateOperationsInput | string
    consentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateInput = {
    id?: string
    documentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName: string
    documentLocation: string
    documentDate: Date | string
    personalDetails: PersonalDetailsCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    documentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    documentName: string
    documentLocation: string
    documentDate: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentLocation?: StringFieldUpdateOperationsInput | string
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentLocation?: StringFieldUpdateOperationsInput | string
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    documentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    documentName: string
    documentLocation: string
    documentDate: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentLocation?: StringFieldUpdateOperationsInput | string
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentLocation?: StringFieldUpdateOperationsInput | string
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateInput = {
    id?: string
    formId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType: $Enums.FormType
    formName: string
    formLink: string
    createdDate: Date | string
    updatedDate: Date | string
    personalDetails: PersonalDetailsCreateNestedOneWithoutFormsInput
  }

  export type FormUncheckedCreateInput = {
    id?: string
    formId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    formType: $Enums.FormType
    formName: string
    formLink: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type FormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    formName?: StringFieldUpdateOperationsInput | string
    formLink?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutFormsNestedInput
  }

  export type FormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    formType?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    formName?: StringFieldUpdateOperationsInput | string
    formLink?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateManyInput = {
    id?: string
    formId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    formType: $Enums.FormType
    formName: string
    formLink: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type FormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    formName?: StringFieldUpdateOperationsInput | string
    formLink?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    formType?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    formName?: StringFieldUpdateOperationsInput | string
    formLink?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFormCreateInput = {
    id?: string
    customFormId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formTemplate: string
    formName: string
    createdDate: Date | string
    updatedDate: Date | string
    personalDetails: PersonalDetailsCreateNestedOneWithoutCustomFormsInput
  }

  export type CustomFormUncheckedCreateInput = {
    id?: string
    customFormId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    formTemplate: string
    formName: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type CustomFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customFormId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formTemplate?: StringFieldUpdateOperationsInput | string
    formName?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailsUpdateOneRequiredWithoutCustomFormsNestedInput
  }

  export type CustomFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customFormId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    formTemplate?: StringFieldUpdateOperationsInput | string
    formName?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFormCreateManyInput = {
    id?: string
    customFormId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personalId: string
    formTemplate: string
    formName: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type CustomFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customFormId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formTemplate?: StringFieldUpdateOperationsInput | string
    formName?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customFormId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalId?: StringFieldUpdateOperationsInput | string
    formTemplate?: StringFieldUpdateOperationsInput | string
    formName?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type AnalysisFormListRelationFilter = {
    every?: AnalysisFormWhereInput
    some?: AnalysisFormWhereInput
    none?: AnalysisFormWhereInput
  }

  export type ImmobillionFormListRelationFilter = {
    every?: ImmobillionFormWhereInput
    some?: ImmobillionFormWhereInput
    none?: ImmobillionFormWhereInput
  }

  export type PersonalDetailsNullableScalarRelationFilter = {
    is?: PersonalDetailsWhereInput | null
    isNot?: PersonalDetailsWhereInput | null
  }

  export type PersonalDetailsListRelationFilter = {
    every?: PersonalDetailsWhereInput
    some?: PersonalDetailsWhereInput
    none?: PersonalDetailsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnalysisFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImmobillionFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    emailVerified?: SortOrder
    profileImage?: SortOrder
    phoneNumber?: SortOrder
    firebaseUid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    emailVerified?: SortOrder
    profileImage?: SortOrder
    phoneNumber?: SortOrder
    firebaseUid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    emailVerified?: SortOrder
    profileImage?: SortOrder
    phoneNumber?: SortOrder
    firebaseUid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisFormScalarRelationFilter = {
    is?: AnalysisFormWhereInput
    isNot?: AnalysisFormWhereInput
  }

  export type ChildCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    nationality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analysisFormId?: SortOrder
  }

  export type ChildMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    nationality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analysisFormId?: SortOrder
  }

  export type ChildMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    nationality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    analysisFormId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableListFilter<$PrismaModel = never> = {
    equals?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    has?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    hasEvery?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    hasSome?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type AnalysisFormNullableScalarRelationFilter = {
    is?: AnalysisFormWhereInput | null
    isNot?: AnalysisFormWhereInput | null
  }

  export type ImmobillionFormNullableScalarRelationFilter = {
    is?: ImmobillionFormWhereInput | null
    isNot?: ImmobillionFormWhereInput | null
  }

  export type ImmobillionApplicantDetailsNullableScalarRelationFilter = {
    is?: ImmobillionApplicantDetailsWhereInput | null
    isNot?: ImmobillionApplicantDetailsWhereInput | null
  }

  export type ApplicantCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salutation?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    maidenName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    birthCountry?: SortOrder
    nationality?: SortOrder
    isEUCitizen?: SortOrder
    residencePermit?: SortOrder
    inGermanySince?: SortOrder
    street?: SortOrder
    houseNumber?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    residentSince?: SortOrder
    previousAddress?: SortOrder
    phoneLandline?: SortOrder
    phoneMobile?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    maritalStatus?: SortOrder
    separationOfGoods?: SortOrder
    numberOfChildren?: SortOrder
    childrenBirthDates?: SortOrder
    profession?: SortOrder
    employmentType?: SortOrder
    employedSince?: SortOrder
    contractType?: SortOrder
    contractUntil?: SortOrder
    employerName?: SortOrder
    employerInGermany?: SortOrder
    netIncome?: SortOrder
    grossIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    iban?: SortOrder
    bic?: SortOrder
    analysisFormId?: SortOrder
    immobillionFormId?: SortOrder
  }

  export type ApplicantAvgOrderByAggregateInput = {
    numberOfChildren?: SortOrder
    netIncome?: SortOrder
    grossIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
  }

  export type ApplicantMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salutation?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    maidenName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    birthCountry?: SortOrder
    nationality?: SortOrder
    isEUCitizen?: SortOrder
    residencePermit?: SortOrder
    inGermanySince?: SortOrder
    street?: SortOrder
    houseNumber?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    residentSince?: SortOrder
    phoneLandline?: SortOrder
    phoneMobile?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    maritalStatus?: SortOrder
    separationOfGoods?: SortOrder
    numberOfChildren?: SortOrder
    profession?: SortOrder
    employmentType?: SortOrder
    employedSince?: SortOrder
    contractType?: SortOrder
    contractUntil?: SortOrder
    employerName?: SortOrder
    employerInGermany?: SortOrder
    netIncome?: SortOrder
    grossIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    iban?: SortOrder
    bic?: SortOrder
    analysisFormId?: SortOrder
    immobillionFormId?: SortOrder
  }

  export type ApplicantMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salutation?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    maidenName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    birthCountry?: SortOrder
    nationality?: SortOrder
    isEUCitizen?: SortOrder
    residencePermit?: SortOrder
    inGermanySince?: SortOrder
    street?: SortOrder
    houseNumber?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    residentSince?: SortOrder
    phoneLandline?: SortOrder
    phoneMobile?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    maritalStatus?: SortOrder
    separationOfGoods?: SortOrder
    numberOfChildren?: SortOrder
    profession?: SortOrder
    employmentType?: SortOrder
    employedSince?: SortOrder
    contractType?: SortOrder
    contractUntil?: SortOrder
    employerName?: SortOrder
    employerInGermany?: SortOrder
    netIncome?: SortOrder
    grossIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    iban?: SortOrder
    bic?: SortOrder
    analysisFormId?: SortOrder
    immobillionFormId?: SortOrder
  }

  export type ApplicantSumOrderByAggregateInput = {
    numberOfChildren?: SortOrder
    netIncome?: SortOrder
    grossIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ApplicantScalarRelationFilter = {
    is?: ApplicantWhereInput
    isNot?: ApplicantWhereInput
  }

  export type ImmobillionApplicantDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    salaryCurrency?: SortOrder
    salaryCurrencyOther?: SortOrder
    hasPartTimeJob?: SortOrder
    partTimeSince?: SortOrder
    isFreelancer?: SortOrder
    isSelfEmployed?: SortOrder
    selfEmployedAs?: SortOrder
    selfEmployedSince?: SortOrder
    selfEmployedCompany?: SortOrder
    vehiclesInHousehold?: SortOrder
    retirementStart?: SortOrder
    statutoryPension?: SortOrder
    privatePension?: SortOrder
    interpreterRequired?: SortOrder
    monthlyIncome?: SortOrder
    monthlyExpenses?: SortOrder
    assets?: SortOrder
    liabilities?: SortOrder
  }

  export type ImmobillionApplicantDetailsAvgOrderByAggregateInput = {
    vehiclesInHousehold?: SortOrder
    statutoryPension?: SortOrder
    privatePension?: SortOrder
  }

  export type ImmobillionApplicantDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    salaryCurrency?: SortOrder
    salaryCurrencyOther?: SortOrder
    hasPartTimeJob?: SortOrder
    partTimeSince?: SortOrder
    isFreelancer?: SortOrder
    isSelfEmployed?: SortOrder
    selfEmployedAs?: SortOrder
    selfEmployedSince?: SortOrder
    selfEmployedCompany?: SortOrder
    vehiclesInHousehold?: SortOrder
    retirementStart?: SortOrder
    statutoryPension?: SortOrder
    privatePension?: SortOrder
    interpreterRequired?: SortOrder
  }

  export type ImmobillionApplicantDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    salaryCurrency?: SortOrder
    salaryCurrencyOther?: SortOrder
    hasPartTimeJob?: SortOrder
    partTimeSince?: SortOrder
    isFreelancer?: SortOrder
    isSelfEmployed?: SortOrder
    selfEmployedAs?: SortOrder
    selfEmployedSince?: SortOrder
    selfEmployedCompany?: SortOrder
    vehiclesInHousehold?: SortOrder
    retirementStart?: SortOrder
    statutoryPension?: SortOrder
    privatePension?: SortOrder
    interpreterRequired?: SortOrder
  }

  export type ImmobillionApplicantDetailsSumOrderByAggregateInput = {
    vehiclesInHousehold?: SortOrder
    statutoryPension?: SortOrder
    privatePension?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ApplicantListRelationFilter = {
    every?: ApplicantWhereInput
    some?: ApplicantWhereInput
    none?: ApplicantWhereInput
  }

  export type ApplicantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImmobillionFormCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    formType?: SortOrder
    formVersion?: SortOrder
  }

  export type ImmobillionFormMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    formType?: SortOrder
    formVersion?: SortOrder
  }

  export type ImmobillionFormMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    formType?: SortOrder
    formVersion?: SortOrder
  }

  export type ChildListRelationFilter = {
    every?: ChildWhereInput
    some?: ChildWhereInput
    none?: ChildWhereInput
  }

  export type ChildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalysisFormCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    consultantName?: SortOrder
    officeLocation?: SortOrder
    analysisDate?: SortOrder
    coldRent?: SortOrder
    gas?: SortOrder
    electricity?: SortOrder
    telecommunication?: SortOrder
    subscriptions?: SortOrder
    accountMaintenanceFee?: SortOrder
    livingExpenses?: SortOrder
    alimony?: SortOrder
    otherExpenses?: SortOrder
    addLoanOrLeasing?: SortOrder
    loanBank?: SortOrder
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
    analysisConsent?: SortOrder
    analysisConsentText?: SortOrder
    analysisConsentSignature?: SortOrder
    analysisLocation?: SortOrder
    analysisConsentDate?: SortOrder
  }

  export type AnalysisFormAvgOrderByAggregateInput = {
    coldRent?: SortOrder
    gas?: SortOrder
    electricity?: SortOrder
    telecommunication?: SortOrder
    subscriptions?: SortOrder
    accountMaintenanceFee?: SortOrder
    livingExpenses?: SortOrder
    alimony?: SortOrder
    otherExpenses?: SortOrder
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
  }

  export type AnalysisFormMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    consultantName?: SortOrder
    officeLocation?: SortOrder
    analysisDate?: SortOrder
    coldRent?: SortOrder
    gas?: SortOrder
    electricity?: SortOrder
    telecommunication?: SortOrder
    subscriptions?: SortOrder
    accountMaintenanceFee?: SortOrder
    livingExpenses?: SortOrder
    alimony?: SortOrder
    otherExpenses?: SortOrder
    addLoanOrLeasing?: SortOrder
    loanBank?: SortOrder
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
    analysisConsent?: SortOrder
    analysisConsentText?: SortOrder
    analysisConsentSignature?: SortOrder
    analysisLocation?: SortOrder
    analysisConsentDate?: SortOrder
  }

  export type AnalysisFormMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    consultantName?: SortOrder
    officeLocation?: SortOrder
    analysisDate?: SortOrder
    coldRent?: SortOrder
    gas?: SortOrder
    electricity?: SortOrder
    telecommunication?: SortOrder
    subscriptions?: SortOrder
    accountMaintenanceFee?: SortOrder
    livingExpenses?: SortOrder
    alimony?: SortOrder
    otherExpenses?: SortOrder
    addLoanOrLeasing?: SortOrder
    loanBank?: SortOrder
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
    analysisConsent?: SortOrder
    analysisConsentText?: SortOrder
    analysisConsentSignature?: SortOrder
    analysisLocation?: SortOrder
    analysisConsentDate?: SortOrder
  }

  export type AnalysisFormSumOrderByAggregateInput = {
    coldRent?: SortOrder
    gas?: SortOrder
    electricity?: SortOrder
    telecommunication?: SortOrder
    subscriptions?: SortOrder
    accountMaintenanceFee?: SortOrder
    livingExpenses?: SortOrder
    alimony?: SortOrder
    otherExpenses?: SortOrder
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
  }

  export type EnumApplicantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantType | EnumApplicantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantTypeFilter<$PrismaModel> | $Enums.ApplicantType
  }

  export type EmploymentDetailsListRelationFilter = {
    every?: EmploymentDetailsWhereInput
    some?: EmploymentDetailsWhereInput
    none?: EmploymentDetailsWhereInput
  }

  export type IncomeDetailsListRelationFilter = {
    every?: IncomeDetailsWhereInput
    some?: IncomeDetailsWhereInput
    none?: IncomeDetailsWhereInput
  }

  export type ExpensesDetailsListRelationFilter = {
    every?: ExpensesDetailsWhereInput
    some?: ExpensesDetailsWhereInput
    none?: ExpensesDetailsWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type LiabilityListRelationFilter = {
    every?: LiabilityWhereInput
    some?: LiabilityWhereInput
    none?: LiabilityWhereInput
  }

  export type GoalsAndWishesNullableScalarRelationFilter = {
    is?: GoalsAndWishesWhereInput | null
    isNot?: GoalsAndWishesWhereInput | null
  }

  export type RiskAppetiteNullableScalarRelationFilter = {
    is?: RiskAppetiteWhereInput | null
    isNot?: RiskAppetiteWhereInput | null
  }

  export type ConsentListRelationFilter = {
    every?: ConsentWhereInput
    some?: ConsentWhereInput
    none?: ConsentWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type FormListRelationFilter = {
    every?: FormWhereInput
    some?: FormWhereInput
    none?: FormWhereInput
  }

  export type CustomFormListRelationFilter = {
    every?: CustomFormWhereInput
    some?: CustomFormWhereInput
    none?: CustomFormWhereInput
  }

  export type EmploymentDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncomeDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpensesDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coachId?: SortOrder
    applicantType?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    streetAddress?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    housing?: SortOrder
  }

  export type PersonalDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coachId?: SortOrder
    applicantType?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    streetAddress?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    housing?: SortOrder
  }

  export type PersonalDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coachId?: SortOrder
    applicantType?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    streetAddress?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    housing?: SortOrder
  }

  export type EnumApplicantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantType | EnumApplicantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicantTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicantTypeFilter<$PrismaModel>
  }

  export type EnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type PersonalDetailsScalarRelationFilter = {
    is?: PersonalDetailsWhereInput
    isNot?: PersonalDetailsWhereInput
  }

  export type EmploymentDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    employmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    employmentType?: SortOrder
    occupation?: SortOrder
    contractType?: SortOrder
    contractDuration?: SortOrder
    employerName?: SortOrder
    employedSince?: SortOrder
  }

  export type EmploymentDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    employmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    employmentType?: SortOrder
    occupation?: SortOrder
    contractType?: SortOrder
    contractDuration?: SortOrder
    employerName?: SortOrder
    employedSince?: SortOrder
  }

  export type EmploymentDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    employmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    employmentType?: SortOrder
    occupation?: SortOrder
    contractType?: SortOrder
    contractDuration?: SortOrder
    employerName?: SortOrder
    employedSince?: SortOrder
  }

  export type EnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type IncomeDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    incomeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    grossIncome?: SortOrder
    netIncome?: SortOrder
    taxClass?: SortOrder
    taxId?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    incomeTradeBusiness?: SortOrder
    incomeSelfEmployedWork?: SortOrder
    incomeSideJob?: SortOrder
  }

  export type IncomeDetailsAvgOrderByAggregateInput = {
    grossIncome?: SortOrder
    netIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    incomeTradeBusiness?: SortOrder
    incomeSelfEmployedWork?: SortOrder
    incomeSideJob?: SortOrder
  }

  export type IncomeDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    incomeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    grossIncome?: SortOrder
    netIncome?: SortOrder
    taxClass?: SortOrder
    taxId?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    incomeTradeBusiness?: SortOrder
    incomeSelfEmployedWork?: SortOrder
    incomeSideJob?: SortOrder
  }

  export type IncomeDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    incomeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    grossIncome?: SortOrder
    netIncome?: SortOrder
    taxClass?: SortOrder
    taxId?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    incomeTradeBusiness?: SortOrder
    incomeSelfEmployedWork?: SortOrder
    incomeSideJob?: SortOrder
  }

  export type IncomeDetailsSumOrderByAggregateInput = {
    grossIncome?: SortOrder
    netIncome?: SortOrder
    numberOfSalaries?: SortOrder
    childBenefit?: SortOrder
    otherIncome?: SortOrder
    incomeTradeBusiness?: SortOrder
    incomeSelfEmployedWork?: SortOrder
    incomeSideJob?: SortOrder
  }

  export type ExpensesDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    expensesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    coldRent?: SortOrder
    electricity?: SortOrder
    livingExpenses?: SortOrder
    gas?: SortOrder
    telecommunication?: SortOrder
    accountMaintenanceFee?: SortOrder
    alimony?: SortOrder
    subscriptions?: SortOrder
    otherExpenses?: SortOrder
  }

  export type ExpensesDetailsAvgOrderByAggregateInput = {
    coldRent?: SortOrder
    electricity?: SortOrder
    livingExpenses?: SortOrder
    gas?: SortOrder
    telecommunication?: SortOrder
    accountMaintenanceFee?: SortOrder
    alimony?: SortOrder
    subscriptions?: SortOrder
    otherExpenses?: SortOrder
  }

  export type ExpensesDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    expensesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    coldRent?: SortOrder
    electricity?: SortOrder
    livingExpenses?: SortOrder
    gas?: SortOrder
    telecommunication?: SortOrder
    accountMaintenanceFee?: SortOrder
    alimony?: SortOrder
    subscriptions?: SortOrder
    otherExpenses?: SortOrder
  }

  export type ExpensesDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    expensesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    coldRent?: SortOrder
    electricity?: SortOrder
    livingExpenses?: SortOrder
    gas?: SortOrder
    telecommunication?: SortOrder
    accountMaintenanceFee?: SortOrder
    alimony?: SortOrder
    subscriptions?: SortOrder
    otherExpenses?: SortOrder
  }

  export type ExpensesDetailsSumOrderByAggregateInput = {
    coldRent?: SortOrder
    electricity?: SortOrder
    livingExpenses?: SortOrder
    gas?: SortOrder
    telecommunication?: SortOrder
    accountMaintenanceFee?: SortOrder
    alimony?: SortOrder
    subscriptions?: SortOrder
    otherExpenses?: SortOrder
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    realEstate?: SortOrder
    securities?: SortOrder
    bankDeposits?: SortOrder
    buildingSavings?: SortOrder
    insuranceValues?: SortOrder
    otherAssets?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    realEstate?: SortOrder
    securities?: SortOrder
    bankDeposits?: SortOrder
    buildingSavings?: SortOrder
    insuranceValues?: SortOrder
    otherAssets?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    realEstate?: SortOrder
    securities?: SortOrder
    bankDeposits?: SortOrder
    buildingSavings?: SortOrder
    insuranceValues?: SortOrder
    otherAssets?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    realEstate?: SortOrder
    securities?: SortOrder
    bankDeposits?: SortOrder
    buildingSavings?: SortOrder
    insuranceValues?: SortOrder
    otherAssets?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    realEstate?: SortOrder
    securities?: SortOrder
    bankDeposits?: SortOrder
    buildingSavings?: SortOrder
    insuranceValues?: SortOrder
    otherAssets?: SortOrder
  }

  export type EnumLoanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanType | EnumLoanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoanType[] | ListEnumLoanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanType[] | ListEnumLoanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanTypeFilter<$PrismaModel> | $Enums.LoanType
  }

  export type LiabilityCountOrderByAggregateInput = {
    id?: SortOrder
    liabilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    loanType?: SortOrder
    loanBank?: SortOrder
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
  }

  export type LiabilityAvgOrderByAggregateInput = {
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
  }

  export type LiabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    liabilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    loanType?: SortOrder
    loanBank?: SortOrder
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
  }

  export type LiabilityMinOrderByAggregateInput = {
    id?: SortOrder
    liabilityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    loanType?: SortOrder
    loanBank?: SortOrder
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
  }

  export type LiabilitySumOrderByAggregateInput = {
    loanAmount?: SortOrder
    loanMonthlyRate?: SortOrder
    loanInterest?: SortOrder
  }

  export type EnumLoanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanType | EnumLoanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoanType[] | ListEnumLoanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanType[] | ListEnumLoanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoanTypeFilter<$PrismaModel>
    _max?: NestedEnumLoanTypeFilter<$PrismaModel>
  }

  export type GoalsAndWishesCountOrderByAggregateInput = {
    id?: SortOrder
    goalsAndWishesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    retirementPlanning?: SortOrder
    capitalFormation?: SortOrder
    realEstateGoals?: SortOrder
    financing?: SortOrder
    protection?: SortOrder
    healthcareProvision?: SortOrder
    otherGoals?: SortOrder
  }

  export type GoalsAndWishesMaxOrderByAggregateInput = {
    id?: SortOrder
    goalsAndWishesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    retirementPlanning?: SortOrder
    capitalFormation?: SortOrder
    realEstateGoals?: SortOrder
    financing?: SortOrder
    protection?: SortOrder
    healthcareProvision?: SortOrder
    otherGoals?: SortOrder
  }

  export type GoalsAndWishesMinOrderByAggregateInput = {
    id?: SortOrder
    goalsAndWishesId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    retirementPlanning?: SortOrder
    capitalFormation?: SortOrder
    realEstateGoals?: SortOrder
    financing?: SortOrder
    protection?: SortOrder
    healthcareProvision?: SortOrder
    otherGoals?: SortOrder
  }

  export type RiskAppetiteCountOrderByAggregateInput = {
    id?: SortOrder
    riskAppetiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    riskAppetite?: SortOrder
    investmentHorizon?: SortOrder
    knowledgeExperience?: SortOrder
    healthInsurance?: SortOrder
    healthInsuranceNumber?: SortOrder
    healthInsuranceProof?: SortOrder
  }

  export type RiskAppetiteMaxOrderByAggregateInput = {
    id?: SortOrder
    riskAppetiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    riskAppetite?: SortOrder
    investmentHorizon?: SortOrder
    knowledgeExperience?: SortOrder
    healthInsurance?: SortOrder
    healthInsuranceNumber?: SortOrder
    healthInsuranceProof?: SortOrder
  }

  export type RiskAppetiteMinOrderByAggregateInput = {
    id?: SortOrder
    riskAppetiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    riskAppetite?: SortOrder
    investmentHorizon?: SortOrder
    knowledgeExperience?: SortOrder
    healthInsurance?: SortOrder
    healthInsuranceNumber?: SortOrder
    healthInsuranceProof?: SortOrder
  }

  export type EnumConsentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentTypeFilter<$PrismaModel> | $Enums.ConsentType
  }

  export type ConsentCountOrderByAggregateInput = {
    id?: SortOrder
    consentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    consentType?: SortOrder
    consent?: SortOrder
    consentText?: SortOrder
    consentSignature?: SortOrder
    consentDate?: SortOrder
    location?: SortOrder
  }

  export type ConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    consentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    consentType?: SortOrder
    consent?: SortOrder
    consentText?: SortOrder
    consentSignature?: SortOrder
    consentDate?: SortOrder
    location?: SortOrder
  }

  export type ConsentMinOrderByAggregateInput = {
    id?: SortOrder
    consentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    consentType?: SortOrder
    consent?: SortOrder
    consentText?: SortOrder
    consentSignature?: SortOrder
    consentDate?: SortOrder
    location?: SortOrder
  }

  export type EnumConsentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConsentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentTypeFilter<$PrismaModel>
    _max?: NestedEnumConsentTypeFilter<$PrismaModel>
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    documentName?: SortOrder
    documentLocation?: SortOrder
    documentDate?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    documentName?: SortOrder
    documentLocation?: SortOrder
    documentDate?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    documentName?: SortOrder
    documentLocation?: SortOrder
    documentDate?: SortOrder
  }

  export type EnumFormTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FormType | EnumFormTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTypeFilter<$PrismaModel> | $Enums.FormType
  }

  export type FormCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formType?: SortOrder
    formName?: SortOrder
    formLink?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type FormMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formType?: SortOrder
    formName?: SortOrder
    formLink?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type FormMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formType?: SortOrder
    formName?: SortOrder
    formLink?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type EnumFormTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormType | EnumFormTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTypeWithAggregatesFilter<$PrismaModel> | $Enums.FormType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormTypeFilter<$PrismaModel>
    _max?: NestedEnumFormTypeFilter<$PrismaModel>
  }

  export type CustomFormCountOrderByAggregateInput = {
    id?: SortOrder
    customFormId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formTemplate?: SortOrder
    formName?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type CustomFormMaxOrderByAggregateInput = {
    id?: SortOrder
    customFormId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formTemplate?: SortOrder
    formName?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type CustomFormMinOrderByAggregateInput = {
    id?: SortOrder
    customFormId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalId?: SortOrder
    formTemplate?: SortOrder
    formName?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type AnalysisFormCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalysisFormCreateWithoutUserInput, AnalysisFormUncheckedCreateWithoutUserInput> | AnalysisFormCreateWithoutUserInput[] | AnalysisFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisFormCreateOrConnectWithoutUserInput | AnalysisFormCreateOrConnectWithoutUserInput[]
    createMany?: AnalysisFormCreateManyUserInputEnvelope
    connect?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
  }

  export type ImmobillionFormCreateNestedManyWithoutUserInput = {
    create?: XOR<ImmobillionFormCreateWithoutUserInput, ImmobillionFormUncheckedCreateWithoutUserInput> | ImmobillionFormCreateWithoutUserInput[] | ImmobillionFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImmobillionFormCreateOrConnectWithoutUserInput | ImmobillionFormCreateOrConnectWithoutUserInput[]
    createMany?: ImmobillionFormCreateManyUserInputEnvelope
    connect?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
  }

  export type PersonalDetailsCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalDetailsCreateWithoutUserInput, PersonalDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutUserInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsCreateNestedManyWithoutCoachInput = {
    create?: XOR<PersonalDetailsCreateWithoutCoachInput, PersonalDetailsUncheckedCreateWithoutCoachInput> | PersonalDetailsCreateWithoutCoachInput[] | PersonalDetailsUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCoachInput | PersonalDetailsCreateOrConnectWithoutCoachInput[]
    createMany?: PersonalDetailsCreateManyCoachInputEnvelope
    connect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
  }

  export type AnalysisFormUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalysisFormCreateWithoutUserInput, AnalysisFormUncheckedCreateWithoutUserInput> | AnalysisFormCreateWithoutUserInput[] | AnalysisFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisFormCreateOrConnectWithoutUserInput | AnalysisFormCreateOrConnectWithoutUserInput[]
    createMany?: AnalysisFormCreateManyUserInputEnvelope
    connect?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
  }

  export type ImmobillionFormUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ImmobillionFormCreateWithoutUserInput, ImmobillionFormUncheckedCreateWithoutUserInput> | ImmobillionFormCreateWithoutUserInput[] | ImmobillionFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImmobillionFormCreateOrConnectWithoutUserInput | ImmobillionFormCreateOrConnectWithoutUserInput[]
    createMany?: ImmobillionFormCreateManyUserInputEnvelope
    connect?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
  }

  export type PersonalDetailsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalDetailsCreateWithoutUserInput, PersonalDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutUserInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<PersonalDetailsCreateWithoutCoachInput, PersonalDetailsUncheckedCreateWithoutCoachInput> | PersonalDetailsCreateWithoutCoachInput[] | PersonalDetailsUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCoachInput | PersonalDetailsCreateOrConnectWithoutCoachInput[]
    createMany?: PersonalDetailsCreateManyCoachInputEnvelope
    connect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type AnalysisFormUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalysisFormCreateWithoutUserInput, AnalysisFormUncheckedCreateWithoutUserInput> | AnalysisFormCreateWithoutUserInput[] | AnalysisFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisFormCreateOrConnectWithoutUserInput | AnalysisFormCreateOrConnectWithoutUserInput[]
    upsert?: AnalysisFormUpsertWithWhereUniqueWithoutUserInput | AnalysisFormUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalysisFormCreateManyUserInputEnvelope
    set?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
    disconnect?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
    delete?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
    connect?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
    update?: AnalysisFormUpdateWithWhereUniqueWithoutUserInput | AnalysisFormUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalysisFormUpdateManyWithWhereWithoutUserInput | AnalysisFormUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalysisFormScalarWhereInput | AnalysisFormScalarWhereInput[]
  }

  export type ImmobillionFormUpdateManyWithoutUserNestedInput = {
    create?: XOR<ImmobillionFormCreateWithoutUserInput, ImmobillionFormUncheckedCreateWithoutUserInput> | ImmobillionFormCreateWithoutUserInput[] | ImmobillionFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImmobillionFormCreateOrConnectWithoutUserInput | ImmobillionFormCreateOrConnectWithoutUserInput[]
    upsert?: ImmobillionFormUpsertWithWhereUniqueWithoutUserInput | ImmobillionFormUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ImmobillionFormCreateManyUserInputEnvelope
    set?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
    disconnect?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
    delete?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
    connect?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
    update?: ImmobillionFormUpdateWithWhereUniqueWithoutUserInput | ImmobillionFormUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ImmobillionFormUpdateManyWithWhereWithoutUserInput | ImmobillionFormUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ImmobillionFormScalarWhereInput | ImmobillionFormScalarWhereInput[]
  }

  export type PersonalDetailsUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutUserInput, PersonalDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutUserInput
    upsert?: PersonalDetailsUpsertWithoutUserInput
    disconnect?: PersonalDetailsWhereInput | boolean
    delete?: PersonalDetailsWhereInput | boolean
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutUserInput, PersonalDetailsUpdateWithoutUserInput>, PersonalDetailsUncheckedUpdateWithoutUserInput>
  }

  export type PersonalDetailsUpdateManyWithoutCoachNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutCoachInput, PersonalDetailsUncheckedCreateWithoutCoachInput> | PersonalDetailsCreateWithoutCoachInput[] | PersonalDetailsUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCoachInput | PersonalDetailsCreateOrConnectWithoutCoachInput[]
    upsert?: PersonalDetailsUpsertWithWhereUniqueWithoutCoachInput | PersonalDetailsUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: PersonalDetailsCreateManyCoachInputEnvelope
    set?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    disconnect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    delete?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    connect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    update?: PersonalDetailsUpdateWithWhereUniqueWithoutCoachInput | PersonalDetailsUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: PersonalDetailsUpdateManyWithWhereWithoutCoachInput | PersonalDetailsUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: PersonalDetailsScalarWhereInput | PersonalDetailsScalarWhereInput[]
  }

  export type AnalysisFormUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalysisFormCreateWithoutUserInput, AnalysisFormUncheckedCreateWithoutUserInput> | AnalysisFormCreateWithoutUserInput[] | AnalysisFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisFormCreateOrConnectWithoutUserInput | AnalysisFormCreateOrConnectWithoutUserInput[]
    upsert?: AnalysisFormUpsertWithWhereUniqueWithoutUserInput | AnalysisFormUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalysisFormCreateManyUserInputEnvelope
    set?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
    disconnect?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
    delete?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
    connect?: AnalysisFormWhereUniqueInput | AnalysisFormWhereUniqueInput[]
    update?: AnalysisFormUpdateWithWhereUniqueWithoutUserInput | AnalysisFormUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalysisFormUpdateManyWithWhereWithoutUserInput | AnalysisFormUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalysisFormScalarWhereInput | AnalysisFormScalarWhereInput[]
  }

  export type ImmobillionFormUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ImmobillionFormCreateWithoutUserInput, ImmobillionFormUncheckedCreateWithoutUserInput> | ImmobillionFormCreateWithoutUserInput[] | ImmobillionFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImmobillionFormCreateOrConnectWithoutUserInput | ImmobillionFormCreateOrConnectWithoutUserInput[]
    upsert?: ImmobillionFormUpsertWithWhereUniqueWithoutUserInput | ImmobillionFormUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ImmobillionFormCreateManyUserInputEnvelope
    set?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
    disconnect?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
    delete?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
    connect?: ImmobillionFormWhereUniqueInput | ImmobillionFormWhereUniqueInput[]
    update?: ImmobillionFormUpdateWithWhereUniqueWithoutUserInput | ImmobillionFormUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ImmobillionFormUpdateManyWithWhereWithoutUserInput | ImmobillionFormUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ImmobillionFormScalarWhereInput | ImmobillionFormScalarWhereInput[]
  }

  export type PersonalDetailsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutUserInput, PersonalDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutUserInput
    upsert?: PersonalDetailsUpsertWithoutUserInput
    disconnect?: PersonalDetailsWhereInput | boolean
    delete?: PersonalDetailsWhereInput | boolean
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutUserInput, PersonalDetailsUpdateWithoutUserInput>, PersonalDetailsUncheckedUpdateWithoutUserInput>
  }

  export type PersonalDetailsUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutCoachInput, PersonalDetailsUncheckedCreateWithoutCoachInput> | PersonalDetailsCreateWithoutCoachInput[] | PersonalDetailsUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCoachInput | PersonalDetailsCreateOrConnectWithoutCoachInput[]
    upsert?: PersonalDetailsUpsertWithWhereUniqueWithoutCoachInput | PersonalDetailsUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: PersonalDetailsCreateManyCoachInputEnvelope
    set?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    disconnect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    delete?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    connect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    update?: PersonalDetailsUpdateWithWhereUniqueWithoutCoachInput | PersonalDetailsUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: PersonalDetailsUpdateManyWithWhereWithoutCoachInput | PersonalDetailsUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: PersonalDetailsScalarWhereInput | PersonalDetailsScalarWhereInput[]
  }

  export type RoleCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AnalysisFormCreateNestedOneWithoutChildrenInput = {
    create?: XOR<AnalysisFormCreateWithoutChildrenInput, AnalysisFormUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AnalysisFormCreateOrConnectWithoutChildrenInput
    connect?: AnalysisFormWhereUniqueInput
  }

  export type AnalysisFormUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<AnalysisFormCreateWithoutChildrenInput, AnalysisFormUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AnalysisFormCreateOrConnectWithoutChildrenInput
    upsert?: AnalysisFormUpsertWithoutChildrenInput
    connect?: AnalysisFormWhereUniqueInput
    update?: XOR<XOR<AnalysisFormUpdateToOneWithWhereWithoutChildrenInput, AnalysisFormUpdateWithoutChildrenInput>, AnalysisFormUncheckedUpdateWithoutChildrenInput>
  }

  export type ApplicantCreatechildrenBirthDatesInput = {
    set: Date[] | string[]
  }

  export type AnalysisFormCreateNestedOneWithoutApplicantsInput = {
    create?: XOR<AnalysisFormCreateWithoutApplicantsInput, AnalysisFormUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: AnalysisFormCreateOrConnectWithoutApplicantsInput
    connect?: AnalysisFormWhereUniqueInput
  }

  export type ImmobillionFormCreateNestedOneWithoutApplicantsInput = {
    create?: XOR<ImmobillionFormCreateWithoutApplicantsInput, ImmobillionFormUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: ImmobillionFormCreateOrConnectWithoutApplicantsInput
    connect?: ImmobillionFormWhereUniqueInput
  }

  export type ImmobillionApplicantDetailsCreateNestedOneWithoutApplicantInput = {
    create?: XOR<ImmobillionApplicantDetailsCreateWithoutApplicantInput, ImmobillionApplicantDetailsUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: ImmobillionApplicantDetailsCreateOrConnectWithoutApplicantInput
    connect?: ImmobillionApplicantDetailsWhereUniqueInput
  }

  export type ImmobillionApplicantDetailsUncheckedCreateNestedOneWithoutApplicantInput = {
    create?: XOR<ImmobillionApplicantDetailsCreateWithoutApplicantInput, ImmobillionApplicantDetailsUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: ImmobillionApplicantDetailsCreateOrConnectWithoutApplicantInput
    connect?: ImmobillionApplicantDetailsWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ApplicantUpdatechildrenBirthDatesInput = {
    set?: Date[] | string[]
    push?: Date | string | Date[] | string[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AnalysisFormUpdateOneWithoutApplicantsNestedInput = {
    create?: XOR<AnalysisFormCreateWithoutApplicantsInput, AnalysisFormUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: AnalysisFormCreateOrConnectWithoutApplicantsInput
    upsert?: AnalysisFormUpsertWithoutApplicantsInput
    disconnect?: AnalysisFormWhereInput | boolean
    delete?: AnalysisFormWhereInput | boolean
    connect?: AnalysisFormWhereUniqueInput
    update?: XOR<XOR<AnalysisFormUpdateToOneWithWhereWithoutApplicantsInput, AnalysisFormUpdateWithoutApplicantsInput>, AnalysisFormUncheckedUpdateWithoutApplicantsInput>
  }

  export type ImmobillionFormUpdateOneWithoutApplicantsNestedInput = {
    create?: XOR<ImmobillionFormCreateWithoutApplicantsInput, ImmobillionFormUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: ImmobillionFormCreateOrConnectWithoutApplicantsInput
    upsert?: ImmobillionFormUpsertWithoutApplicantsInput
    disconnect?: ImmobillionFormWhereInput | boolean
    delete?: ImmobillionFormWhereInput | boolean
    connect?: ImmobillionFormWhereUniqueInput
    update?: XOR<XOR<ImmobillionFormUpdateToOneWithWhereWithoutApplicantsInput, ImmobillionFormUpdateWithoutApplicantsInput>, ImmobillionFormUncheckedUpdateWithoutApplicantsInput>
  }

  export type ImmobillionApplicantDetailsUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<ImmobillionApplicantDetailsCreateWithoutApplicantInput, ImmobillionApplicantDetailsUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: ImmobillionApplicantDetailsCreateOrConnectWithoutApplicantInput
    upsert?: ImmobillionApplicantDetailsUpsertWithoutApplicantInput
    disconnect?: ImmobillionApplicantDetailsWhereInput | boolean
    delete?: ImmobillionApplicantDetailsWhereInput | boolean
    connect?: ImmobillionApplicantDetailsWhereUniqueInput
    update?: XOR<XOR<ImmobillionApplicantDetailsUpdateToOneWithWhereWithoutApplicantInput, ImmobillionApplicantDetailsUpdateWithoutApplicantInput>, ImmobillionApplicantDetailsUncheckedUpdateWithoutApplicantInput>
  }

  export type ImmobillionApplicantDetailsUncheckedUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<ImmobillionApplicantDetailsCreateWithoutApplicantInput, ImmobillionApplicantDetailsUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: ImmobillionApplicantDetailsCreateOrConnectWithoutApplicantInput
    upsert?: ImmobillionApplicantDetailsUpsertWithoutApplicantInput
    disconnect?: ImmobillionApplicantDetailsWhereInput | boolean
    delete?: ImmobillionApplicantDetailsWhereInput | boolean
    connect?: ImmobillionApplicantDetailsWhereUniqueInput
    update?: XOR<XOR<ImmobillionApplicantDetailsUpdateToOneWithWhereWithoutApplicantInput, ImmobillionApplicantDetailsUpdateWithoutApplicantInput>, ImmobillionApplicantDetailsUncheckedUpdateWithoutApplicantInput>
  }

  export type ApplicantCreateNestedOneWithoutImmobillionDetailsInput = {
    create?: XOR<ApplicantCreateWithoutImmobillionDetailsInput, ApplicantUncheckedCreateWithoutImmobillionDetailsInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutImmobillionDetailsInput
    connect?: ApplicantWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ApplicantUpdateOneRequiredWithoutImmobillionDetailsNestedInput = {
    create?: XOR<ApplicantCreateWithoutImmobillionDetailsInput, ApplicantUncheckedCreateWithoutImmobillionDetailsInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutImmobillionDetailsInput
    upsert?: ApplicantUpsertWithoutImmobillionDetailsInput
    connect?: ApplicantWhereUniqueInput
    update?: XOR<XOR<ApplicantUpdateToOneWithWhereWithoutImmobillionDetailsInput, ApplicantUpdateWithoutImmobillionDetailsInput>, ApplicantUncheckedUpdateWithoutImmobillionDetailsInput>
  }

  export type UserCreateNestedOneWithoutImmobillionFormsInput = {
    create?: XOR<UserCreateWithoutImmobillionFormsInput, UserUncheckedCreateWithoutImmobillionFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImmobillionFormsInput
    connect?: UserWhereUniqueInput
  }

  export type ApplicantCreateNestedManyWithoutImmobillionFormInput = {
    create?: XOR<ApplicantCreateWithoutImmobillionFormInput, ApplicantUncheckedCreateWithoutImmobillionFormInput> | ApplicantCreateWithoutImmobillionFormInput[] | ApplicantUncheckedCreateWithoutImmobillionFormInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutImmobillionFormInput | ApplicantCreateOrConnectWithoutImmobillionFormInput[]
    createMany?: ApplicantCreateManyImmobillionFormInputEnvelope
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
  }

  export type ApplicantUncheckedCreateNestedManyWithoutImmobillionFormInput = {
    create?: XOR<ApplicantCreateWithoutImmobillionFormInput, ApplicantUncheckedCreateWithoutImmobillionFormInput> | ApplicantCreateWithoutImmobillionFormInput[] | ApplicantUncheckedCreateWithoutImmobillionFormInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutImmobillionFormInput | ApplicantCreateOrConnectWithoutImmobillionFormInput[]
    createMany?: ApplicantCreateManyImmobillionFormInputEnvelope
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutImmobillionFormsNestedInput = {
    create?: XOR<UserCreateWithoutImmobillionFormsInput, UserUncheckedCreateWithoutImmobillionFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImmobillionFormsInput
    upsert?: UserUpsertWithoutImmobillionFormsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutImmobillionFormsInput, UserUpdateWithoutImmobillionFormsInput>, UserUncheckedUpdateWithoutImmobillionFormsInput>
  }

  export type ApplicantUpdateManyWithoutImmobillionFormNestedInput = {
    create?: XOR<ApplicantCreateWithoutImmobillionFormInput, ApplicantUncheckedCreateWithoutImmobillionFormInput> | ApplicantCreateWithoutImmobillionFormInput[] | ApplicantUncheckedCreateWithoutImmobillionFormInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutImmobillionFormInput | ApplicantCreateOrConnectWithoutImmobillionFormInput[]
    upsert?: ApplicantUpsertWithWhereUniqueWithoutImmobillionFormInput | ApplicantUpsertWithWhereUniqueWithoutImmobillionFormInput[]
    createMany?: ApplicantCreateManyImmobillionFormInputEnvelope
    set?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    disconnect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    delete?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    update?: ApplicantUpdateWithWhereUniqueWithoutImmobillionFormInput | ApplicantUpdateWithWhereUniqueWithoutImmobillionFormInput[]
    updateMany?: ApplicantUpdateManyWithWhereWithoutImmobillionFormInput | ApplicantUpdateManyWithWhereWithoutImmobillionFormInput[]
    deleteMany?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
  }

  export type ApplicantUncheckedUpdateManyWithoutImmobillionFormNestedInput = {
    create?: XOR<ApplicantCreateWithoutImmobillionFormInput, ApplicantUncheckedCreateWithoutImmobillionFormInput> | ApplicantCreateWithoutImmobillionFormInput[] | ApplicantUncheckedCreateWithoutImmobillionFormInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutImmobillionFormInput | ApplicantCreateOrConnectWithoutImmobillionFormInput[]
    upsert?: ApplicantUpsertWithWhereUniqueWithoutImmobillionFormInput | ApplicantUpsertWithWhereUniqueWithoutImmobillionFormInput[]
    createMany?: ApplicantCreateManyImmobillionFormInputEnvelope
    set?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    disconnect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    delete?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    update?: ApplicantUpdateWithWhereUniqueWithoutImmobillionFormInput | ApplicantUpdateWithWhereUniqueWithoutImmobillionFormInput[]
    updateMany?: ApplicantUpdateManyWithWhereWithoutImmobillionFormInput | ApplicantUpdateManyWithWhereWithoutImmobillionFormInput[]
    deleteMany?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAnalysisFormsInput = {
    create?: XOR<UserCreateWithoutAnalysisFormsInput, UserUncheckedCreateWithoutAnalysisFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalysisFormsInput
    connect?: UserWhereUniqueInput
  }

  export type ChildCreateNestedManyWithoutAnalysisFormInput = {
    create?: XOR<ChildCreateWithoutAnalysisFormInput, ChildUncheckedCreateWithoutAnalysisFormInput> | ChildCreateWithoutAnalysisFormInput[] | ChildUncheckedCreateWithoutAnalysisFormInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutAnalysisFormInput | ChildCreateOrConnectWithoutAnalysisFormInput[]
    createMany?: ChildCreateManyAnalysisFormInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type ApplicantCreateNestedManyWithoutAnalysisFormInput = {
    create?: XOR<ApplicantCreateWithoutAnalysisFormInput, ApplicantUncheckedCreateWithoutAnalysisFormInput> | ApplicantCreateWithoutAnalysisFormInput[] | ApplicantUncheckedCreateWithoutAnalysisFormInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutAnalysisFormInput | ApplicantCreateOrConnectWithoutAnalysisFormInput[]
    createMany?: ApplicantCreateManyAnalysisFormInputEnvelope
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
  }

  export type ChildUncheckedCreateNestedManyWithoutAnalysisFormInput = {
    create?: XOR<ChildCreateWithoutAnalysisFormInput, ChildUncheckedCreateWithoutAnalysisFormInput> | ChildCreateWithoutAnalysisFormInput[] | ChildUncheckedCreateWithoutAnalysisFormInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutAnalysisFormInput | ChildCreateOrConnectWithoutAnalysisFormInput[]
    createMany?: ChildCreateManyAnalysisFormInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type ApplicantUncheckedCreateNestedManyWithoutAnalysisFormInput = {
    create?: XOR<ApplicantCreateWithoutAnalysisFormInput, ApplicantUncheckedCreateWithoutAnalysisFormInput> | ApplicantCreateWithoutAnalysisFormInput[] | ApplicantUncheckedCreateWithoutAnalysisFormInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutAnalysisFormInput | ApplicantCreateOrConnectWithoutAnalysisFormInput[]
    createMany?: ApplicantCreateManyAnalysisFormInputEnvelope
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAnalysisFormsNestedInput = {
    create?: XOR<UserCreateWithoutAnalysisFormsInput, UserUncheckedCreateWithoutAnalysisFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalysisFormsInput
    upsert?: UserUpsertWithoutAnalysisFormsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalysisFormsInput, UserUpdateWithoutAnalysisFormsInput>, UserUncheckedUpdateWithoutAnalysisFormsInput>
  }

  export type ChildUpdateManyWithoutAnalysisFormNestedInput = {
    create?: XOR<ChildCreateWithoutAnalysisFormInput, ChildUncheckedCreateWithoutAnalysisFormInput> | ChildCreateWithoutAnalysisFormInput[] | ChildUncheckedCreateWithoutAnalysisFormInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutAnalysisFormInput | ChildCreateOrConnectWithoutAnalysisFormInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutAnalysisFormInput | ChildUpsertWithWhereUniqueWithoutAnalysisFormInput[]
    createMany?: ChildCreateManyAnalysisFormInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutAnalysisFormInput | ChildUpdateWithWhereUniqueWithoutAnalysisFormInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutAnalysisFormInput | ChildUpdateManyWithWhereWithoutAnalysisFormInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type ApplicantUpdateManyWithoutAnalysisFormNestedInput = {
    create?: XOR<ApplicantCreateWithoutAnalysisFormInput, ApplicantUncheckedCreateWithoutAnalysisFormInput> | ApplicantCreateWithoutAnalysisFormInput[] | ApplicantUncheckedCreateWithoutAnalysisFormInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutAnalysisFormInput | ApplicantCreateOrConnectWithoutAnalysisFormInput[]
    upsert?: ApplicantUpsertWithWhereUniqueWithoutAnalysisFormInput | ApplicantUpsertWithWhereUniqueWithoutAnalysisFormInput[]
    createMany?: ApplicantCreateManyAnalysisFormInputEnvelope
    set?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    disconnect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    delete?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    update?: ApplicantUpdateWithWhereUniqueWithoutAnalysisFormInput | ApplicantUpdateWithWhereUniqueWithoutAnalysisFormInput[]
    updateMany?: ApplicantUpdateManyWithWhereWithoutAnalysisFormInput | ApplicantUpdateManyWithWhereWithoutAnalysisFormInput[]
    deleteMany?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
  }

  export type ChildUncheckedUpdateManyWithoutAnalysisFormNestedInput = {
    create?: XOR<ChildCreateWithoutAnalysisFormInput, ChildUncheckedCreateWithoutAnalysisFormInput> | ChildCreateWithoutAnalysisFormInput[] | ChildUncheckedCreateWithoutAnalysisFormInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutAnalysisFormInput | ChildCreateOrConnectWithoutAnalysisFormInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutAnalysisFormInput | ChildUpsertWithWhereUniqueWithoutAnalysisFormInput[]
    createMany?: ChildCreateManyAnalysisFormInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutAnalysisFormInput | ChildUpdateWithWhereUniqueWithoutAnalysisFormInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutAnalysisFormInput | ChildUpdateManyWithWhereWithoutAnalysisFormInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type ApplicantUncheckedUpdateManyWithoutAnalysisFormNestedInput = {
    create?: XOR<ApplicantCreateWithoutAnalysisFormInput, ApplicantUncheckedCreateWithoutAnalysisFormInput> | ApplicantCreateWithoutAnalysisFormInput[] | ApplicantUncheckedCreateWithoutAnalysisFormInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutAnalysisFormInput | ApplicantCreateOrConnectWithoutAnalysisFormInput[]
    upsert?: ApplicantUpsertWithWhereUniqueWithoutAnalysisFormInput | ApplicantUpsertWithWhereUniqueWithoutAnalysisFormInput[]
    createMany?: ApplicantCreateManyAnalysisFormInputEnvelope
    set?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    disconnect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    delete?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    update?: ApplicantUpdateWithWhereUniqueWithoutAnalysisFormInput | ApplicantUpdateWithWhereUniqueWithoutAnalysisFormInput[]
    updateMany?: ApplicantUpdateManyWithWhereWithoutAnalysisFormInput | ApplicantUpdateManyWithWhereWithoutAnalysisFormInput[]
    deleteMany?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPersonalDetailsInput = {
    create?: XOR<UserCreateWithoutPersonalDetailsInput, UserUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientsAsCoachInput = {
    create?: XOR<UserCreateWithoutClientsAsCoachInput, UserUncheckedCreateWithoutClientsAsCoachInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsAsCoachInput
    connect?: UserWhereUniqueInput
  }

  export type EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<EmploymentDetailsCreateWithoutPersonalDetailsInput, EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput> | EmploymentDetailsCreateWithoutPersonalDetailsInput[] | EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput | EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: EmploymentDetailsCreateManyPersonalDetailsInputEnvelope
    connect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
  }

  export type IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<IncomeDetailsCreateWithoutPersonalDetailsInput, IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput> | IncomeDetailsCreateWithoutPersonalDetailsInput[] | IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput | IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: IncomeDetailsCreateManyPersonalDetailsInputEnvelope
    connect?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
  }

  export type ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<ExpensesDetailsCreateWithoutPersonalDetailsInput, ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput> | ExpensesDetailsCreateWithoutPersonalDetailsInput[] | ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput | ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: ExpensesDetailsCreateManyPersonalDetailsInputEnvelope
    connect?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<AssetCreateWithoutPersonalDetailsInput, AssetUncheckedCreateWithoutPersonalDetailsInput> | AssetCreateWithoutPersonalDetailsInput[] | AssetUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPersonalDetailsInput | AssetCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: AssetCreateManyPersonalDetailsInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type LiabilityCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<LiabilityCreateWithoutPersonalDetailsInput, LiabilityUncheckedCreateWithoutPersonalDetailsInput> | LiabilityCreateWithoutPersonalDetailsInput[] | LiabilityUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: LiabilityCreateOrConnectWithoutPersonalDetailsInput | LiabilityCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: LiabilityCreateManyPersonalDetailsInputEnvelope
    connect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
  }

  export type GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput = {
    create?: XOR<GoalsAndWishesCreateWithoutPersonalDetailsInput, GoalsAndWishesUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: GoalsAndWishesCreateOrConnectWithoutPersonalDetailsInput
    connect?: GoalsAndWishesWhereUniqueInput
  }

  export type RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput = {
    create?: XOR<RiskAppetiteCreateWithoutPersonalDetailsInput, RiskAppetiteUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: RiskAppetiteCreateOrConnectWithoutPersonalDetailsInput
    connect?: RiskAppetiteWhereUniqueInput
  }

  export type ConsentCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<ConsentCreateWithoutPersonalDetailsInput, ConsentUncheckedCreateWithoutPersonalDetailsInput> | ConsentCreateWithoutPersonalDetailsInput[] | ConsentUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: ConsentCreateOrConnectWithoutPersonalDetailsInput | ConsentCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: ConsentCreateManyPersonalDetailsInputEnvelope
    connect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<DocumentCreateWithoutPersonalDetailsInput, DocumentUncheckedCreateWithoutPersonalDetailsInput> | DocumentCreateWithoutPersonalDetailsInput[] | DocumentUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPersonalDetailsInput | DocumentCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: DocumentCreateManyPersonalDetailsInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type FormCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<FormCreateWithoutPersonalDetailsInput, FormUncheckedCreateWithoutPersonalDetailsInput> | FormCreateWithoutPersonalDetailsInput[] | FormUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: FormCreateOrConnectWithoutPersonalDetailsInput | FormCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: FormCreateManyPersonalDetailsInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type CustomFormCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<CustomFormCreateWithoutPersonalDetailsInput, CustomFormUncheckedCreateWithoutPersonalDetailsInput> | CustomFormCreateWithoutPersonalDetailsInput[] | CustomFormUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: CustomFormCreateOrConnectWithoutPersonalDetailsInput | CustomFormCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: CustomFormCreateManyPersonalDetailsInputEnvelope
    connect?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
  }

  export type EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<EmploymentDetailsCreateWithoutPersonalDetailsInput, EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput> | EmploymentDetailsCreateWithoutPersonalDetailsInput[] | EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput | EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: EmploymentDetailsCreateManyPersonalDetailsInputEnvelope
    connect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
  }

  export type IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<IncomeDetailsCreateWithoutPersonalDetailsInput, IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput> | IncomeDetailsCreateWithoutPersonalDetailsInput[] | IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput | IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: IncomeDetailsCreateManyPersonalDetailsInputEnvelope
    connect?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
  }

  export type ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<ExpensesDetailsCreateWithoutPersonalDetailsInput, ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput> | ExpensesDetailsCreateWithoutPersonalDetailsInput[] | ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput | ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: ExpensesDetailsCreateManyPersonalDetailsInputEnvelope
    connect?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<AssetCreateWithoutPersonalDetailsInput, AssetUncheckedCreateWithoutPersonalDetailsInput> | AssetCreateWithoutPersonalDetailsInput[] | AssetUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPersonalDetailsInput | AssetCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: AssetCreateManyPersonalDetailsInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<LiabilityCreateWithoutPersonalDetailsInput, LiabilityUncheckedCreateWithoutPersonalDetailsInput> | LiabilityCreateWithoutPersonalDetailsInput[] | LiabilityUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: LiabilityCreateOrConnectWithoutPersonalDetailsInput | LiabilityCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: LiabilityCreateManyPersonalDetailsInputEnvelope
    connect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
  }

  export type GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput = {
    create?: XOR<GoalsAndWishesCreateWithoutPersonalDetailsInput, GoalsAndWishesUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: GoalsAndWishesCreateOrConnectWithoutPersonalDetailsInput
    connect?: GoalsAndWishesWhereUniqueInput
  }

  export type RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput = {
    create?: XOR<RiskAppetiteCreateWithoutPersonalDetailsInput, RiskAppetiteUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: RiskAppetiteCreateOrConnectWithoutPersonalDetailsInput
    connect?: RiskAppetiteWhereUniqueInput
  }

  export type ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<ConsentCreateWithoutPersonalDetailsInput, ConsentUncheckedCreateWithoutPersonalDetailsInput> | ConsentCreateWithoutPersonalDetailsInput[] | ConsentUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: ConsentCreateOrConnectWithoutPersonalDetailsInput | ConsentCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: ConsentCreateManyPersonalDetailsInputEnvelope
    connect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<DocumentCreateWithoutPersonalDetailsInput, DocumentUncheckedCreateWithoutPersonalDetailsInput> | DocumentCreateWithoutPersonalDetailsInput[] | DocumentUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPersonalDetailsInput | DocumentCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: DocumentCreateManyPersonalDetailsInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type FormUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<FormCreateWithoutPersonalDetailsInput, FormUncheckedCreateWithoutPersonalDetailsInput> | FormCreateWithoutPersonalDetailsInput[] | FormUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: FormCreateOrConnectWithoutPersonalDetailsInput | FormCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: FormCreateManyPersonalDetailsInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput = {
    create?: XOR<CustomFormCreateWithoutPersonalDetailsInput, CustomFormUncheckedCreateWithoutPersonalDetailsInput> | CustomFormCreateWithoutPersonalDetailsInput[] | CustomFormUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: CustomFormCreateOrConnectWithoutPersonalDetailsInput | CustomFormCreateOrConnectWithoutPersonalDetailsInput[]
    createMany?: CustomFormCreateManyPersonalDetailsInputEnvelope
    connect?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
  }

  export type EnumApplicantTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApplicantType
  }

  export type UserUpdateOneRequiredWithoutPersonalDetailsNestedInput = {
    create?: XOR<UserCreateWithoutPersonalDetailsInput, UserUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalDetailsInput
    upsert?: UserUpsertWithoutPersonalDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonalDetailsInput, UserUpdateWithoutPersonalDetailsInput>, UserUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type UserUpdateOneRequiredWithoutClientsAsCoachNestedInput = {
    create?: XOR<UserCreateWithoutClientsAsCoachInput, UserUncheckedCreateWithoutClientsAsCoachInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsAsCoachInput
    upsert?: UserUpsertWithoutClientsAsCoachInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientsAsCoachInput, UserUpdateWithoutClientsAsCoachInput>, UserUncheckedUpdateWithoutClientsAsCoachInput>
  }

  export type EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<EmploymentDetailsCreateWithoutPersonalDetailsInput, EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput> | EmploymentDetailsCreateWithoutPersonalDetailsInput[] | EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput | EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: EmploymentDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput | EmploymentDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: EmploymentDetailsCreateManyPersonalDetailsInputEnvelope
    set?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    disconnect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    delete?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    connect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    update?: EmploymentDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput | EmploymentDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: EmploymentDetailsUpdateManyWithWhereWithoutPersonalDetailsInput | EmploymentDetailsUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: EmploymentDetailsScalarWhereInput | EmploymentDetailsScalarWhereInput[]
  }

  export type IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<IncomeDetailsCreateWithoutPersonalDetailsInput, IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput> | IncomeDetailsCreateWithoutPersonalDetailsInput[] | IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput | IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: IncomeDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput | IncomeDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: IncomeDetailsCreateManyPersonalDetailsInputEnvelope
    set?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
    disconnect?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
    delete?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
    connect?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
    update?: IncomeDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput | IncomeDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: IncomeDetailsUpdateManyWithWhereWithoutPersonalDetailsInput | IncomeDetailsUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: IncomeDetailsScalarWhereInput | IncomeDetailsScalarWhereInput[]
  }

  export type ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<ExpensesDetailsCreateWithoutPersonalDetailsInput, ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput> | ExpensesDetailsCreateWithoutPersonalDetailsInput[] | ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput | ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: ExpensesDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput | ExpensesDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: ExpensesDetailsCreateManyPersonalDetailsInputEnvelope
    set?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
    disconnect?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
    delete?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
    connect?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
    update?: ExpensesDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput | ExpensesDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: ExpensesDetailsUpdateManyWithWhereWithoutPersonalDetailsInput | ExpensesDetailsUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: ExpensesDetailsScalarWhereInput | ExpensesDetailsScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<AssetCreateWithoutPersonalDetailsInput, AssetUncheckedCreateWithoutPersonalDetailsInput> | AssetCreateWithoutPersonalDetailsInput[] | AssetUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPersonalDetailsInput | AssetCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutPersonalDetailsInput | AssetUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: AssetCreateManyPersonalDetailsInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutPersonalDetailsInput | AssetUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutPersonalDetailsInput | AssetUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type LiabilityUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<LiabilityCreateWithoutPersonalDetailsInput, LiabilityUncheckedCreateWithoutPersonalDetailsInput> | LiabilityCreateWithoutPersonalDetailsInput[] | LiabilityUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: LiabilityCreateOrConnectWithoutPersonalDetailsInput | LiabilityCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: LiabilityUpsertWithWhereUniqueWithoutPersonalDetailsInput | LiabilityUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: LiabilityCreateManyPersonalDetailsInputEnvelope
    set?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    disconnect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    delete?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    connect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    update?: LiabilityUpdateWithWhereUniqueWithoutPersonalDetailsInput | LiabilityUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: LiabilityUpdateManyWithWhereWithoutPersonalDetailsInput | LiabilityUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: LiabilityScalarWhereInput | LiabilityScalarWhereInput[]
  }

  export type GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput = {
    create?: XOR<GoalsAndWishesCreateWithoutPersonalDetailsInput, GoalsAndWishesUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: GoalsAndWishesCreateOrConnectWithoutPersonalDetailsInput
    upsert?: GoalsAndWishesUpsertWithoutPersonalDetailsInput
    disconnect?: GoalsAndWishesWhereInput | boolean
    delete?: GoalsAndWishesWhereInput | boolean
    connect?: GoalsAndWishesWhereUniqueInput
    update?: XOR<XOR<GoalsAndWishesUpdateToOneWithWhereWithoutPersonalDetailsInput, GoalsAndWishesUpdateWithoutPersonalDetailsInput>, GoalsAndWishesUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput = {
    create?: XOR<RiskAppetiteCreateWithoutPersonalDetailsInput, RiskAppetiteUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: RiskAppetiteCreateOrConnectWithoutPersonalDetailsInput
    upsert?: RiskAppetiteUpsertWithoutPersonalDetailsInput
    disconnect?: RiskAppetiteWhereInput | boolean
    delete?: RiskAppetiteWhereInput | boolean
    connect?: RiskAppetiteWhereUniqueInput
    update?: XOR<XOR<RiskAppetiteUpdateToOneWithWhereWithoutPersonalDetailsInput, RiskAppetiteUpdateWithoutPersonalDetailsInput>, RiskAppetiteUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type ConsentUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<ConsentCreateWithoutPersonalDetailsInput, ConsentUncheckedCreateWithoutPersonalDetailsInput> | ConsentCreateWithoutPersonalDetailsInput[] | ConsentUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: ConsentCreateOrConnectWithoutPersonalDetailsInput | ConsentCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: ConsentUpsertWithWhereUniqueWithoutPersonalDetailsInput | ConsentUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: ConsentCreateManyPersonalDetailsInputEnvelope
    set?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    disconnect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    delete?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    connect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    update?: ConsentUpdateWithWhereUniqueWithoutPersonalDetailsInput | ConsentUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: ConsentUpdateManyWithWhereWithoutPersonalDetailsInput | ConsentUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: ConsentScalarWhereInput | ConsentScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<DocumentCreateWithoutPersonalDetailsInput, DocumentUncheckedCreateWithoutPersonalDetailsInput> | DocumentCreateWithoutPersonalDetailsInput[] | DocumentUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPersonalDetailsInput | DocumentCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPersonalDetailsInput | DocumentUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: DocumentCreateManyPersonalDetailsInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPersonalDetailsInput | DocumentUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPersonalDetailsInput | DocumentUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type FormUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<FormCreateWithoutPersonalDetailsInput, FormUncheckedCreateWithoutPersonalDetailsInput> | FormCreateWithoutPersonalDetailsInput[] | FormUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: FormCreateOrConnectWithoutPersonalDetailsInput | FormCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutPersonalDetailsInput | FormUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: FormCreateManyPersonalDetailsInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutPersonalDetailsInput | FormUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: FormUpdateManyWithWhereWithoutPersonalDetailsInput | FormUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type CustomFormUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<CustomFormCreateWithoutPersonalDetailsInput, CustomFormUncheckedCreateWithoutPersonalDetailsInput> | CustomFormCreateWithoutPersonalDetailsInput[] | CustomFormUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: CustomFormCreateOrConnectWithoutPersonalDetailsInput | CustomFormCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: CustomFormUpsertWithWhereUniqueWithoutPersonalDetailsInput | CustomFormUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: CustomFormCreateManyPersonalDetailsInputEnvelope
    set?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
    disconnect?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
    delete?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
    connect?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
    update?: CustomFormUpdateWithWhereUniqueWithoutPersonalDetailsInput | CustomFormUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: CustomFormUpdateManyWithWhereWithoutPersonalDetailsInput | CustomFormUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: CustomFormScalarWhereInput | CustomFormScalarWhereInput[]
  }

  export type EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<EmploymentDetailsCreateWithoutPersonalDetailsInput, EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput> | EmploymentDetailsCreateWithoutPersonalDetailsInput[] | EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput | EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: EmploymentDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput | EmploymentDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: EmploymentDetailsCreateManyPersonalDetailsInputEnvelope
    set?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    disconnect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    delete?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    connect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    update?: EmploymentDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput | EmploymentDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: EmploymentDetailsUpdateManyWithWhereWithoutPersonalDetailsInput | EmploymentDetailsUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: EmploymentDetailsScalarWhereInput | EmploymentDetailsScalarWhereInput[]
  }

  export type IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<IncomeDetailsCreateWithoutPersonalDetailsInput, IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput> | IncomeDetailsCreateWithoutPersonalDetailsInput[] | IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput | IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: IncomeDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput | IncomeDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: IncomeDetailsCreateManyPersonalDetailsInputEnvelope
    set?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
    disconnect?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
    delete?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
    connect?: IncomeDetailsWhereUniqueInput | IncomeDetailsWhereUniqueInput[]
    update?: IncomeDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput | IncomeDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: IncomeDetailsUpdateManyWithWhereWithoutPersonalDetailsInput | IncomeDetailsUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: IncomeDetailsScalarWhereInput | IncomeDetailsScalarWhereInput[]
  }

  export type ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<ExpensesDetailsCreateWithoutPersonalDetailsInput, ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput> | ExpensesDetailsCreateWithoutPersonalDetailsInput[] | ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput | ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: ExpensesDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput | ExpensesDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: ExpensesDetailsCreateManyPersonalDetailsInputEnvelope
    set?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
    disconnect?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
    delete?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
    connect?: ExpensesDetailsWhereUniqueInput | ExpensesDetailsWhereUniqueInput[]
    update?: ExpensesDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput | ExpensesDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: ExpensesDetailsUpdateManyWithWhereWithoutPersonalDetailsInput | ExpensesDetailsUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: ExpensesDetailsScalarWhereInput | ExpensesDetailsScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<AssetCreateWithoutPersonalDetailsInput, AssetUncheckedCreateWithoutPersonalDetailsInput> | AssetCreateWithoutPersonalDetailsInput[] | AssetUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPersonalDetailsInput | AssetCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutPersonalDetailsInput | AssetUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: AssetCreateManyPersonalDetailsInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutPersonalDetailsInput | AssetUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutPersonalDetailsInput | AssetUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<LiabilityCreateWithoutPersonalDetailsInput, LiabilityUncheckedCreateWithoutPersonalDetailsInput> | LiabilityCreateWithoutPersonalDetailsInput[] | LiabilityUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: LiabilityCreateOrConnectWithoutPersonalDetailsInput | LiabilityCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: LiabilityUpsertWithWhereUniqueWithoutPersonalDetailsInput | LiabilityUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: LiabilityCreateManyPersonalDetailsInputEnvelope
    set?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    disconnect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    delete?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    connect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    update?: LiabilityUpdateWithWhereUniqueWithoutPersonalDetailsInput | LiabilityUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: LiabilityUpdateManyWithWhereWithoutPersonalDetailsInput | LiabilityUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: LiabilityScalarWhereInput | LiabilityScalarWhereInput[]
  }

  export type GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput = {
    create?: XOR<GoalsAndWishesCreateWithoutPersonalDetailsInput, GoalsAndWishesUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: GoalsAndWishesCreateOrConnectWithoutPersonalDetailsInput
    upsert?: GoalsAndWishesUpsertWithoutPersonalDetailsInput
    disconnect?: GoalsAndWishesWhereInput | boolean
    delete?: GoalsAndWishesWhereInput | boolean
    connect?: GoalsAndWishesWhereUniqueInput
    update?: XOR<XOR<GoalsAndWishesUpdateToOneWithWhereWithoutPersonalDetailsInput, GoalsAndWishesUpdateWithoutPersonalDetailsInput>, GoalsAndWishesUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput = {
    create?: XOR<RiskAppetiteCreateWithoutPersonalDetailsInput, RiskAppetiteUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: RiskAppetiteCreateOrConnectWithoutPersonalDetailsInput
    upsert?: RiskAppetiteUpsertWithoutPersonalDetailsInput
    disconnect?: RiskAppetiteWhereInput | boolean
    delete?: RiskAppetiteWhereInput | boolean
    connect?: RiskAppetiteWhereUniqueInput
    update?: XOR<XOR<RiskAppetiteUpdateToOneWithWhereWithoutPersonalDetailsInput, RiskAppetiteUpdateWithoutPersonalDetailsInput>, RiskAppetiteUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<ConsentCreateWithoutPersonalDetailsInput, ConsentUncheckedCreateWithoutPersonalDetailsInput> | ConsentCreateWithoutPersonalDetailsInput[] | ConsentUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: ConsentCreateOrConnectWithoutPersonalDetailsInput | ConsentCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: ConsentUpsertWithWhereUniqueWithoutPersonalDetailsInput | ConsentUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: ConsentCreateManyPersonalDetailsInputEnvelope
    set?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    disconnect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    delete?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    connect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    update?: ConsentUpdateWithWhereUniqueWithoutPersonalDetailsInput | ConsentUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: ConsentUpdateManyWithWhereWithoutPersonalDetailsInput | ConsentUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: ConsentScalarWhereInput | ConsentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<DocumentCreateWithoutPersonalDetailsInput, DocumentUncheckedCreateWithoutPersonalDetailsInput> | DocumentCreateWithoutPersonalDetailsInput[] | DocumentUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPersonalDetailsInput | DocumentCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPersonalDetailsInput | DocumentUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: DocumentCreateManyPersonalDetailsInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPersonalDetailsInput | DocumentUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPersonalDetailsInput | DocumentUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<FormCreateWithoutPersonalDetailsInput, FormUncheckedCreateWithoutPersonalDetailsInput> | FormCreateWithoutPersonalDetailsInput[] | FormUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: FormCreateOrConnectWithoutPersonalDetailsInput | FormCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutPersonalDetailsInput | FormUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: FormCreateManyPersonalDetailsInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutPersonalDetailsInput | FormUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: FormUpdateManyWithWhereWithoutPersonalDetailsInput | FormUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput = {
    create?: XOR<CustomFormCreateWithoutPersonalDetailsInput, CustomFormUncheckedCreateWithoutPersonalDetailsInput> | CustomFormCreateWithoutPersonalDetailsInput[] | CustomFormUncheckedCreateWithoutPersonalDetailsInput[]
    connectOrCreate?: CustomFormCreateOrConnectWithoutPersonalDetailsInput | CustomFormCreateOrConnectWithoutPersonalDetailsInput[]
    upsert?: CustomFormUpsertWithWhereUniqueWithoutPersonalDetailsInput | CustomFormUpsertWithWhereUniqueWithoutPersonalDetailsInput[]
    createMany?: CustomFormCreateManyPersonalDetailsInputEnvelope
    set?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
    disconnect?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
    delete?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
    connect?: CustomFormWhereUniqueInput | CustomFormWhereUniqueInput[]
    update?: CustomFormUpdateWithWhereUniqueWithoutPersonalDetailsInput | CustomFormUpdateWithWhereUniqueWithoutPersonalDetailsInput[]
    updateMany?: CustomFormUpdateManyWithWhereWithoutPersonalDetailsInput | CustomFormUpdateManyWithWhereWithoutPersonalDetailsInput[]
    deleteMany?: CustomFormScalarWhereInput | CustomFormScalarWhereInput[]
  }

  export type PersonalDetailsCreateNestedOneWithoutEmploymentDetailsInput = {
    create?: XOR<PersonalDetailsCreateWithoutEmploymentDetailsInput, PersonalDetailsUncheckedCreateWithoutEmploymentDetailsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutEmploymentDetailsInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type EnumEmploymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmploymentType
  }

  export type PersonalDetailsUpdateOneRequiredWithoutEmploymentDetailsNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutEmploymentDetailsInput, PersonalDetailsUncheckedCreateWithoutEmploymentDetailsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutEmploymentDetailsInput
    upsert?: PersonalDetailsUpsertWithoutEmploymentDetailsInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutEmploymentDetailsInput, PersonalDetailsUpdateWithoutEmploymentDetailsInput>, PersonalDetailsUncheckedUpdateWithoutEmploymentDetailsInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutIncomeDetailsInput = {
    create?: XOR<PersonalDetailsCreateWithoutIncomeDetailsInput, PersonalDetailsUncheckedCreateWithoutIncomeDetailsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutIncomeDetailsInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsUpdateOneRequiredWithoutIncomeDetailsNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutIncomeDetailsInput, PersonalDetailsUncheckedCreateWithoutIncomeDetailsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutIncomeDetailsInput
    upsert?: PersonalDetailsUpsertWithoutIncomeDetailsInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutIncomeDetailsInput, PersonalDetailsUpdateWithoutIncomeDetailsInput>, PersonalDetailsUncheckedUpdateWithoutIncomeDetailsInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutExpensesDetailsInput = {
    create?: XOR<PersonalDetailsCreateWithoutExpensesDetailsInput, PersonalDetailsUncheckedCreateWithoutExpensesDetailsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutExpensesDetailsInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsUpdateOneRequiredWithoutExpensesDetailsNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutExpensesDetailsInput, PersonalDetailsUncheckedCreateWithoutExpensesDetailsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutExpensesDetailsInput
    upsert?: PersonalDetailsUpsertWithoutExpensesDetailsInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutExpensesDetailsInput, PersonalDetailsUpdateWithoutExpensesDetailsInput>, PersonalDetailsUncheckedUpdateWithoutExpensesDetailsInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutAssetsInput = {
    create?: XOR<PersonalDetailsCreateWithoutAssetsInput, PersonalDetailsUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutAssetsInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutAssetsInput, PersonalDetailsUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutAssetsInput
    upsert?: PersonalDetailsUpsertWithoutAssetsInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutAssetsInput, PersonalDetailsUpdateWithoutAssetsInput>, PersonalDetailsUncheckedUpdateWithoutAssetsInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutLiabilitiesInput = {
    create?: XOR<PersonalDetailsCreateWithoutLiabilitiesInput, PersonalDetailsUncheckedCreateWithoutLiabilitiesInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutLiabilitiesInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type EnumLoanTypeFieldUpdateOperationsInput = {
    set?: $Enums.LoanType
  }

  export type PersonalDetailsUpdateOneRequiredWithoutLiabilitiesNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutLiabilitiesInput, PersonalDetailsUncheckedCreateWithoutLiabilitiesInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutLiabilitiesInput
    upsert?: PersonalDetailsUpsertWithoutLiabilitiesInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutLiabilitiesInput, PersonalDetailsUpdateWithoutLiabilitiesInput>, PersonalDetailsUncheckedUpdateWithoutLiabilitiesInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutGoalsAndWishesInput = {
    create?: XOR<PersonalDetailsCreateWithoutGoalsAndWishesInput, PersonalDetailsUncheckedCreateWithoutGoalsAndWishesInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutGoalsAndWishesInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsUpdateOneRequiredWithoutGoalsAndWishesNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutGoalsAndWishesInput, PersonalDetailsUncheckedCreateWithoutGoalsAndWishesInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutGoalsAndWishesInput
    upsert?: PersonalDetailsUpsertWithoutGoalsAndWishesInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutGoalsAndWishesInput, PersonalDetailsUpdateWithoutGoalsAndWishesInput>, PersonalDetailsUncheckedUpdateWithoutGoalsAndWishesInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutRiskAppetiteInput = {
    create?: XOR<PersonalDetailsCreateWithoutRiskAppetiteInput, PersonalDetailsUncheckedCreateWithoutRiskAppetiteInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutRiskAppetiteInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsUpdateOneRequiredWithoutRiskAppetiteNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutRiskAppetiteInput, PersonalDetailsUncheckedCreateWithoutRiskAppetiteInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutRiskAppetiteInput
    upsert?: PersonalDetailsUpsertWithoutRiskAppetiteInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutRiskAppetiteInput, PersonalDetailsUpdateWithoutRiskAppetiteInput>, PersonalDetailsUncheckedUpdateWithoutRiskAppetiteInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutConsentsInput = {
    create?: XOR<PersonalDetailsCreateWithoutConsentsInput, PersonalDetailsUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutConsentsInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type EnumConsentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConsentType
  }

  export type PersonalDetailsUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutConsentsInput, PersonalDetailsUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutConsentsInput
    upsert?: PersonalDetailsUpsertWithoutConsentsInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutConsentsInput, PersonalDetailsUpdateWithoutConsentsInput>, PersonalDetailsUncheckedUpdateWithoutConsentsInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PersonalDetailsCreateWithoutDocumentsInput, PersonalDetailsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutDocumentsInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutDocumentsInput, PersonalDetailsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutDocumentsInput
    upsert?: PersonalDetailsUpsertWithoutDocumentsInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutDocumentsInput, PersonalDetailsUpdateWithoutDocumentsInput>, PersonalDetailsUncheckedUpdateWithoutDocumentsInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutFormsInput = {
    create?: XOR<PersonalDetailsCreateWithoutFormsInput, PersonalDetailsUncheckedCreateWithoutFormsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutFormsInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type EnumFormTypeFieldUpdateOperationsInput = {
    set?: $Enums.FormType
  }

  export type PersonalDetailsUpdateOneRequiredWithoutFormsNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutFormsInput, PersonalDetailsUncheckedCreateWithoutFormsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutFormsInput
    upsert?: PersonalDetailsUpsertWithoutFormsInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutFormsInput, PersonalDetailsUpdateWithoutFormsInput>, PersonalDetailsUncheckedUpdateWithoutFormsInput>
  }

  export type PersonalDetailsCreateNestedOneWithoutCustomFormsInput = {
    create?: XOR<PersonalDetailsCreateWithoutCustomFormsInput, PersonalDetailsUncheckedCreateWithoutCustomFormsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCustomFormsInput
    connect?: PersonalDetailsWhereUniqueInput
  }

  export type PersonalDetailsUpdateOneRequiredWithoutCustomFormsNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutCustomFormsInput, PersonalDetailsUncheckedCreateWithoutCustomFormsInput>
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCustomFormsInput
    upsert?: PersonalDetailsUpsertWithoutCustomFormsInput
    connect?: PersonalDetailsWhereUniqueInput
    update?: XOR<XOR<PersonalDetailsUpdateToOneWithWhereWithoutCustomFormsInput, PersonalDetailsUpdateWithoutCustomFormsInput>, PersonalDetailsUncheckedUpdateWithoutCustomFormsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumApplicantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantType | EnumApplicantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantTypeFilter<$PrismaModel> | $Enums.ApplicantType
  }

  export type NestedEnumApplicantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantType | EnumApplicantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantType[] | ListEnumApplicantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicantTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicantTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumLoanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanType | EnumLoanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoanType[] | ListEnumLoanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanType[] | ListEnumLoanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanTypeFilter<$PrismaModel> | $Enums.LoanType
  }

  export type NestedEnumLoanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoanType | EnumLoanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoanType[] | ListEnumLoanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoanType[] | ListEnumLoanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoanTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoanTypeFilter<$PrismaModel>
    _max?: NestedEnumLoanTypeFilter<$PrismaModel>
  }

  export type NestedEnumConsentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentTypeFilter<$PrismaModel> | $Enums.ConsentType
  }

  export type NestedEnumConsentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentType | EnumConsentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentType[] | ListEnumConsentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConsentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentTypeFilter<$PrismaModel>
    _max?: NestedEnumConsentTypeFilter<$PrismaModel>
  }

  export type NestedEnumFormTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FormType | EnumFormTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTypeFilter<$PrismaModel> | $Enums.FormType
  }

  export type NestedEnumFormTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormType | EnumFormTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTypeWithAggregatesFilter<$PrismaModel> | $Enums.FormType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormTypeFilter<$PrismaModel>
    _max?: NestedEnumFormTypeFilter<$PrismaModel>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type AnalysisFormCreateWithoutUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
    children?: ChildCreateNestedManyWithoutAnalysisFormInput
    applicants?: ApplicantCreateNestedManyWithoutAnalysisFormInput
  }

  export type AnalysisFormUncheckedCreateWithoutUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutAnalysisFormInput
    applicants?: ApplicantUncheckedCreateNestedManyWithoutAnalysisFormInput
  }

  export type AnalysisFormCreateOrConnectWithoutUserInput = {
    where: AnalysisFormWhereUniqueInput
    create: XOR<AnalysisFormCreateWithoutUserInput, AnalysisFormUncheckedCreateWithoutUserInput>
  }

  export type AnalysisFormCreateManyUserInputEnvelope = {
    data: AnalysisFormCreateManyUserInput | AnalysisFormCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ImmobillionFormCreateWithoutUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType?: string
    formVersion?: string
    applicants?: ApplicantCreateNestedManyWithoutImmobillionFormInput
  }

  export type ImmobillionFormUncheckedCreateWithoutUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType?: string
    formVersion?: string
    applicants?: ApplicantUncheckedCreateNestedManyWithoutImmobillionFormInput
  }

  export type ImmobillionFormCreateOrConnectWithoutUserInput = {
    where: ImmobillionFormWhereUniqueInput
    create: XOR<ImmobillionFormCreateWithoutUserInput, ImmobillionFormUncheckedCreateWithoutUserInput>
  }

  export type ImmobillionFormCreateManyUserInputEnvelope = {
    data: ImmobillionFormCreateManyUserInput | ImmobillionFormCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PersonalDetailsCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutUserInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutUserInput, PersonalDetailsUncheckedCreateWithoutUserInput>
  }

  export type PersonalDetailsCreateWithoutCoachInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutCoachInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutCoachInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutCoachInput, PersonalDetailsUncheckedCreateWithoutCoachInput>
  }

  export type PersonalDetailsCreateManyCoachInputEnvelope = {
    data: PersonalDetailsCreateManyCoachInput | PersonalDetailsCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisFormUpsertWithWhereUniqueWithoutUserInput = {
    where: AnalysisFormWhereUniqueInput
    update: XOR<AnalysisFormUpdateWithoutUserInput, AnalysisFormUncheckedUpdateWithoutUserInput>
    create: XOR<AnalysisFormCreateWithoutUserInput, AnalysisFormUncheckedCreateWithoutUserInput>
  }

  export type AnalysisFormUpdateWithWhereUniqueWithoutUserInput = {
    where: AnalysisFormWhereUniqueInput
    data: XOR<AnalysisFormUpdateWithoutUserInput, AnalysisFormUncheckedUpdateWithoutUserInput>
  }

  export type AnalysisFormUpdateManyWithWhereWithoutUserInput = {
    where: AnalysisFormScalarWhereInput
    data: XOR<AnalysisFormUpdateManyMutationInput, AnalysisFormUncheckedUpdateManyWithoutUserInput>
  }

  export type AnalysisFormScalarWhereInput = {
    AND?: AnalysisFormScalarWhereInput | AnalysisFormScalarWhereInput[]
    OR?: AnalysisFormScalarWhereInput[]
    NOT?: AnalysisFormScalarWhereInput | AnalysisFormScalarWhereInput[]
    id?: StringFilter<"AnalysisForm"> | string
    status?: StringFilter<"AnalysisForm"> | string
    createdAt?: DateTimeFilter<"AnalysisForm"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisForm"> | Date | string
    userId?: StringFilter<"AnalysisForm"> | string
    consultantName?: StringFilter<"AnalysisForm"> | string
    officeLocation?: StringFilter<"AnalysisForm"> | string
    analysisDate?: DateTimeFilter<"AnalysisForm"> | Date | string
    coldRent?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    gas?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFilter<"AnalysisForm"> | boolean
    loanBank?: StringNullableFilter<"AnalysisForm"> | string | null
    loanAmount?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    loanInterest?: DecimalNullableFilter<"AnalysisForm"> | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFilter<"AnalysisForm"> | boolean
    analysisConsentText?: StringFilter<"AnalysisForm"> | string
    analysisConsentSignature?: StringFilter<"AnalysisForm"> | string
    analysisLocation?: StringFilter<"AnalysisForm"> | string
    analysisConsentDate?: DateTimeFilter<"AnalysisForm"> | Date | string
  }

  export type ImmobillionFormUpsertWithWhereUniqueWithoutUserInput = {
    where: ImmobillionFormWhereUniqueInput
    update: XOR<ImmobillionFormUpdateWithoutUserInput, ImmobillionFormUncheckedUpdateWithoutUserInput>
    create: XOR<ImmobillionFormCreateWithoutUserInput, ImmobillionFormUncheckedCreateWithoutUserInput>
  }

  export type ImmobillionFormUpdateWithWhereUniqueWithoutUserInput = {
    where: ImmobillionFormWhereUniqueInput
    data: XOR<ImmobillionFormUpdateWithoutUserInput, ImmobillionFormUncheckedUpdateWithoutUserInput>
  }

  export type ImmobillionFormUpdateManyWithWhereWithoutUserInput = {
    where: ImmobillionFormScalarWhereInput
    data: XOR<ImmobillionFormUpdateManyMutationInput, ImmobillionFormUncheckedUpdateManyWithoutUserInput>
  }

  export type ImmobillionFormScalarWhereInput = {
    AND?: ImmobillionFormScalarWhereInput | ImmobillionFormScalarWhereInput[]
    OR?: ImmobillionFormScalarWhereInput[]
    NOT?: ImmobillionFormScalarWhereInput | ImmobillionFormScalarWhereInput[]
    id?: StringFilter<"ImmobillionForm"> | string
    status?: StringFilter<"ImmobillionForm"> | string
    createdAt?: DateTimeFilter<"ImmobillionForm"> | Date | string
    updatedAt?: DateTimeFilter<"ImmobillionForm"> | Date | string
    userId?: StringFilter<"ImmobillionForm"> | string
    formType?: StringFilter<"ImmobillionForm"> | string
    formVersion?: StringFilter<"ImmobillionForm"> | string
  }

  export type PersonalDetailsUpsertWithoutUserInput = {
    update: XOR<PersonalDetailsUpdateWithoutUserInput, PersonalDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<PersonalDetailsCreateWithoutUserInput, PersonalDetailsUncheckedCreateWithoutUserInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutUserInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutUserInput, PersonalDetailsUncheckedUpdateWithoutUserInput>
  }

  export type PersonalDetailsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUpsertWithWhereUniqueWithoutCoachInput = {
    where: PersonalDetailsWhereUniqueInput
    update: XOR<PersonalDetailsUpdateWithoutCoachInput, PersonalDetailsUncheckedUpdateWithoutCoachInput>
    create: XOR<PersonalDetailsCreateWithoutCoachInput, PersonalDetailsUncheckedCreateWithoutCoachInput>
  }

  export type PersonalDetailsUpdateWithWhereUniqueWithoutCoachInput = {
    where: PersonalDetailsWhereUniqueInput
    data: XOR<PersonalDetailsUpdateWithoutCoachInput, PersonalDetailsUncheckedUpdateWithoutCoachInput>
  }

  export type PersonalDetailsUpdateManyWithWhereWithoutCoachInput = {
    where: PersonalDetailsScalarWhereInput
    data: XOR<PersonalDetailsUpdateManyMutationInput, PersonalDetailsUncheckedUpdateManyWithoutCoachInput>
  }

  export type PersonalDetailsScalarWhereInput = {
    AND?: PersonalDetailsScalarWhereInput | PersonalDetailsScalarWhereInput[]
    OR?: PersonalDetailsScalarWhereInput[]
    NOT?: PersonalDetailsScalarWhereInput | PersonalDetailsScalarWhereInput[]
    id?: StringFilter<"PersonalDetails"> | string
    userId?: StringFilter<"PersonalDetails"> | string
    createdAt?: DateTimeFilter<"PersonalDetails"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalDetails"> | Date | string
    coachId?: StringFilter<"PersonalDetails"> | string
    applicantType?: EnumApplicantTypeFilter<"PersonalDetails"> | $Enums.ApplicantType
    firstName?: StringFilter<"PersonalDetails"> | string
    lastName?: StringFilter<"PersonalDetails"> | string
    streetAddress?: StringFilter<"PersonalDetails"> | string
    postalCode?: StringFilter<"PersonalDetails"> | string
    city?: StringFilter<"PersonalDetails"> | string
    phone?: StringFilter<"PersonalDetails"> | string
    email?: StringFilter<"PersonalDetails"> | string
    birthDate?: DateTimeFilter<"PersonalDetails"> | Date | string
    birthPlace?: StringFilter<"PersonalDetails"> | string
    maritalStatus?: StringFilter<"PersonalDetails"> | string
    nationality?: StringFilter<"PersonalDetails"> | string
    housing?: StringFilter<"PersonalDetails"> | string
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    analysisForms?: AnalysisFormCreateNestedManyWithoutUserInput
    immobillionForms?: ImmobillionFormCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsCreateNestedOneWithoutUserInput
    clientsAsCoach?: PersonalDetailsCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    analysisForms?: AnalysisFormUncheckedCreateNestedManyWithoutUserInput
    immobillionForms?: ImmobillionFormUncheckedCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsUncheckedCreateNestedOneWithoutUserInput
    clientsAsCoach?: PersonalDetailsUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    profileImage?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    firebaseUid?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: StringFilter<"User"> | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type AnalysisFormCreateWithoutChildrenInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
    user: UserCreateNestedOneWithoutAnalysisFormsInput
    applicants?: ApplicantCreateNestedManyWithoutAnalysisFormInput
  }

  export type AnalysisFormUncheckedCreateWithoutChildrenInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
    applicants?: ApplicantUncheckedCreateNestedManyWithoutAnalysisFormInput
  }

  export type AnalysisFormCreateOrConnectWithoutChildrenInput = {
    where: AnalysisFormWhereUniqueInput
    create: XOR<AnalysisFormCreateWithoutChildrenInput, AnalysisFormUncheckedCreateWithoutChildrenInput>
  }

  export type AnalysisFormUpsertWithoutChildrenInput = {
    update: XOR<AnalysisFormUpdateWithoutChildrenInput, AnalysisFormUncheckedUpdateWithoutChildrenInput>
    create: XOR<AnalysisFormCreateWithoutChildrenInput, AnalysisFormUncheckedCreateWithoutChildrenInput>
    where?: AnalysisFormWhereInput
  }

  export type AnalysisFormUpdateToOneWithWhereWithoutChildrenInput = {
    where?: AnalysisFormWhereInput
    data: XOR<AnalysisFormUpdateWithoutChildrenInput, AnalysisFormUncheckedUpdateWithoutChildrenInput>
  }

  export type AnalysisFormUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalysisFormsNestedInput
    applicants?: ApplicantUpdateManyWithoutAnalysisFormNestedInput
  }

  export type AnalysisFormUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    applicants?: ApplicantUncheckedUpdateManyWithoutAnalysisFormNestedInput
  }

  export type AnalysisFormCreateWithoutApplicantsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
    user: UserCreateNestedOneWithoutAnalysisFormsInput
    children?: ChildCreateNestedManyWithoutAnalysisFormInput
  }

  export type AnalysisFormUncheckedCreateWithoutApplicantsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutAnalysisFormInput
  }

  export type AnalysisFormCreateOrConnectWithoutApplicantsInput = {
    where: AnalysisFormWhereUniqueInput
    create: XOR<AnalysisFormCreateWithoutApplicantsInput, AnalysisFormUncheckedCreateWithoutApplicantsInput>
  }

  export type ImmobillionFormCreateWithoutApplicantsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType?: string
    formVersion?: string
    user: UserCreateNestedOneWithoutImmobillionFormsInput
  }

  export type ImmobillionFormUncheckedCreateWithoutApplicantsInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    formType?: string
    formVersion?: string
  }

  export type ImmobillionFormCreateOrConnectWithoutApplicantsInput = {
    where: ImmobillionFormWhereUniqueInput
    create: XOR<ImmobillionFormCreateWithoutApplicantsInput, ImmobillionFormUncheckedCreateWithoutApplicantsInput>
  }

  export type ImmobillionApplicantDetailsCreateWithoutApplicantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryCurrency?: string | null
    salaryCurrencyOther?: string | null
    hasPartTimeJob: boolean
    partTimeSince?: Date | string | null
    isFreelancer: boolean
    isSelfEmployed: boolean
    selfEmployedAs?: string | null
    selfEmployedSince?: Date | string | null
    selfEmployedCompany?: string | null
    vehiclesInHousehold: number
    retirementStart?: Date | string | null
    statutoryPension?: Decimal | DecimalJsLike | number | string | null
    privatePension?: Decimal | DecimalJsLike | number | string | null
    interpreterRequired: boolean
    monthlyIncome: JsonNullValueInput | InputJsonValue
    monthlyExpenses: JsonNullValueInput | InputJsonValue
    assets: JsonNullValueInput | InputJsonValue
    liabilities: JsonNullValueInput | InputJsonValue
  }

  export type ImmobillionApplicantDetailsUncheckedCreateWithoutApplicantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryCurrency?: string | null
    salaryCurrencyOther?: string | null
    hasPartTimeJob: boolean
    partTimeSince?: Date | string | null
    isFreelancer: boolean
    isSelfEmployed: boolean
    selfEmployedAs?: string | null
    selfEmployedSince?: Date | string | null
    selfEmployedCompany?: string | null
    vehiclesInHousehold: number
    retirementStart?: Date | string | null
    statutoryPension?: Decimal | DecimalJsLike | number | string | null
    privatePension?: Decimal | DecimalJsLike | number | string | null
    interpreterRequired: boolean
    monthlyIncome: JsonNullValueInput | InputJsonValue
    monthlyExpenses: JsonNullValueInput | InputJsonValue
    assets: JsonNullValueInput | InputJsonValue
    liabilities: JsonNullValueInput | InputJsonValue
  }

  export type ImmobillionApplicantDetailsCreateOrConnectWithoutApplicantInput = {
    where: ImmobillionApplicantDetailsWhereUniqueInput
    create: XOR<ImmobillionApplicantDetailsCreateWithoutApplicantInput, ImmobillionApplicantDetailsUncheckedCreateWithoutApplicantInput>
  }

  export type AnalysisFormUpsertWithoutApplicantsInput = {
    update: XOR<AnalysisFormUpdateWithoutApplicantsInput, AnalysisFormUncheckedUpdateWithoutApplicantsInput>
    create: XOR<AnalysisFormCreateWithoutApplicantsInput, AnalysisFormUncheckedCreateWithoutApplicantsInput>
    where?: AnalysisFormWhereInput
  }

  export type AnalysisFormUpdateToOneWithWhereWithoutApplicantsInput = {
    where?: AnalysisFormWhereInput
    data: XOR<AnalysisFormUpdateWithoutApplicantsInput, AnalysisFormUncheckedUpdateWithoutApplicantsInput>
  }

  export type AnalysisFormUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalysisFormsNestedInput
    children?: ChildUpdateManyWithoutAnalysisFormNestedInput
  }

  export type AnalysisFormUncheckedUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutAnalysisFormNestedInput
  }

  export type ImmobillionFormUpsertWithoutApplicantsInput = {
    update: XOR<ImmobillionFormUpdateWithoutApplicantsInput, ImmobillionFormUncheckedUpdateWithoutApplicantsInput>
    create: XOR<ImmobillionFormCreateWithoutApplicantsInput, ImmobillionFormUncheckedCreateWithoutApplicantsInput>
    where?: ImmobillionFormWhereInput
  }

  export type ImmobillionFormUpdateToOneWithWhereWithoutApplicantsInput = {
    where?: ImmobillionFormWhereInput
    data: XOR<ImmobillionFormUpdateWithoutApplicantsInput, ImmobillionFormUncheckedUpdateWithoutApplicantsInput>
  }

  export type ImmobillionFormUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutImmobillionFormsNestedInput
  }

  export type ImmobillionFormUncheckedUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
  }

  export type ImmobillionApplicantDetailsUpsertWithoutApplicantInput = {
    update: XOR<ImmobillionApplicantDetailsUpdateWithoutApplicantInput, ImmobillionApplicantDetailsUncheckedUpdateWithoutApplicantInput>
    create: XOR<ImmobillionApplicantDetailsCreateWithoutApplicantInput, ImmobillionApplicantDetailsUncheckedCreateWithoutApplicantInput>
    where?: ImmobillionApplicantDetailsWhereInput
  }

  export type ImmobillionApplicantDetailsUpdateToOneWithWhereWithoutApplicantInput = {
    where?: ImmobillionApplicantDetailsWhereInput
    data: XOR<ImmobillionApplicantDetailsUpdateWithoutApplicantInput, ImmobillionApplicantDetailsUncheckedUpdateWithoutApplicantInput>
  }

  export type ImmobillionApplicantDetailsUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryCurrencyOther?: NullableStringFieldUpdateOperationsInput | string | null
    hasPartTimeJob?: BoolFieldUpdateOperationsInput | boolean
    partTimeSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFreelancer?: BoolFieldUpdateOperationsInput | boolean
    isSelfEmployed?: BoolFieldUpdateOperationsInput | boolean
    selfEmployedAs?: NullableStringFieldUpdateOperationsInput | string | null
    selfEmployedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    selfEmployedCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesInHousehold?: IntFieldUpdateOperationsInput | number
    retirementStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutoryPension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    privatePension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolFieldUpdateOperationsInput | boolean
    monthlyIncome?: JsonNullValueInput | InputJsonValue
    monthlyExpenses?: JsonNullValueInput | InputJsonValue
    assets?: JsonNullValueInput | InputJsonValue
    liabilities?: JsonNullValueInput | InputJsonValue
  }

  export type ImmobillionApplicantDetailsUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryCurrencyOther?: NullableStringFieldUpdateOperationsInput | string | null
    hasPartTimeJob?: BoolFieldUpdateOperationsInput | boolean
    partTimeSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isFreelancer?: BoolFieldUpdateOperationsInput | boolean
    isSelfEmployed?: BoolFieldUpdateOperationsInput | boolean
    selfEmployedAs?: NullableStringFieldUpdateOperationsInput | string | null
    selfEmployedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    selfEmployedCompany?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesInHousehold?: IntFieldUpdateOperationsInput | number
    retirementStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutoryPension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    privatePension?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    interpreterRequired?: BoolFieldUpdateOperationsInput | boolean
    monthlyIncome?: JsonNullValueInput | InputJsonValue
    monthlyExpenses?: JsonNullValueInput | InputJsonValue
    assets?: JsonNullValueInput | InputJsonValue
    liabilities?: JsonNullValueInput | InputJsonValue
  }

  export type ApplicantCreateWithoutImmobillionDetailsInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    analysisForm?: AnalysisFormCreateNestedOneWithoutApplicantsInput
    immobillionForm?: ImmobillionFormCreateNestedOneWithoutApplicantsInput
  }

  export type ApplicantUncheckedCreateWithoutImmobillionDetailsInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    analysisFormId?: string | null
    immobillionFormId?: string | null
  }

  export type ApplicantCreateOrConnectWithoutImmobillionDetailsInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutImmobillionDetailsInput, ApplicantUncheckedCreateWithoutImmobillionDetailsInput>
  }

  export type ApplicantUpsertWithoutImmobillionDetailsInput = {
    update: XOR<ApplicantUpdateWithoutImmobillionDetailsInput, ApplicantUncheckedUpdateWithoutImmobillionDetailsInput>
    create: XOR<ApplicantCreateWithoutImmobillionDetailsInput, ApplicantUncheckedCreateWithoutImmobillionDetailsInput>
    where?: ApplicantWhereInput
  }

  export type ApplicantUpdateToOneWithWhereWithoutImmobillionDetailsInput = {
    where?: ApplicantWhereInput
    data: XOR<ApplicantUpdateWithoutImmobillionDetailsInput, ApplicantUncheckedUpdateWithoutImmobillionDetailsInput>
  }

  export type ApplicantUpdateWithoutImmobillionDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    analysisForm?: AnalysisFormUpdateOneWithoutApplicantsNestedInput
    immobillionForm?: ImmobillionFormUpdateOneWithoutApplicantsNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutImmobillionDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    analysisFormId?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionFormId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutImmobillionFormsInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    analysisForms?: AnalysisFormCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsCreateNestedOneWithoutUserInput
    clientsAsCoach?: PersonalDetailsCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutImmobillionFormsInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    analysisForms?: AnalysisFormUncheckedCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsUncheckedCreateNestedOneWithoutUserInput
    clientsAsCoach?: PersonalDetailsUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutImmobillionFormsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImmobillionFormsInput, UserUncheckedCreateWithoutImmobillionFormsInput>
  }

  export type ApplicantCreateWithoutImmobillionFormInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    analysisForm?: AnalysisFormCreateNestedOneWithoutApplicantsInput
    immobillionDetails?: ImmobillionApplicantDetailsCreateNestedOneWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutImmobillionFormInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    analysisFormId?: string | null
    immobillionDetails?: ImmobillionApplicantDetailsUncheckedCreateNestedOneWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutImmobillionFormInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutImmobillionFormInput, ApplicantUncheckedCreateWithoutImmobillionFormInput>
  }

  export type ApplicantCreateManyImmobillionFormInputEnvelope = {
    data: ApplicantCreateManyImmobillionFormInput | ApplicantCreateManyImmobillionFormInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutImmobillionFormsInput = {
    update: XOR<UserUpdateWithoutImmobillionFormsInput, UserUncheckedUpdateWithoutImmobillionFormsInput>
    create: XOR<UserCreateWithoutImmobillionFormsInput, UserUncheckedCreateWithoutImmobillionFormsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutImmobillionFormsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutImmobillionFormsInput, UserUncheckedUpdateWithoutImmobillionFormsInput>
  }

  export type UserUpdateWithoutImmobillionFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    analysisForms?: AnalysisFormUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUpdateOneWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutImmobillionFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisForms?: AnalysisFormUncheckedUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUncheckedUpdateOneWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ApplicantUpsertWithWhereUniqueWithoutImmobillionFormInput = {
    where: ApplicantWhereUniqueInput
    update: XOR<ApplicantUpdateWithoutImmobillionFormInput, ApplicantUncheckedUpdateWithoutImmobillionFormInput>
    create: XOR<ApplicantCreateWithoutImmobillionFormInput, ApplicantUncheckedCreateWithoutImmobillionFormInput>
  }

  export type ApplicantUpdateWithWhereUniqueWithoutImmobillionFormInput = {
    where: ApplicantWhereUniqueInput
    data: XOR<ApplicantUpdateWithoutImmobillionFormInput, ApplicantUncheckedUpdateWithoutImmobillionFormInput>
  }

  export type ApplicantUpdateManyWithWhereWithoutImmobillionFormInput = {
    where: ApplicantScalarWhereInput
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyWithoutImmobillionFormInput>
  }

  export type ApplicantScalarWhereInput = {
    AND?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
    OR?: ApplicantScalarWhereInput[]
    NOT?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
    id?: StringFilter<"Applicant"> | string
    type?: StringFilter<"Applicant"> | string
    createdAt?: DateTimeFilter<"Applicant"> | Date | string
    updatedAt?: DateTimeFilter<"Applicant"> | Date | string
    salutation?: StringNullableFilter<"Applicant"> | string | null
    title?: StringNullableFilter<"Applicant"> | string | null
    firstName?: StringFilter<"Applicant"> | string
    lastName?: StringFilter<"Applicant"> | string
    maidenName?: StringNullableFilter<"Applicant"> | string | null
    birthDate?: DateTimeFilter<"Applicant"> | Date | string
    birthPlace?: StringFilter<"Applicant"> | string
    birthCountry?: StringNullableFilter<"Applicant"> | string | null
    nationality?: StringFilter<"Applicant"> | string
    isEUCitizen?: BoolNullableFilter<"Applicant"> | boolean | null
    residencePermit?: StringNullableFilter<"Applicant"> | string | null
    inGermanySince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    street?: StringFilter<"Applicant"> | string
    houseNumber?: StringNullableFilter<"Applicant"> | string | null
    postalCode?: StringFilter<"Applicant"> | string
    city?: StringFilter<"Applicant"> | string
    residentSince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    previousAddress?: JsonNullableFilter<"Applicant">
    phoneLandline?: StringNullableFilter<"Applicant"> | string | null
    phoneMobile?: StringFilter<"Applicant"> | string
    email?: StringFilter<"Applicant"> | string
    taxId?: StringNullableFilter<"Applicant"> | string | null
    maritalStatus?: StringFilter<"Applicant"> | string
    separationOfGoods?: BoolNullableFilter<"Applicant"> | boolean | null
    numberOfChildren?: IntFilter<"Applicant"> | number
    childrenBirthDates?: DateTimeNullableListFilter<"Applicant">
    profession?: StringFilter<"Applicant"> | string
    employmentType?: StringNullableFilter<"Applicant"> | string | null
    employedSince?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    contractType?: StringFilter<"Applicant"> | string
    contractUntil?: DateTimeNullableFilter<"Applicant"> | Date | string | null
    employerName?: StringNullableFilter<"Applicant"> | string | null
    employerInGermany?: BoolNullableFilter<"Applicant"> | boolean | null
    netIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFilter<"Applicant"> | number
    childBenefit?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFilter<"Applicant"> | Decimal | DecimalJsLike | number | string
    iban?: StringNullableFilter<"Applicant"> | string | null
    bic?: StringNullableFilter<"Applicant"> | string | null
    analysisFormId?: StringNullableFilter<"Applicant"> | string | null
    immobillionFormId?: StringNullableFilter<"Applicant"> | string | null
  }

  export type UserCreateWithoutAnalysisFormsInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    immobillionForms?: ImmobillionFormCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsCreateNestedOneWithoutUserInput
    clientsAsCoach?: PersonalDetailsCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutAnalysisFormsInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    immobillionForms?: ImmobillionFormUncheckedCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsUncheckedCreateNestedOneWithoutUserInput
    clientsAsCoach?: PersonalDetailsUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutAnalysisFormsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalysisFormsInput, UserUncheckedCreateWithoutAnalysisFormsInput>
  }

  export type ChildCreateWithoutAnalysisFormInput = {
    id?: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace: string
    nationality: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildUncheckedCreateWithoutAnalysisFormInput = {
    id?: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace: string
    nationality: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildCreateOrConnectWithoutAnalysisFormInput = {
    where: ChildWhereUniqueInput
    create: XOR<ChildCreateWithoutAnalysisFormInput, ChildUncheckedCreateWithoutAnalysisFormInput>
  }

  export type ChildCreateManyAnalysisFormInputEnvelope = {
    data: ChildCreateManyAnalysisFormInput | ChildCreateManyAnalysisFormInput[]
    skipDuplicates?: boolean
  }

  export type ApplicantCreateWithoutAnalysisFormInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    immobillionForm?: ImmobillionFormCreateNestedOneWithoutApplicantsInput
    immobillionDetails?: ImmobillionApplicantDetailsCreateNestedOneWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutAnalysisFormInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    immobillionFormId?: string | null
    immobillionDetails?: ImmobillionApplicantDetailsUncheckedCreateNestedOneWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutAnalysisFormInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutAnalysisFormInput, ApplicantUncheckedCreateWithoutAnalysisFormInput>
  }

  export type ApplicantCreateManyAnalysisFormInputEnvelope = {
    data: ApplicantCreateManyAnalysisFormInput | ApplicantCreateManyAnalysisFormInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAnalysisFormsInput = {
    update: XOR<UserUpdateWithoutAnalysisFormsInput, UserUncheckedUpdateWithoutAnalysisFormsInput>
    create: XOR<UserCreateWithoutAnalysisFormsInput, UserUncheckedCreateWithoutAnalysisFormsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalysisFormsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalysisFormsInput, UserUncheckedUpdateWithoutAnalysisFormsInput>
  }

  export type UserUpdateWithoutAnalysisFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    immobillionForms?: ImmobillionFormUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUpdateOneWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalysisFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    immobillionForms?: ImmobillionFormUncheckedUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUncheckedUpdateOneWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ChildUpsertWithWhereUniqueWithoutAnalysisFormInput = {
    where: ChildWhereUniqueInput
    update: XOR<ChildUpdateWithoutAnalysisFormInput, ChildUncheckedUpdateWithoutAnalysisFormInput>
    create: XOR<ChildCreateWithoutAnalysisFormInput, ChildUncheckedCreateWithoutAnalysisFormInput>
  }

  export type ChildUpdateWithWhereUniqueWithoutAnalysisFormInput = {
    where: ChildWhereUniqueInput
    data: XOR<ChildUpdateWithoutAnalysisFormInput, ChildUncheckedUpdateWithoutAnalysisFormInput>
  }

  export type ChildUpdateManyWithWhereWithoutAnalysisFormInput = {
    where: ChildScalarWhereInput
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyWithoutAnalysisFormInput>
  }

  export type ChildScalarWhereInput = {
    AND?: ChildScalarWhereInput | ChildScalarWhereInput[]
    OR?: ChildScalarWhereInput[]
    NOT?: ChildScalarWhereInput | ChildScalarWhereInput[]
    id?: StringFilter<"Child"> | string
    firstName?: StringFilter<"Child"> | string
    lastName?: StringFilter<"Child"> | string
    birthDate?: DateTimeFilter<"Child"> | Date | string
    birthPlace?: StringFilter<"Child"> | string
    nationality?: StringFilter<"Child"> | string
    createdAt?: DateTimeFilter<"Child"> | Date | string
    updatedAt?: DateTimeFilter<"Child"> | Date | string
    analysisFormId?: StringFilter<"Child"> | string
  }

  export type ApplicantUpsertWithWhereUniqueWithoutAnalysisFormInput = {
    where: ApplicantWhereUniqueInput
    update: XOR<ApplicantUpdateWithoutAnalysisFormInput, ApplicantUncheckedUpdateWithoutAnalysisFormInput>
    create: XOR<ApplicantCreateWithoutAnalysisFormInput, ApplicantUncheckedCreateWithoutAnalysisFormInput>
  }

  export type ApplicantUpdateWithWhereUniqueWithoutAnalysisFormInput = {
    where: ApplicantWhereUniqueInput
    data: XOR<ApplicantUpdateWithoutAnalysisFormInput, ApplicantUncheckedUpdateWithoutAnalysisFormInput>
  }

  export type ApplicantUpdateManyWithWhereWithoutAnalysisFormInput = {
    where: ApplicantScalarWhereInput
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyWithoutAnalysisFormInput>
  }

  export type UserCreateWithoutPersonalDetailsInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    analysisForms?: AnalysisFormCreateNestedManyWithoutUserInput
    immobillionForms?: ImmobillionFormCreateNestedManyWithoutUserInput
    clientsAsCoach?: PersonalDetailsCreateNestedManyWithoutCoachInput
  }

  export type UserUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    analysisForms?: AnalysisFormUncheckedCreateNestedManyWithoutUserInput
    immobillionForms?: ImmobillionFormUncheckedCreateNestedManyWithoutUserInput
    clientsAsCoach?: PersonalDetailsUncheckedCreateNestedManyWithoutCoachInput
  }

  export type UserCreateOrConnectWithoutPersonalDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalDetailsInput, UserUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type UserCreateWithoutClientsAsCoachInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    role: RoleCreateNestedOneWithoutUsersInput
    analysisForms?: AnalysisFormCreateNestedManyWithoutUserInput
    immobillionForms?: ImmobillionFormCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientsAsCoachInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    analysisForms?: AnalysisFormUncheckedCreateNestedManyWithoutUserInput
    immobillionForms?: ImmobillionFormUncheckedCreateNestedManyWithoutUserInput
    personalDetails?: PersonalDetailsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientsAsCoachInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientsAsCoachInput, UserUncheckedCreateWithoutClientsAsCoachInput>
  }

  export type EmploymentDetailsCreateWithoutPersonalDetailsInput = {
    id?: string
    employmentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employmentType: $Enums.EmploymentType
    occupation: string
    contractType: string
    contractDuration: string
    employerName: string
    employedSince: Date | string
  }

  export type EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    employmentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employmentType: $Enums.EmploymentType
    occupation: string
    contractType: string
    contractDuration: string
    employerName: string
    employedSince: Date | string
  }

  export type EmploymentDetailsCreateOrConnectWithoutPersonalDetailsInput = {
    where: EmploymentDetailsWhereUniqueInput
    create: XOR<EmploymentDetailsCreateWithoutPersonalDetailsInput, EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type EmploymentDetailsCreateManyPersonalDetailsInputEnvelope = {
    data: EmploymentDetailsCreateManyPersonalDetailsInput | EmploymentDetailsCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type IncomeDetailsCreateWithoutPersonalDetailsInput = {
    id?: string
    incomeId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grossIncome: Decimal | DecimalJsLike | number | string
    netIncome: Decimal | DecimalJsLike | number | string
    taxClass: string
    taxId: string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    incomeTradeBusiness: Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork: Decimal | DecimalJsLike | number | string
    incomeSideJob: Decimal | DecimalJsLike | number | string
  }

  export type IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    incomeId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grossIncome: Decimal | DecimalJsLike | number | string
    netIncome: Decimal | DecimalJsLike | number | string
    taxClass: string
    taxId: string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    incomeTradeBusiness: Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork: Decimal | DecimalJsLike | number | string
    incomeSideJob: Decimal | DecimalJsLike | number | string
  }

  export type IncomeDetailsCreateOrConnectWithoutPersonalDetailsInput = {
    where: IncomeDetailsWhereUniqueInput
    create: XOR<IncomeDetailsCreateWithoutPersonalDetailsInput, IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type IncomeDetailsCreateManyPersonalDetailsInputEnvelope = {
    data: IncomeDetailsCreateManyPersonalDetailsInput | IncomeDetailsCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type ExpensesDetailsCreateWithoutPersonalDetailsInput = {
    id?: string
    expensesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    expensesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsCreateOrConnectWithoutPersonalDetailsInput = {
    where: ExpensesDetailsWhereUniqueInput
    create: XOR<ExpensesDetailsCreateWithoutPersonalDetailsInput, ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type ExpensesDetailsCreateManyPersonalDetailsInputEnvelope = {
    data: ExpensesDetailsCreateManyPersonalDetailsInput | ExpensesDetailsCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutPersonalDetailsInput = {
    id?: string
    assetId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstate: Decimal | DecimalJsLike | number | string
    securities: Decimal | DecimalJsLike | number | string
    bankDeposits: Decimal | DecimalJsLike | number | string
    buildingSavings: Decimal | DecimalJsLike | number | string
    insuranceValues: Decimal | DecimalJsLike | number | string
    otherAssets: Decimal | DecimalJsLike | number | string
  }

  export type AssetUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    assetId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstate: Decimal | DecimalJsLike | number | string
    securities: Decimal | DecimalJsLike | number | string
    bankDeposits: Decimal | DecimalJsLike | number | string
    buildingSavings: Decimal | DecimalJsLike | number | string
    insuranceValues: Decimal | DecimalJsLike | number | string
    otherAssets: Decimal | DecimalJsLike | number | string
  }

  export type AssetCreateOrConnectWithoutPersonalDetailsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutPersonalDetailsInput, AssetUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type AssetCreateManyPersonalDetailsInputEnvelope = {
    data: AssetCreateManyPersonalDetailsInput | AssetCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type LiabilityCreateWithoutPersonalDetailsInput = {
    id?: string
    liabilityId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loanType: $Enums.LoanType
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
  }

  export type LiabilityUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    liabilityId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loanType: $Enums.LoanType
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
  }

  export type LiabilityCreateOrConnectWithoutPersonalDetailsInput = {
    where: LiabilityWhereUniqueInput
    create: XOR<LiabilityCreateWithoutPersonalDetailsInput, LiabilityUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type LiabilityCreateManyPersonalDetailsInputEnvelope = {
    data: LiabilityCreateManyPersonalDetailsInput | LiabilityCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type GoalsAndWishesCreateWithoutPersonalDetailsInput = {
    id?: string
    goalsAndWishesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    retirementPlanning: string
    capitalFormation: string
    realEstateGoals: string
    financing: string
    protection: string
    healthcareProvision: string
    otherGoals: string
  }

  export type GoalsAndWishesUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    goalsAndWishesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    retirementPlanning: string
    capitalFormation: string
    realEstateGoals: string
    financing: string
    protection: string
    healthcareProvision: string
    otherGoals: string
  }

  export type GoalsAndWishesCreateOrConnectWithoutPersonalDetailsInput = {
    where: GoalsAndWishesWhereUniqueInput
    create: XOR<GoalsAndWishesCreateWithoutPersonalDetailsInput, GoalsAndWishesUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type RiskAppetiteCreateWithoutPersonalDetailsInput = {
    id?: string
    riskAppetiteId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    riskAppetite: string
    investmentHorizon: string
    knowledgeExperience: string
    healthInsurance: string
    healthInsuranceNumber: string
    healthInsuranceProof: string
  }

  export type RiskAppetiteUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    riskAppetiteId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    riskAppetite: string
    investmentHorizon: string
    knowledgeExperience: string
    healthInsurance: string
    healthInsuranceNumber: string
    healthInsuranceProof: string
  }

  export type RiskAppetiteCreateOrConnectWithoutPersonalDetailsInput = {
    where: RiskAppetiteWhereUniqueInput
    create: XOR<RiskAppetiteCreateWithoutPersonalDetailsInput, RiskAppetiteUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type ConsentCreateWithoutPersonalDetailsInput = {
    id?: string
    consentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consentType: $Enums.ConsentType
    consent: boolean
    consentText: string
    consentSignature: string
    consentDate: Date | string
    location: string
  }

  export type ConsentUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    consentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consentType: $Enums.ConsentType
    consent: boolean
    consentText: string
    consentSignature: string
    consentDate: Date | string
    location: string
  }

  export type ConsentCreateOrConnectWithoutPersonalDetailsInput = {
    where: ConsentWhereUniqueInput
    create: XOR<ConsentCreateWithoutPersonalDetailsInput, ConsentUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type ConsentCreateManyPersonalDetailsInputEnvelope = {
    data: ConsentCreateManyPersonalDetailsInput | ConsentCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutPersonalDetailsInput = {
    id?: string
    documentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName: string
    documentLocation: string
    documentDate: Date | string
  }

  export type DocumentUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    documentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName: string
    documentLocation: string
    documentDate: Date | string
  }

  export type DocumentCreateOrConnectWithoutPersonalDetailsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPersonalDetailsInput, DocumentUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type DocumentCreateManyPersonalDetailsInputEnvelope = {
    data: DocumentCreateManyPersonalDetailsInput | DocumentCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type FormCreateWithoutPersonalDetailsInput = {
    id?: string
    formId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType: $Enums.FormType
    formName: string
    formLink: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type FormUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    formId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType: $Enums.FormType
    formName: string
    formLink: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type FormCreateOrConnectWithoutPersonalDetailsInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutPersonalDetailsInput, FormUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type FormCreateManyPersonalDetailsInputEnvelope = {
    data: FormCreateManyPersonalDetailsInput | FormCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type CustomFormCreateWithoutPersonalDetailsInput = {
    id?: string
    customFormId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formTemplate: string
    formName: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type CustomFormUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    customFormId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formTemplate: string
    formName: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type CustomFormCreateOrConnectWithoutPersonalDetailsInput = {
    where: CustomFormWhereUniqueInput
    create: XOR<CustomFormCreateWithoutPersonalDetailsInput, CustomFormUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type CustomFormCreateManyPersonalDetailsInputEnvelope = {
    data: CustomFormCreateManyPersonalDetailsInput | CustomFormCreateManyPersonalDetailsInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPersonalDetailsInput = {
    update: XOR<UserUpdateWithoutPersonalDetailsInput, UserUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<UserCreateWithoutPersonalDetailsInput, UserUncheckedCreateWithoutPersonalDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonalDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonalDetailsInput, UserUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type UserUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    analysisForms?: AnalysisFormUpdateManyWithoutUserNestedInput
    immobillionForms?: ImmobillionFormUpdateManyWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisForms?: AnalysisFormUncheckedUpdateManyWithoutUserNestedInput
    immobillionForms?: ImmobillionFormUncheckedUpdateManyWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserUpsertWithoutClientsAsCoachInput = {
    update: XOR<UserUpdateWithoutClientsAsCoachInput, UserUncheckedUpdateWithoutClientsAsCoachInput>
    create: XOR<UserCreateWithoutClientsAsCoachInput, UserUncheckedCreateWithoutClientsAsCoachInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientsAsCoachInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientsAsCoachInput, UserUncheckedUpdateWithoutClientsAsCoachInput>
  }

  export type UserUpdateWithoutClientsAsCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    analysisForms?: AnalysisFormUpdateManyWithoutUserNestedInput
    immobillionForms?: ImmobillionFormUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientsAsCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisForms?: AnalysisFormUncheckedUpdateManyWithoutUserNestedInput
    immobillionForms?: ImmobillionFormUncheckedUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EmploymentDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: EmploymentDetailsWhereUniqueInput
    update: XOR<EmploymentDetailsUpdateWithoutPersonalDetailsInput, EmploymentDetailsUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<EmploymentDetailsCreateWithoutPersonalDetailsInput, EmploymentDetailsUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type EmploymentDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: EmploymentDetailsWhereUniqueInput
    data: XOR<EmploymentDetailsUpdateWithoutPersonalDetailsInput, EmploymentDetailsUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type EmploymentDetailsUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: EmploymentDetailsScalarWhereInput
    data: XOR<EmploymentDetailsUpdateManyMutationInput, EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type EmploymentDetailsScalarWhereInput = {
    AND?: EmploymentDetailsScalarWhereInput | EmploymentDetailsScalarWhereInput[]
    OR?: EmploymentDetailsScalarWhereInput[]
    NOT?: EmploymentDetailsScalarWhereInput | EmploymentDetailsScalarWhereInput[]
    id?: StringFilter<"EmploymentDetails"> | string
    employmentId?: StringFilter<"EmploymentDetails"> | string
    createdAt?: DateTimeFilter<"EmploymentDetails"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentDetails"> | Date | string
    personalId?: StringFilter<"EmploymentDetails"> | string
    employmentType?: EnumEmploymentTypeFilter<"EmploymentDetails"> | $Enums.EmploymentType
    occupation?: StringFilter<"EmploymentDetails"> | string
    contractType?: StringFilter<"EmploymentDetails"> | string
    contractDuration?: StringFilter<"EmploymentDetails"> | string
    employerName?: StringFilter<"EmploymentDetails"> | string
    employedSince?: DateTimeFilter<"EmploymentDetails"> | Date | string
  }

  export type IncomeDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: IncomeDetailsWhereUniqueInput
    update: XOR<IncomeDetailsUpdateWithoutPersonalDetailsInput, IncomeDetailsUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<IncomeDetailsCreateWithoutPersonalDetailsInput, IncomeDetailsUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type IncomeDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: IncomeDetailsWhereUniqueInput
    data: XOR<IncomeDetailsUpdateWithoutPersonalDetailsInput, IncomeDetailsUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type IncomeDetailsUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: IncomeDetailsScalarWhereInput
    data: XOR<IncomeDetailsUpdateManyMutationInput, IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type IncomeDetailsScalarWhereInput = {
    AND?: IncomeDetailsScalarWhereInput | IncomeDetailsScalarWhereInput[]
    OR?: IncomeDetailsScalarWhereInput[]
    NOT?: IncomeDetailsScalarWhereInput | IncomeDetailsScalarWhereInput[]
    id?: StringFilter<"IncomeDetails"> | string
    incomeId?: StringFilter<"IncomeDetails"> | string
    createdAt?: DateTimeFilter<"IncomeDetails"> | Date | string
    updatedAt?: DateTimeFilter<"IncomeDetails"> | Date | string
    personalId?: StringFilter<"IncomeDetails"> | string
    grossIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    taxClass?: StringFilter<"IncomeDetails"> | string
    taxId?: StringFilter<"IncomeDetails"> | string
    numberOfSalaries?: IntFilter<"IncomeDetails"> | number
    childBenefit?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFilter<"IncomeDetails"> | Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: ExpensesDetailsWhereUniqueInput
    update: XOR<ExpensesDetailsUpdateWithoutPersonalDetailsInput, ExpensesDetailsUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<ExpensesDetailsCreateWithoutPersonalDetailsInput, ExpensesDetailsUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type ExpensesDetailsUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: ExpensesDetailsWhereUniqueInput
    data: XOR<ExpensesDetailsUpdateWithoutPersonalDetailsInput, ExpensesDetailsUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type ExpensesDetailsUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: ExpensesDetailsScalarWhereInput
    data: XOR<ExpensesDetailsUpdateManyMutationInput, ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type ExpensesDetailsScalarWhereInput = {
    AND?: ExpensesDetailsScalarWhereInput | ExpensesDetailsScalarWhereInput[]
    OR?: ExpensesDetailsScalarWhereInput[]
    NOT?: ExpensesDetailsScalarWhereInput | ExpensesDetailsScalarWhereInput[]
    id?: StringFilter<"ExpensesDetails"> | string
    expensesId?: StringFilter<"ExpensesDetails"> | string
    createdAt?: DateTimeFilter<"ExpensesDetails"> | Date | string
    updatedAt?: DateTimeFilter<"ExpensesDetails"> | Date | string
    personalId?: StringFilter<"ExpensesDetails"> | string
    coldRent?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    gas?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFilter<"ExpensesDetails"> | Decimal | DecimalJsLike | number | string
  }

  export type AssetUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutPersonalDetailsInput, AssetUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<AssetCreateWithoutPersonalDetailsInput, AssetUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutPersonalDetailsInput, AssetUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type AssetUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    assetId?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    personalId?: StringFilter<"Asset"> | string
    realEstate?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    securities?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
  }

  export type LiabilityUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: LiabilityWhereUniqueInput
    update: XOR<LiabilityUpdateWithoutPersonalDetailsInput, LiabilityUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<LiabilityCreateWithoutPersonalDetailsInput, LiabilityUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type LiabilityUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: LiabilityWhereUniqueInput
    data: XOR<LiabilityUpdateWithoutPersonalDetailsInput, LiabilityUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type LiabilityUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: LiabilityScalarWhereInput
    data: XOR<LiabilityUpdateManyMutationInput, LiabilityUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type LiabilityScalarWhereInput = {
    AND?: LiabilityScalarWhereInput | LiabilityScalarWhereInput[]
    OR?: LiabilityScalarWhereInput[]
    NOT?: LiabilityScalarWhereInput | LiabilityScalarWhereInput[]
    id?: StringFilter<"Liability"> | string
    liabilityId?: StringFilter<"Liability"> | string
    createdAt?: DateTimeFilter<"Liability"> | Date | string
    updatedAt?: DateTimeFilter<"Liability"> | Date | string
    personalId?: StringFilter<"Liability"> | string
    loanType?: EnumLoanTypeFilter<"Liability"> | $Enums.LoanType
    loanBank?: StringNullableFilter<"Liability"> | string | null
    loanAmount?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
    loanInterest?: DecimalNullableFilter<"Liability"> | Decimal | DecimalJsLike | number | string | null
  }

  export type GoalsAndWishesUpsertWithoutPersonalDetailsInput = {
    update: XOR<GoalsAndWishesUpdateWithoutPersonalDetailsInput, GoalsAndWishesUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<GoalsAndWishesCreateWithoutPersonalDetailsInput, GoalsAndWishesUncheckedCreateWithoutPersonalDetailsInput>
    where?: GoalsAndWishesWhereInput
  }

  export type GoalsAndWishesUpdateToOneWithWhereWithoutPersonalDetailsInput = {
    where?: GoalsAndWishesWhereInput
    data: XOR<GoalsAndWishesUpdateWithoutPersonalDetailsInput, GoalsAndWishesUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type GoalsAndWishesUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalsAndWishesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retirementPlanning?: StringFieldUpdateOperationsInput | string
    capitalFormation?: StringFieldUpdateOperationsInput | string
    realEstateGoals?: StringFieldUpdateOperationsInput | string
    financing?: StringFieldUpdateOperationsInput | string
    protection?: StringFieldUpdateOperationsInput | string
    healthcareProvision?: StringFieldUpdateOperationsInput | string
    otherGoals?: StringFieldUpdateOperationsInput | string
  }

  export type GoalsAndWishesUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalsAndWishesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    retirementPlanning?: StringFieldUpdateOperationsInput | string
    capitalFormation?: StringFieldUpdateOperationsInput | string
    realEstateGoals?: StringFieldUpdateOperationsInput | string
    financing?: StringFieldUpdateOperationsInput | string
    protection?: StringFieldUpdateOperationsInput | string
    healthcareProvision?: StringFieldUpdateOperationsInput | string
    otherGoals?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAppetiteUpsertWithoutPersonalDetailsInput = {
    update: XOR<RiskAppetiteUpdateWithoutPersonalDetailsInput, RiskAppetiteUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<RiskAppetiteCreateWithoutPersonalDetailsInput, RiskAppetiteUncheckedCreateWithoutPersonalDetailsInput>
    where?: RiskAppetiteWhereInput
  }

  export type RiskAppetiteUpdateToOneWithWhereWithoutPersonalDetailsInput = {
    where?: RiskAppetiteWhereInput
    data: XOR<RiskAppetiteUpdateWithoutPersonalDetailsInput, RiskAppetiteUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type RiskAppetiteUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskAppetiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskAppetite?: StringFieldUpdateOperationsInput | string
    investmentHorizon?: StringFieldUpdateOperationsInput | string
    knowledgeExperience?: StringFieldUpdateOperationsInput | string
    healthInsurance?: StringFieldUpdateOperationsInput | string
    healthInsuranceNumber?: StringFieldUpdateOperationsInput | string
    healthInsuranceProof?: StringFieldUpdateOperationsInput | string
  }

  export type RiskAppetiteUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskAppetiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    riskAppetite?: StringFieldUpdateOperationsInput | string
    investmentHorizon?: StringFieldUpdateOperationsInput | string
    knowledgeExperience?: StringFieldUpdateOperationsInput | string
    healthInsurance?: StringFieldUpdateOperationsInput | string
    healthInsuranceNumber?: StringFieldUpdateOperationsInput | string
    healthInsuranceProof?: StringFieldUpdateOperationsInput | string
  }

  export type ConsentUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: ConsentWhereUniqueInput
    update: XOR<ConsentUpdateWithoutPersonalDetailsInput, ConsentUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<ConsentCreateWithoutPersonalDetailsInput, ConsentUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type ConsentUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: ConsentWhereUniqueInput
    data: XOR<ConsentUpdateWithoutPersonalDetailsInput, ConsentUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type ConsentUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: ConsentScalarWhereInput
    data: XOR<ConsentUpdateManyMutationInput, ConsentUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type ConsentScalarWhereInput = {
    AND?: ConsentScalarWhereInput | ConsentScalarWhereInput[]
    OR?: ConsentScalarWhereInput[]
    NOT?: ConsentScalarWhereInput | ConsentScalarWhereInput[]
    id?: StringFilter<"Consent"> | string
    consentId?: StringFilter<"Consent"> | string
    createdAt?: DateTimeFilter<"Consent"> | Date | string
    updatedAt?: DateTimeFilter<"Consent"> | Date | string
    personalId?: StringFilter<"Consent"> | string
    consentType?: EnumConsentTypeFilter<"Consent"> | $Enums.ConsentType
    consent?: BoolFilter<"Consent"> | boolean
    consentText?: StringFilter<"Consent"> | string
    consentSignature?: StringFilter<"Consent"> | string
    consentDate?: DateTimeFilter<"Consent"> | Date | string
    location?: StringFilter<"Consent"> | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutPersonalDetailsInput, DocumentUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<DocumentCreateWithoutPersonalDetailsInput, DocumentUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutPersonalDetailsInput, DocumentUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type DocumentUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    documentId?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    personalId?: StringFilter<"Document"> | string
    documentName?: StringFilter<"Document"> | string
    documentLocation?: StringFilter<"Document"> | string
    documentDate?: DateTimeFilter<"Document"> | Date | string
  }

  export type FormUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: FormWhereUniqueInput
    update: XOR<FormUpdateWithoutPersonalDetailsInput, FormUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<FormCreateWithoutPersonalDetailsInput, FormUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type FormUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: FormWhereUniqueInput
    data: XOR<FormUpdateWithoutPersonalDetailsInput, FormUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type FormUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: FormScalarWhereInput
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type FormScalarWhereInput = {
    AND?: FormScalarWhereInput | FormScalarWhereInput[]
    OR?: FormScalarWhereInput[]
    NOT?: FormScalarWhereInput | FormScalarWhereInput[]
    id?: StringFilter<"Form"> | string
    formId?: StringFilter<"Form"> | string
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    personalId?: StringFilter<"Form"> | string
    formType?: EnumFormTypeFilter<"Form"> | $Enums.FormType
    formName?: StringFilter<"Form"> | string
    formLink?: StringFilter<"Form"> | string
    createdDate?: DateTimeFilter<"Form"> | Date | string
    updatedDate?: DateTimeFilter<"Form"> | Date | string
  }

  export type CustomFormUpsertWithWhereUniqueWithoutPersonalDetailsInput = {
    where: CustomFormWhereUniqueInput
    update: XOR<CustomFormUpdateWithoutPersonalDetailsInput, CustomFormUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<CustomFormCreateWithoutPersonalDetailsInput, CustomFormUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type CustomFormUpdateWithWhereUniqueWithoutPersonalDetailsInput = {
    where: CustomFormWhereUniqueInput
    data: XOR<CustomFormUpdateWithoutPersonalDetailsInput, CustomFormUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type CustomFormUpdateManyWithWhereWithoutPersonalDetailsInput = {
    where: CustomFormScalarWhereInput
    data: XOR<CustomFormUpdateManyMutationInput, CustomFormUncheckedUpdateManyWithoutPersonalDetailsInput>
  }

  export type CustomFormScalarWhereInput = {
    AND?: CustomFormScalarWhereInput | CustomFormScalarWhereInput[]
    OR?: CustomFormScalarWhereInput[]
    NOT?: CustomFormScalarWhereInput | CustomFormScalarWhereInput[]
    id?: StringFilter<"CustomForm"> | string
    customFormId?: StringFilter<"CustomForm"> | string
    createdAt?: DateTimeFilter<"CustomForm"> | Date | string
    updatedAt?: DateTimeFilter<"CustomForm"> | Date | string
    personalId?: StringFilter<"CustomForm"> | string
    formTemplate?: StringFilter<"CustomForm"> | string
    formName?: StringFilter<"CustomForm"> | string
    createdDate?: DateTimeFilter<"CustomForm"> | Date | string
    updatedDate?: DateTimeFilter<"CustomForm"> | Date | string
  }

  export type PersonalDetailsCreateWithoutEmploymentDetailsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutEmploymentDetailsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutEmploymentDetailsInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutEmploymentDetailsInput, PersonalDetailsUncheckedCreateWithoutEmploymentDetailsInput>
  }

  export type PersonalDetailsUpsertWithoutEmploymentDetailsInput = {
    update: XOR<PersonalDetailsUpdateWithoutEmploymentDetailsInput, PersonalDetailsUncheckedUpdateWithoutEmploymentDetailsInput>
    create: XOR<PersonalDetailsCreateWithoutEmploymentDetailsInput, PersonalDetailsUncheckedCreateWithoutEmploymentDetailsInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutEmploymentDetailsInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutEmploymentDetailsInput, PersonalDetailsUncheckedUpdateWithoutEmploymentDetailsInput>
  }

  export type PersonalDetailsUpdateWithoutEmploymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutEmploymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutIncomeDetailsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutIncomeDetailsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutIncomeDetailsInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutIncomeDetailsInput, PersonalDetailsUncheckedCreateWithoutIncomeDetailsInput>
  }

  export type PersonalDetailsUpsertWithoutIncomeDetailsInput = {
    update: XOR<PersonalDetailsUpdateWithoutIncomeDetailsInput, PersonalDetailsUncheckedUpdateWithoutIncomeDetailsInput>
    create: XOR<PersonalDetailsCreateWithoutIncomeDetailsInput, PersonalDetailsUncheckedCreateWithoutIncomeDetailsInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutIncomeDetailsInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutIncomeDetailsInput, PersonalDetailsUncheckedUpdateWithoutIncomeDetailsInput>
  }

  export type PersonalDetailsUpdateWithoutIncomeDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutIncomeDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutExpensesDetailsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutExpensesDetailsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutExpensesDetailsInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutExpensesDetailsInput, PersonalDetailsUncheckedCreateWithoutExpensesDetailsInput>
  }

  export type PersonalDetailsUpsertWithoutExpensesDetailsInput = {
    update: XOR<PersonalDetailsUpdateWithoutExpensesDetailsInput, PersonalDetailsUncheckedUpdateWithoutExpensesDetailsInput>
    create: XOR<PersonalDetailsCreateWithoutExpensesDetailsInput, PersonalDetailsUncheckedCreateWithoutExpensesDetailsInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutExpensesDetailsInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutExpensesDetailsInput, PersonalDetailsUncheckedUpdateWithoutExpensesDetailsInput>
  }

  export type PersonalDetailsUpdateWithoutExpensesDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutExpensesDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutAssetsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutAssetsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutAssetsInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutAssetsInput, PersonalDetailsUncheckedCreateWithoutAssetsInput>
  }

  export type PersonalDetailsUpsertWithoutAssetsInput = {
    update: XOR<PersonalDetailsUpdateWithoutAssetsInput, PersonalDetailsUncheckedUpdateWithoutAssetsInput>
    create: XOR<PersonalDetailsCreateWithoutAssetsInput, PersonalDetailsUncheckedCreateWithoutAssetsInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutAssetsInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutAssetsInput, PersonalDetailsUncheckedUpdateWithoutAssetsInput>
  }

  export type PersonalDetailsUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutLiabilitiesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutLiabilitiesInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutLiabilitiesInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutLiabilitiesInput, PersonalDetailsUncheckedCreateWithoutLiabilitiesInput>
  }

  export type PersonalDetailsUpsertWithoutLiabilitiesInput = {
    update: XOR<PersonalDetailsUpdateWithoutLiabilitiesInput, PersonalDetailsUncheckedUpdateWithoutLiabilitiesInput>
    create: XOR<PersonalDetailsCreateWithoutLiabilitiesInput, PersonalDetailsUncheckedCreateWithoutLiabilitiesInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutLiabilitiesInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutLiabilitiesInput, PersonalDetailsUncheckedUpdateWithoutLiabilitiesInput>
  }

  export type PersonalDetailsUpdateWithoutLiabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutLiabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutGoalsAndWishesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutGoalsAndWishesInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutGoalsAndWishesInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutGoalsAndWishesInput, PersonalDetailsUncheckedCreateWithoutGoalsAndWishesInput>
  }

  export type PersonalDetailsUpsertWithoutGoalsAndWishesInput = {
    update: XOR<PersonalDetailsUpdateWithoutGoalsAndWishesInput, PersonalDetailsUncheckedUpdateWithoutGoalsAndWishesInput>
    create: XOR<PersonalDetailsCreateWithoutGoalsAndWishesInput, PersonalDetailsUncheckedCreateWithoutGoalsAndWishesInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutGoalsAndWishesInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutGoalsAndWishesInput, PersonalDetailsUncheckedUpdateWithoutGoalsAndWishesInput>
  }

  export type PersonalDetailsUpdateWithoutGoalsAndWishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutGoalsAndWishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutRiskAppetiteInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutRiskAppetiteInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutRiskAppetiteInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutRiskAppetiteInput, PersonalDetailsUncheckedCreateWithoutRiskAppetiteInput>
  }

  export type PersonalDetailsUpsertWithoutRiskAppetiteInput = {
    update: XOR<PersonalDetailsUpdateWithoutRiskAppetiteInput, PersonalDetailsUncheckedUpdateWithoutRiskAppetiteInput>
    create: XOR<PersonalDetailsCreateWithoutRiskAppetiteInput, PersonalDetailsUncheckedCreateWithoutRiskAppetiteInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutRiskAppetiteInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutRiskAppetiteInput, PersonalDetailsUncheckedUpdateWithoutRiskAppetiteInput>
  }

  export type PersonalDetailsUpdateWithoutRiskAppetiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutRiskAppetiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutConsentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutConsentsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutConsentsInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutConsentsInput, PersonalDetailsUncheckedCreateWithoutConsentsInput>
  }

  export type PersonalDetailsUpsertWithoutConsentsInput = {
    update: XOR<PersonalDetailsUpdateWithoutConsentsInput, PersonalDetailsUncheckedUpdateWithoutConsentsInput>
    create: XOR<PersonalDetailsCreateWithoutConsentsInput, PersonalDetailsUncheckedCreateWithoutConsentsInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutConsentsInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutConsentsInput, PersonalDetailsUncheckedUpdateWithoutConsentsInput>
  }

  export type PersonalDetailsUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutDocumentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutDocumentsInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutDocumentsInput, PersonalDetailsUncheckedCreateWithoutDocumentsInput>
  }

  export type PersonalDetailsUpsertWithoutDocumentsInput = {
    update: XOR<PersonalDetailsUpdateWithoutDocumentsInput, PersonalDetailsUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PersonalDetailsCreateWithoutDocumentsInput, PersonalDetailsUncheckedCreateWithoutDocumentsInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutDocumentsInput, PersonalDetailsUncheckedUpdateWithoutDocumentsInput>
  }

  export type PersonalDetailsUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutFormsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutFormsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    customForms?: CustomFormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutFormsInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutFormsInput, PersonalDetailsUncheckedCreateWithoutFormsInput>
  }

  export type PersonalDetailsUpsertWithoutFormsInput = {
    update: XOR<PersonalDetailsUpdateWithoutFormsInput, PersonalDetailsUncheckedUpdateWithoutFormsInput>
    create: XOR<PersonalDetailsCreateWithoutFormsInput, PersonalDetailsUncheckedCreateWithoutFormsInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutFormsInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutFormsInput, PersonalDetailsUncheckedUpdateWithoutFormsInput>
  }

  export type PersonalDetailsUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsCreateWithoutCustomFormsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
    coach: UserCreateNestedOneWithoutClientsAsCoachInput
    employmentDetails?: EmploymentDetailsCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateWithoutCustomFormsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coachId: string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
    employmentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    incomeDetails?: IncomeDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    expensesDetails?: ExpensesDetailsUncheckedCreateNestedManyWithoutPersonalDetailsInput
    assets?: AssetUncheckedCreateNestedManyWithoutPersonalDetailsInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutPersonalDetailsInput
    goalsAndWishes?: GoalsAndWishesUncheckedCreateNestedOneWithoutPersonalDetailsInput
    riskAppetite?: RiskAppetiteUncheckedCreateNestedOneWithoutPersonalDetailsInput
    consents?: ConsentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPersonalDetailsInput
    forms?: FormUncheckedCreateNestedManyWithoutPersonalDetailsInput
  }

  export type PersonalDetailsCreateOrConnectWithoutCustomFormsInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutCustomFormsInput, PersonalDetailsUncheckedCreateWithoutCustomFormsInput>
  }

  export type PersonalDetailsUpsertWithoutCustomFormsInput = {
    update: XOR<PersonalDetailsUpdateWithoutCustomFormsInput, PersonalDetailsUncheckedUpdateWithoutCustomFormsInput>
    create: XOR<PersonalDetailsCreateWithoutCustomFormsInput, PersonalDetailsUncheckedCreateWithoutCustomFormsInput>
    where?: PersonalDetailsWhereInput
  }

  export type PersonalDetailsUpdateToOneWithWhereWithoutCustomFormsInput = {
    where?: PersonalDetailsWhereInput
    data: XOR<PersonalDetailsUpdateWithoutCustomFormsInput, PersonalDetailsUncheckedUpdateWithoutCustomFormsInput>
  }

  export type PersonalDetailsUpdateWithoutCustomFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    coach?: UserUpdateOneRequiredWithoutClientsAsCoachNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutCustomFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachId?: StringFieldUpdateOperationsInput | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type AnalysisFormCreateManyUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultantName: string
    officeLocation: string
    analysisDate: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
    addLoanOrLeasing: boolean
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
    analysisConsent: boolean
    analysisConsentText: string
    analysisConsentSignature: string
    analysisLocation: string
    analysisConsentDate: Date | string
  }

  export type ImmobillionFormCreateManyUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType?: string
    formVersion?: string
  }

  export type PersonalDetailsCreateManyCoachInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantType: $Enums.ApplicantType
    firstName: string
    lastName: string
    streetAddress: string
    postalCode: string
    city: string
    phone: string
    email: string
    birthDate: Date | string
    birthPlace: string
    maritalStatus: string
    nationality: string
    housing: string
  }

  export type AnalysisFormUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUpdateManyWithoutAnalysisFormNestedInput
    applicants?: ApplicantUpdateManyWithoutAnalysisFormNestedInput
  }

  export type AnalysisFormUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutAnalysisFormNestedInput
    applicants?: ApplicantUncheckedUpdateManyWithoutAnalysisFormNestedInput
  }

  export type AnalysisFormUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultantName?: StringFieldUpdateOperationsInput | string
    officeLocation?: StringFieldUpdateOperationsInput | string
    analysisDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addLoanOrLeasing?: BoolFieldUpdateOperationsInput | boolean
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    analysisConsent?: BoolFieldUpdateOperationsInput | boolean
    analysisConsentText?: StringFieldUpdateOperationsInput | string
    analysisConsentSignature?: StringFieldUpdateOperationsInput | string
    analysisLocation?: StringFieldUpdateOperationsInput | string
    analysisConsentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImmobillionFormUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
    applicants?: ApplicantUpdateManyWithoutImmobillionFormNestedInput
  }

  export type ImmobillionFormUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
    applicants?: ApplicantUncheckedUpdateManyWithoutImmobillionFormNestedInput
  }

  export type ImmobillionFormUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: StringFieldUpdateOperationsInput | string
    formVersion?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalDetailsUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
    employmentDetails?: EmploymentDetailsUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
    employmentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    incomeDetails?: IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    expensesDetails?: ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    goalsAndWishes?: GoalsAndWishesUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    riskAppetite?: RiskAppetiteUncheckedUpdateOneWithoutPersonalDetailsNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    forms?: FormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
    customForms?: CustomFormUncheckedUpdateManyWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantType?: EnumApplicantTypeFieldUpdateOperationsInput | $Enums.ApplicantType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    streetAddress?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    housing?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email: string
    password: string
    displayName?: string | null
    emailVerified?: boolean
    profileImage?: string | null
    phoneNumber?: string | null
    firebaseUid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisForms?: AnalysisFormUpdateManyWithoutUserNestedInput
    immobillionForms?: ImmobillionFormUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUpdateOneWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisForms?: AnalysisFormUncheckedUpdateManyWithoutUserNestedInput
    immobillionForms?: ImmobillionFormUncheckedUpdateManyWithoutUserNestedInput
    personalDetails?: PersonalDetailsUncheckedUpdateOneWithoutUserNestedInput
    clientsAsCoach?: PersonalDetailsUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApplicantCreateManyImmobillionFormInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    analysisFormId?: string | null
  }

  export type ApplicantUpdateWithoutImmobillionFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    analysisForm?: AnalysisFormUpdateOneWithoutApplicantsNestedInput
    immobillionDetails?: ImmobillionApplicantDetailsUpdateOneWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutImmobillionFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    analysisFormId?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionDetails?: ImmobillionApplicantDetailsUncheckedUpdateOneWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateManyWithoutImmobillionFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    analysisFormId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChildCreateManyAnalysisFormInput = {
    id?: string
    firstName: string
    lastName: string
    birthDate: Date | string
    birthPlace: string
    nationality: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicantCreateManyAnalysisFormInput = {
    id?: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salutation?: string | null
    title?: string | null
    firstName: string
    lastName: string
    maidenName?: string | null
    birthDate: Date | string
    birthPlace: string
    birthCountry?: string | null
    nationality: string
    isEUCitizen?: boolean | null
    residencePermit?: string | null
    inGermanySince?: Date | string | null
    street: string
    houseNumber?: string | null
    postalCode: string
    city: string
    residentSince?: Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: string | null
    phoneMobile: string
    email: string
    taxId?: string | null
    maritalStatus: string
    separationOfGoods?: boolean | null
    numberOfChildren: number
    childrenBirthDates?: ApplicantCreatechildrenBirthDatesInput | Date[] | string[]
    profession: string
    employmentType?: string | null
    employedSince?: Date | string | null
    contractType: string
    contractUntil?: Date | string | null
    employerName?: string | null
    employerInGermany?: boolean | null
    netIncome: Decimal | DecimalJsLike | number | string
    grossIncome: Decimal | DecimalJsLike | number | string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    iban?: string | null
    bic?: string | null
    immobillionFormId?: string | null
  }

  export type ChildUpdateWithoutAnalysisFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildUncheckedUpdateWithoutAnalysisFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildUncheckedUpdateManyWithoutAnalysisFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicantUpdateWithoutAnalysisFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionForm?: ImmobillionFormUpdateOneWithoutApplicantsNestedInput
    immobillionDetails?: ImmobillionApplicantDetailsUpdateOneWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutAnalysisFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionFormId?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionDetails?: ImmobillionApplicantDetailsUncheckedUpdateOneWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateManyWithoutAnalysisFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    maidenName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    birthCountry?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: StringFieldUpdateOperationsInput | string
    isEUCitizen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    residencePermit?: NullableStringFieldUpdateOperationsInput | string | null
    inGermanySince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    residentSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAddress?: NullableJsonNullValueInput | InputJsonValue
    phoneLandline?: NullableStringFieldUpdateOperationsInput | string | null
    phoneMobile?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: StringFieldUpdateOperationsInput | string
    separationOfGoods?: NullableBoolFieldUpdateOperationsInput | boolean | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    childrenBirthDates?: ApplicantUpdatechildrenBirthDatesInput | Date[] | string[]
    profession?: StringFieldUpdateOperationsInput | string
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    employedSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractType?: StringFieldUpdateOperationsInput | string
    contractUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerInGermany?: NullableBoolFieldUpdateOperationsInput | boolean | null
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    immobillionFormId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmploymentDetailsCreateManyPersonalDetailsInput = {
    id?: string
    employmentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employmentType: $Enums.EmploymentType
    occupation: string
    contractType: string
    contractDuration: string
    employerName: string
    employedSince: Date | string
  }

  export type IncomeDetailsCreateManyPersonalDetailsInput = {
    id?: string
    incomeId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grossIncome: Decimal | DecimalJsLike | number | string
    netIncome: Decimal | DecimalJsLike | number | string
    taxClass: string
    taxId: string
    numberOfSalaries: number
    childBenefit: Decimal | DecimalJsLike | number | string
    otherIncome: Decimal | DecimalJsLike | number | string
    incomeTradeBusiness: Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork: Decimal | DecimalJsLike | number | string
    incomeSideJob: Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsCreateManyPersonalDetailsInput = {
    id?: string
    expensesId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coldRent: Decimal | DecimalJsLike | number | string
    electricity: Decimal | DecimalJsLike | number | string
    livingExpenses: Decimal | DecimalJsLike | number | string
    gas: Decimal | DecimalJsLike | number | string
    telecommunication: Decimal | DecimalJsLike | number | string
    accountMaintenanceFee: Decimal | DecimalJsLike | number | string
    alimony: Decimal | DecimalJsLike | number | string
    subscriptions: Decimal | DecimalJsLike | number | string
    otherExpenses: Decimal | DecimalJsLike | number | string
  }

  export type AssetCreateManyPersonalDetailsInput = {
    id?: string
    assetId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    realEstate: Decimal | DecimalJsLike | number | string
    securities: Decimal | DecimalJsLike | number | string
    bankDeposits: Decimal | DecimalJsLike | number | string
    buildingSavings: Decimal | DecimalJsLike | number | string
    insuranceValues: Decimal | DecimalJsLike | number | string
    otherAssets: Decimal | DecimalJsLike | number | string
  }

  export type LiabilityCreateManyPersonalDetailsInput = {
    id?: string
    liabilityId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loanType: $Enums.LoanType
    loanBank?: string | null
    loanAmount?: Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: Decimal | DecimalJsLike | number | string | null
    loanInterest?: Decimal | DecimalJsLike | number | string | null
  }

  export type ConsentCreateManyPersonalDetailsInput = {
    id?: string
    consentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consentType: $Enums.ConsentType
    consent: boolean
    consentText: string
    consentSignature: string
    consentDate: Date | string
    location: string
  }

  export type DocumentCreateManyPersonalDetailsInput = {
    id?: string
    documentId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentName: string
    documentLocation: string
    documentDate: Date | string
  }

  export type FormCreateManyPersonalDetailsInput = {
    id?: string
    formId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formType: $Enums.FormType
    formName: string
    formLink: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type CustomFormCreateManyPersonalDetailsInput = {
    id?: string
    customFormId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formTemplate: string
    formName: string
    createdDate: Date | string
    updatedDate: Date | string
  }

  export type EmploymentDetailsUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    occupation?: StringFieldUpdateOperationsInput | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractDuration?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    employedSince?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailsUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    occupation?: StringFieldUpdateOperationsInput | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractDuration?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    employedSince?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentDetailsUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    occupation?: StringFieldUpdateOperationsInput | string
    contractType?: StringFieldUpdateOperationsInput | string
    contractDuration?: StringFieldUpdateOperationsInput | string
    employerName?: StringFieldUpdateOperationsInput | string
    employedSince?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeDetailsUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxClass?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type IncomeDetailsUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxClass?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type IncomeDetailsUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grossIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxClass?: StringFieldUpdateOperationsInput | string
    taxId?: StringFieldUpdateOperationsInput | string
    numberOfSalaries?: IntFieldUpdateOperationsInput | number
    childBenefit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeTradeBusiness?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSelfEmployedWork?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeSideJob?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expensesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expensesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ExpensesDetailsUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expensesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coldRent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    electricity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    livingExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gas?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    telecommunication?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountMaintenanceFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alimony?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscriptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AssetUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AssetUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AssetUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    realEstate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankDeposits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    buildingSavings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    insuranceValues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LiabilityUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    liabilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | $Enums.LoanType
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LiabilityUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    liabilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | $Enums.LoanType
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LiabilityUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    liabilityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanType?: EnumLoanTypeFieldUpdateOperationsInput | $Enums.LoanType
    loanBank?: NullableStringFieldUpdateOperationsInput | string | null
    loanAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanMonthlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loanInterest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ConsentUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consent?: BoolFieldUpdateOperationsInput | boolean
    consentText?: StringFieldUpdateOperationsInput | string
    consentSignature?: StringFieldUpdateOperationsInput | string
    consentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type ConsentUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consent?: BoolFieldUpdateOperationsInput | boolean
    consentText?: StringFieldUpdateOperationsInput | string
    consentSignature?: StringFieldUpdateOperationsInput | string
    consentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type ConsentUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentType?: EnumConsentTypeFieldUpdateOperationsInput | $Enums.ConsentType
    consent?: BoolFieldUpdateOperationsInput | boolean
    consentText?: StringFieldUpdateOperationsInput | string
    consentSignature?: StringFieldUpdateOperationsInput | string
    consentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentLocation?: StringFieldUpdateOperationsInput | string
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentLocation?: StringFieldUpdateOperationsInput | string
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentLocation?: StringFieldUpdateOperationsInput | string
    documentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    formName?: StringFieldUpdateOperationsInput | string
    formLink?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    formName?: StringFieldUpdateOperationsInput | string
    formLink?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formType?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    formName?: StringFieldUpdateOperationsInput | string
    formLink?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFormUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customFormId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formTemplate?: StringFieldUpdateOperationsInput | string
    formName?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFormUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customFormId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formTemplate?: StringFieldUpdateOperationsInput | string
    formName?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFormUncheckedUpdateManyWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customFormId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formTemplate?: StringFieldUpdateOperationsInput | string
    formName?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}